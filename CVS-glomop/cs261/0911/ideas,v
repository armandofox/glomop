head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	98.09.11.19.10.03;	author iang;	state Exp;
branches;
next	;


desc
@@


1.1
log
@*** empty log message ***
@
text
@PRIMITIVES:

key length
key generation
gathering entropy in software
reseeding
zeroization

ways to make block ciphers stronger
  (e.g. multiple modes, iteration, -X construction;
  triple-des, meet-in-the-middle)

one-way function
collision-free function
hash function
prf
mac
  & lack of non-repudiability
when to use which

birthday paradox

public-key crypto
difference between decryption and signing
non-repudiability
##number theory intro
##RSA math
##pitfalls of implementing your own RSA
##  (e.g. padding, probabilistic encryption, etc.)

need for authentication of public keys
  man-in-the-middle attack, diffie-hellman
certificates
public-key infrastructure

the right tool for the right job
  when should you use public-key crypto, when will symmetric-key suffice?
  why does the web use SSL, but web browser for a pilot uses symmetric...
  number of keys needed: O(n) for pubkey, O(n^2) for symmetric-key
  cost of revocation vs cost of key-establishment in symmetrickey & pubkey
  order: compress then encrypt then encode (add redundancy)

good algorithms (e.g. triple-DES, SHA1, SHA1-HMAC, D-H, RSA)
don't bother implementing your own
(anyone can create a cryptosystem that they can't themself break)



PROTOCOLS


key-transport protocols
key-agreement protocols
perfect forward secrecy

EKE, etc.

pitfalls of session-layer crypto
  (e.g. always mac everything, append random padding, etc.)
examples: ssl, ipsec

protocols
examples of bad protocols
one good protocol

techniques:
hash chaining (e.g. for s/key, payword, certificate revocation, etc.)
timestamping

protocol failures

PGP's problem with fingerprints
@
