head	1.14;
access;
symbols
	prewink:1.12
	stable:1.11
	release:1.9
	current:1.14
	initial:1.1.1.1
	initial:1.1.1;
locks; strict;
comment	@# @;


1.14
date	96.08.23.19.35.51;	author gribble;	state Exp;
branches;
next	1.13;

1.13
date	96.07.26.20.30.46;	author fox;	state Exp;
branches;
next	1.12;

1.12
date	96.06.23.01.33.00;	author fox;	state Exp;
branches;
next	1.11;

1.11
date	96.06.11.02.17.23;	author fox;	state Exp;
branches;
next	1.10;

1.10
date	96.06.07.00.33.46;	author fox;	state Exp;
branches;
next	1.9;

1.9
date	96.06.04.01.25.56;	author fox;	state Exp;
branches;
next	1.8;

1.8
date	96.05.25.02.45.55;	author fox;	state Exp;
branches;
next	1.7;

1.7
date	96.05.22.23.59.16;	author fox;	state Exp;
branches;
next	1.6;

1.6
date	96.05.03.23.09.03;	author fox;	state Exp;
branches;
next	1.5;

1.5
date	96.04.28.00.41.40;	author fox;	state Exp;
branches;
next	1.4;

1.4
date	96.04.26.10.12.04;	author fox;	state Exp;
branches;
next	1.3;

1.3
date	96.04.24.08.15.51;	author fox;	state Exp;
branches;
next	1.2;

1.2
date	96.04.24.08.13.32;	author fox;	state Exp;
branches;
next	1.1;

1.1
date	96.04.24.06.12.18;	author fox;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.04.24.06.12.18;	author fox;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Did a complete merge with the source tree from Wink, and got refinement and
Kerberos authentication working again.  Many, many little subtle changes.
The refinement path was changed to "./gmtmpXXX/I1" from an absolute path
name, which broke some regexps.  Fixing that helped, as well as calling
the determine_htype function with a filename instead of undef.
@
text
@# $Id: bytestream.pl,v 1.2 96/08/22 14:43:35 glomop Exp $
=head1 NAME

bytestream -  Support for the bytestream protocol defined in hsk.txt

=head1 SYNOPSIS

 require "bytestream.pl";

 # Message writing

 $msg = &Msg::pack_msg($flags,@@args,@@types);
 &Msg::raw_write([$fh,]$msg);
 &Msg::send_immediate_error($errstr);

 # Message receiving

 $msg_type = &Msg::read_generic([$fh]);
 @@stuff = &Msg::unpack_msg(@@template);

 # Low-level stuff

 &Msg::set_buffer($name);
 &Msg::putback($thing);
 $bytes = &Msg::read_block($fh,$nbytes);
 $thing= &Msg::read_str1;
 $thing= &Msg::read_str2;
 $thing= &Msg::read_i16;
 $thing= &Msg::read_i32;
 $thing= &Msg::read_byte;
 $packed_str1 = &Msg::pack_str1($string);
 $packed_str2 = &Msg::pack_str2($string);
 $packed_i16 = &Msg::pack_i16($num);
 $packed_i32 = &Msg::pack_i32($num);
 $packed_byte = &Msg::pack_byte($val);

=head1 DESCRIPTION

Implements the bytestream protocol: message packing and unpacking, receiving,
etc.  This is not a class; it is a package.  The functions are meant to be
called as subroutines, not methods, and the package is stateful.

=head1 MESSAGE SENDING FUNCTIONS

=over 3

=item $msg = &Msg::pack_msg($flags,@@args,@@types);

Returns a ready-to-send message.  $flags is the flags byte; see L<msgdefs(3)>
for some values you can pull out of hsk.txt via predefined macros.  @@args is
the list of message arguments, and @@types the list of their respective types.
Each type must be a string: one of C<str1>, C<str2>, C<i16>, C<i32>, C<byte>.
You can then (if you want) call L</"raw_write"> to send the message to the
client.

=item &Msg::raw_write([$fh,]$msg);

Writes the $msg verbatim to the client.  If $fh is specified B<(not
recommended)>, the message is written to that filehandle rather than to the
client.  Unbuffered writes (syswrite) are used, though low-level network
interface buffering may occur.

=item &Msg::send_immediate_error($errstr);

Constructs a protocol-level error message containing the given message string
and sends it to the client.  Basically a shorthand for constructing and sending
a msg_err (see hsk.txt) yourself.

=back

=head1 MESSAGE RECEIVING FUNCTIONS

=over 3

=item $msg_type = &Msg::read_generic([$fh]);

Read a complete message into the buffer and return the first token.  The
message is decrypted/decompressed if necessary, and it is left in the buffer so
that further calls to the message receiving functions will work.  For example:

C<if (&Msg::read_generic() eq &Msg::OP_OPEN_DOC) {
   ($op,$doc_loc,$max,$id) = &Msg::receive_open_doc();
}>

If the function is called in an array context, it returns a two-element list:
the first token of the message, and the flags byte.  (Note that
decompression/decryption are still done automatically; examining the flags byte
just allows you to determine that these things occurred.)

=item @@stuff = &Msg::unpack_msg(@@template);

Attempt to read a message containing exactly the elements specified in
@@template.  Each element must be a string denoting a type: C<str1>, C<str2>,
C<i16>, C<i32>, C<byte>.  All reads are blocking; it is an error for some
received token not to match the next element in the template.  It's recommended
that you instead use L</"read_generic"> to determine what type of message you
got, and then use the appropriate function generated by L</"msgdefs"> to
actually extract the message body components.

=back

=head1 LOW-LEVEL FUNCTIONS

These are documented for completeness, but you normally shouldn't call them
directly; they're called from inside other functions.  

=over 3

=item &Msg::set_buffer($name);

Set the pushback buffer to a buffer named $name, creating it if necessary.
Useful if you want to avoid mucking with the main buffer.  To reset the
pushback buffer to be the main buffer, call this function with no arguments.

=item &Msg::putback($thing);

Put $thing back in the current buffer, so further calls will read it again.

=item $bytes = &Msg::read_block($fh,$nbytes);

Block until $nbytes bytes have been read from $fh.  Bytes in the current buffer
are used up first; if you want to avoid this, L</"set_buffer"> to an empty
buffer before calling read_block.  Only a signal can interrupt this function.
All other functions in this module ultimately call this function, and since it
is 
the one that deals with buffer management, L</"set_buffer"> calls implicitly
apply to all functions in this module.

=item $thing= &Msg::read_str1;
=item $thing= &Msg::read_str2;
=item $thing= &Msg::read_i16;
=item $thing= &Msg::read_i32;
=item $thing= &Msg::read_byte;

Perform blocking read for the given message token, and return the value of the
token.  For all of these, you can give an optional argument to use as the
filehandle, but B<it's not recommended.>

=item $packed_str1 = &Msg::pack_str1($string);
=item $packed_str2 = &Msg::pack_str2($string);
=item $packed_i16 = &Msg::pack_i16($num);
=item $packed_i32 = &Msg::pack_i32($num);
=item $packed_byte = &Msg::pack_byte($val);

Return a packed version of the given token. These can be aggregated together to
form a message, but you still need to construct the appropriate message header
(flags, length byte, etc.) For this reason, it's recommended that you instead
gather up all your arguments and call L</"pack_msg"> to construct a
ready-to-send message.

=back

=cut

package Msg;
use strict 'vars';

# Allowed token types for packing functions

$Msg::Types = "str1|str2|i16|i32";
$Msg::Bufname = 'Buf';
$Msg::Buf = '';

sub set_buffer { $Msg::Bufname = shift || 'Msg::Buf'; }

sub putback {
    my $thing = shift;
    substr($$Msg::Bufname,0,0) = $thing;
    return $thing;
}

sub read_block {
    my ($fh,$len) = @@_;
    my ($res)= '';
    my($count)=0;
    my($tmp)='';
    my($nread);

    &util::debug("bs", ">>>Reading $len bytes");

    # attempt to use characters from Buffer first

    if (length($$Msg::Bufname) >= $len) {
        $res = substr($$Msg::Bufname,0,$len);
        $$Msg::Bufname = substr($$Msg::Bufname,$len);
    }
    $count = length($res);

    while (($count < $len)) {
        $count += ($nread = sysread($fh, $tmp, $len-$count));
        $res .= $tmp;
        &util::debug("dump", (sprintf("res: " . "%02x " x length($res),
                                      unpack("C*",$res))));
        last unless $nread;
    }
    return $res;
}
    
#
#  Read a generic complete message, and put it in the buffer.  Decrypt message
#  using session key if it's encrypted.  Return the first token of the message
#  as a str1, or undef if the message has the error flag set
#
sub read_generic {
    my ($f) = shift || STDIN;
    my $len = eval {&read_i16($f)};
    return undef if $@@;
    my $flags = eval { &read_byte($f) };
    return undef if $@@;
    my $msg = eval { &read_block($f, $len-1) };
    return undef if $@@;

    # if flags byte has error bit set, error.

    return undef if ($flags & &FLAG_MSG_ERROR);

    # if encrypted, decrypt it here.

    # BUG::need to do this

    # put the whole message in the "real" buffer.
    # BUG::this should not make explicit reference to pack templates!! (but
    # 'pack' doesn't work properly with a single list arg)
    &putback(pack("n",$len) . pack("C",$flags) . $msg);

    # extract str1 from msg, but put it right back in front of buffer since we
    # don't actually want to consume it.  Do this by copying the message body
    # into a 'fake' buffer and temporarily consuming stuff out of that buffer,
    # then switching back to real buffer when done.

    $Msg::CopyBuf = $msg;
    &set_buffer('Msg::CopyBuf');
    my $first_tok = eval { &read_str1($f) };
    &set_buffer();
    
    if ($@@) {
        &util::debug("dump", "*** Eval warning: $@@");
        return (wantarray? () : undef);
    } else {
        &util::debug("dump", "*** Returning $first_tok ***");
        return (wantarray? ($first_tok,$flags) : $first_tok);
    }
}

# Read tokens from a file descriptor (default is STDIN)

sub read_str1 {
    my $f = shift || STDIN;
    my $str = '';
    my $len_rcv;
    my $len = &read_byte($f);

    return "" if ($len == 0);
    &util::debug("dump", "read_str1: reading $len bytes");
    die "Read_Block: $len_rcv" if
        (($len_rcv=length($str=&read_block($f, $len))) != $len);
    &util::debug("dump", "read_str1: returning ($len)$str" );
    return $str;
}

sub read_str2 {
    my $f=shift || STDIN;
    my $str = '';
    my $len_rcv;
    my $len = &read_i16($f);

    return "" if ($len == 0);
    &util::debug("dump", "read_str2: reading $len bytes");
    die "Read_Block: $len_rcv" if
        (($len_rcv=length($str=&read_block($f, $len))) != $len);
    &util::debug("dump", "read_str2: returning ($len)$str" );
    return $str;
}

sub read_byte {
    my $f=shift || STDIN;
    my $str = '';
    my $len = '';
    my $rd;
    $len = &read_block($f, 1);
    $rd = (unpack("C",$len))[0];
    &util::debug("dump", "read_byte: returning $rd");
    return $rd;
}
    
sub read_i16 {
    my $f=shift || STDIN;
    my $str = '';
    my $len = '';

    $len = &read_block($f, 2);
    my $rd = (unpack("n",$len))[0];
    &util::debug("dump", "read_i16: returning $rd");
    return $rd;
}

sub read_i32 {
    my $f=shift || STDIN;
    my $str = '';
    my $len = '';
    my $rd = '**BAD**';
    $len = &read_block($f, 4);
    $rd = (unpack("N",$len))[0];
    &util::debug("dump", "read_i32: returning $rd" );
    return $rd;
}

# raw write to file descriptor (default = STDIN)

sub raw_write {
    my $data = pop @@_;
    my $f = shift || STDIN;
    &util::debug("dump", "*** Raw_write: " .
                 sprintf("%02x " x length($data), unpack("C*",$data)));
    syswrite($f, $data, length($data));
}

# Following routines return tokens

sub byte { return("C", 0+$_[0]); }
sub pack_byte { pack("C", 0+$_[0]) }

sub i16 { return("n", 0+$_[0]); }
sub pack_i16 { pack("n", 0+$_[0]) }

sub i32 { return("N", 0+$_[0]); }
sub pack_i32 { pack("N", 0+$_[0]) }

sub str1 {
    my $l = length($_[0]);
    if ($l) {
        return "Ca$l",$l,$_[0];
    } else {
        # null string
        return 'x';
    }
}
sub pack_str1 { my ($p,@@q) = &str1($_[0]); return pack($p,@@q); }

sub str2 {
    my $l = length($_[0]);
    if ($l) {
        return "na$l",$l,$_[0];
    } else {                                # null str
        return 'xx';
    }
}
sub pack_str2 { my ($p,@@q) = &str2($_[0]); return pack($p,@@q); }

sub send_immediate_error {
    my $errstr = shift;

    eval {&raw_write(&pack_msg(&FLAG_MSG_ERROR, $errstr, "str2")) }
}

sub pack_msg {
    my $flags = shift;
    my @@ary = @@_;

    my @@packlist;
    my $val;
    my @@res;
    my $tmpl = '';
    my $msg;
    
    return (undef, "Odd number of elts in msg list")
        unless $#ary & 1;

    my @@types = @@ary[($#ary+1)/2 .. $#ary];
    @@ary = @@ary[0 .. ($#ary/2)];

    &util::debug("dump", "pack_msg: packing $#ary+1 values: @@ary");
    while (defined($val = shift @@ary)) {
        $_ = shift @@types;
        return (undef, "Bad type $_")
            unless /$Msg::Types/o;
        @@res = &{$_}($val);
        $tmpl .= (shift @@res);
        push(@@packlist,@@res);
    }
    &util::debug("dump", "pack_msg: template '$tmpl' for $#packlist+1 values");
    $msg =  pack($tmpl, @@packlist);
    # form the complete packet by prepending the 2 length bytes and flags byte
    return pack("nC".$tmpl, 1+length($msg), $flags, @@packlist);
}
            
sub unpack_msg {
    my $file = STDIN;
    my @@tmpl = @@_;
    my @@res;
    my $count = 0;
    my ($msglen, $msgflags);
    my @@tmp;

    $msglen = &read_i16($file);
    $msgflags = &read_byte($file);

    &util::debug("dump", "unpack_msg: file=$file, len=$msglen, flags=$msgflags, template is @@tmpl\n");
    foreach (@@tmpl) {
        (&util::debug("bs", ("Bad type $_ in message")),
         return (undef, "Bad type $_"))
            unless /$Msg::Types/o;
        &util::debug("bs", "unpack_msg: reading type $_");
        push(@@res, &{"read_".$_}($file));
        $count++;
    }
    &util::debug("bs", "unpack_msg: $count items" );
    return (undef, "Empty message") if $count==0;
    return @@res;
}

sub loopback_test {

    my ($tmpl,@@tmpl,$vals,@@vals);
    my @@packlist;
    my $type;
    my (@@y,@@z,@@m,$msg,@@p,$i,@@res);
    my $Debug =1;
    while (1) {
        print STDERR "Msg template and vals:";
        chomp($msg = <STDIN>);
        @@m = split(/\s+/,$msg);
        @@z = @@m[($#m+1)/2 .. $#m];
        @@y= @@m[0 .. $#m/2];
        #@@p = &pack_msg(0,@@m);
        @@p = &pack_msg(0,@@y,@@z);
        print "Typelist: @@z\n";
        if (defined($p[0])) {
            open(T,">/tmp/msgtest") or die $!;
            print T $p[0];
            close T;
            open(T,"/tmp/msgtest") or die $!;
            my $f = 'Msg::T';
            print STDERR "Unpacking msg:";
            @@res = &unpack_msg($f,@@z);
            if (defined($res[0])) {
                for ($i=0;$i<=$#res;$i++) {
                    print "->$res[$i]<-";
                    print "***mismatch" unless $res[$i] eq $y[$i];
                    print "\n";
                }
            } else {
                &util::debug("bs", "Unpack error: $res[1]\n");
            }
            close  T;
            next;
        } else {
            &util::debug("bs", "Pack error: $p[1]\n");
        }
    }
}


=head1 COPYRIGHT

Copyright (C) 1994-1996 by the Regents of the University of California.
Commercial and non-commercial licenses to use this software must be arranged by
the GloMop Group at UC Berkeley.  For inquiries email Armando Fox
<fox@@cs.berkeley.edu>, Prof. Eric Brewer <brewer@@cs.berkeley.edu>, or
Prof. Randy Katz <randy@@cs.berkeley.edu>.

=cut    

1;
@


1.13
log
@segmgr renamed to chunk.  lots of changes including new html parser,
rudimentary layout manager, beginnings of interface to ptm, modularized
front-end vs back-end distiller components (but interfaces aren't really
stabilized yet).
@
text
@d1 1
d452 11
@


1.12
log
@Added extensive documentation in the form of embedded perlpod.
@
text
@d155 1
d159 3
a161 3
$Types = "str1|str2|i16|i32";
$Bufname = 'Buf';
$Buf = '';
d163 1
a163 1
sub set_buffer { $Bufname = shift || 'Buf'; }
d167 1
a167 1
    substr($$Bufname,0,0) = $thing;
d173 4
a176 4
    local ($res)= '';
    local($count)=0;
    local($tmp)='';
    local($nread);
d182 4
a185 2
    $res = substr($$Bufname,0,$len);
    $$Bufname = substr($$Bufname,$len);
d230 2
a231 2
    $CopyBuf = $msg;
    &set_buffer(CopyBuf);
d300 1
a300 1
    my $rd;
d344 1
a344 1
        return 'x';
d375 1
a375 1
            unless /$Types/o;
d401 1
a401 1
            unless /$Types/o;
d417 1
a417 1
    $Debug =1;
d432 1
a432 1
            $f = 'Msg::T';
@


1.11
log
@Image fetching and segmenting works end-to-end, but no error checking in
place yet.
@
text
@d1 152
a152 3
#
#  Support for the bytestream protocol defined in hsk.txt
#
d234 1
a234 1
        return undef;
d237 1
a237 1
        return $first_tok;
@


1.10
log
@Added utilities file (with debugging stuff and generalization of
instance-variable access for various classes), and segment manager
(provides generic segmentation services).  'tm' submodule will contain
high-level document type (htype) "chunkers".  added close_doc message to
hsk.txt.
@
text
@d168 1
d171 1
d174 1
d185 1
d195 1
@


1.9
log
@Semi-runnable state; allows auth handshake and OD (open doc) requests
seem to work.
@
text
@d28 1
a28 1
    warn ">>>Reading $len bytes";
a36 1
        warn "count=$count len=$len\n";
d39 2
a40 1
        warn (sprintf("res: " . "%02x " x length($res), unpack("C*",$res)));
a42 2

    warn "**Done**";
d84 1
a84 1
        warn "*** Eval warning: $@@";
d87 1
a87 1
        warn "*** Returning $first_tok ***";
d101 1
a101 1
    warn "read_str1: reading $len bytes" if $Debug;
d104 1
a104 1
    warn "read_str1: returning ($len)$str" if $Debug;
d115 1
a115 1
    warn "read_str2: reading $len bytes" if $Debug;
d118 1
a118 1
    warn "read_str2: returning ($len)$str" if $Debug;
d129 1
a129 1
    warn "read_byte: returning $rd" if $Debug;
d140 1
a140 1
    warn "read_i16: returning $rd" if $Debug;
d151 1
a151 1
    warn "read_i32: returning $rd" if $Debug;
d160 2
a161 1
    warn "*** Raw_write: " . sprintf("%02x " x length($data), unpack("C*",$data));
d214 1
a214 1
    warn "pack_msg: packing $#ary+1 values: @@ary" if $Debug;
d223 1
a223 1
    warn "pack_msg: template '$tmpl' for $#packlist+1 values" if $Debug;
d240 1
a240 2
    warn "unpack_msg: file=$file, len=$msglen, flags=$msgflags, template is @@tmpl\n"
        if $Debug;
d242 2
a243 1
        warn ("Bad type $_ in message"),return (undef, "Bad type $_")
d245 1
a245 1
        warn "unpack_msg: reading type $_" if $Debug;
d249 1
a249 1
    warn "unpack_msg: $count items" if $Debug;
d285 1
a285 1
                warn "Unpack error: $res[1]\n";
d290 1
a290 1
            warn "Pack error: $p[1]\n";
@


1.8
log
@no longer a need for http transport mgr; using LWP perl module.
completed multilanguage support for msgdef generation.  added messages
for doc open and chunk xmission to hsk.txt.  added monitor calls for
showing open documents.  modified testdrv to use as generic send/receive
of any messags defined in hsk.txt.  began working on doc.pl document
abstraction.
@
text
@d10 1
d13 2
d17 1
a17 1
    substr($Buf,0,0) = $thing;
d32 2
a33 2
    $res = substr($Buf,0,$len);
    $Buf = substr($Buf,$len);
d59 1
a59 1
    my $msg = eval { &read_block($f, $len) };
d70 5
d76 3
a78 1
    # don't actually want to consume it.
d80 2
d83 9
a91 3
    &putback($first_tok);
    return undef if $@@;
    return $first_tok;
d167 2
@


1.7
log
@moved some globals into config file.  first cut at mainloop.  created
directories for front-end servers, transport managers, and doc type
segmenters.  split out message-parsing-code generation so that various
language back-ends can be used, allowing message code to be generated
automatically for clients in different languages; say 'perl5 msgdefs.pl
<lang>' to do it.
@
text
@d172 7
a178 1
    
@


1.6
log
@Added support for monitoring (to external GUI monitor) in mon.pl.
currently talks to tcl/tk monitor app via udp packets.
@
text
@d10 7
d24 9
a32 1
    
d41 1
d45 30
d269 2
@


1.5
log
@Kerberos handshake works.  Need to put in code to actually check fields
of received packets, timestamps, etc., and remove debugging printf's.
@
text
@d23 1
a23 1
        last unless defined $nread;
@


1.4
log
@*** empty log message ***
@
text
@d11 19
d35 1
d37 1
d40 2
a41 1
    die "Sysread: $!" if (sysread($f, $str, $len) != $len);
d49 1
d51 1
d54 2
a55 1
    die "Sysread: $!" if (sysread($f, $str, $len) != $len);
d65 1
a65 1
    die "Sysread: $!" if (sysread($f, $len, 1) != 1);
d76 1
a76 1
    die "Sysread: $!" if (sysread($f, $len, 2) != 2);
d87 1
a87 1
    die "Sysread: $!" if (sysread($f, $len, 4) != 4);
d98 1
d172 2
a173 1
        return (undef, "Bad type $_") unless /$Types/o;
@


1.3
log
@*** empty log message ***
@
text
@d11 1
a11 1
# Read tokens from a file descriptor
d14 1
a14 1
    my $f = shift;
d20 1
d25 1
a25 1
    my $f=shift;
d31 1
d36 1
a36 1
    my $f=shift;
d47 1
a47 1
    my $f=shift;
d58 1
a58 1
    my $f=shift;
d68 8
d133 1
a133 1
    my $file = shift;
@


1.2
log
@*** empty log message ***
@
text
@d119 1
a119 1
    return pack("nC".$tmpl, length($msg), $flags, @@packlist);
@


1.1
log
@Initial revision
@
text
@d16 1
a16 4
    my $len = '';
    my $rd;
    die "Sysread: $!" if (sysread($f, $len, 1) != 1);
    $len = unpack("C", $len);
d26 1
a26 4
    my $len = '';
    my $rd;
    die "Sysread: $!" if (sysread($f, $len, 2) != 2);
    $len = unpack("n",$len);
d39 3
a41 1
    return (unpack("C",$len))[0];
d48 1
a48 1
    my $rd;
d50 3
a52 1
    return (unpack("n",$len))[0];
d61 3
a63 1
    return (unpack("N",$len))[0];
d92 3
d99 1
a99 2
    my $flags = shift;
    my @@ary = @@_;
d117 3
a119 1
    return pack($tmpl, @@packlist);
d124 1
a124 1
    my @@tmpl = (ref($_[0]) eq 'ARRAY' ? @@{$_[0]} : split(/\s+/,$_[0]));
d127 1
a127 1
    my $msglen, $msgflags;
d130 2
a131 7
    @@msglen = &read_i16($file);
    if (!defined ($msglen[0])) {
        warn "unpack_msg: Can't read msg len" if $Debug;
        return undef;
    }
    $msglen = $msglen[1];
    @@msgflags = &read_byte($file);
d133 2
a134 8
    if (!defined ($msglen[0])) {
        warn "unpack_msg: Can't read msg flags" if $Debug;
        return undef;
    }
    $msgflags = $msgflags[1];
    

    warn "unpack_msg: file=$file, template is @@tmpl" if $Debug;
d137 1
d157 4
a160 3
        @@p = &pack_msg(0,@@m);
        @@z = @@y= ();
        while (defined($_ = shift @@m)) { push(@@y,$_); push(@@z,shift @@m); }
d169 1
a169 1
            @@res = &unpack_msg($f,\@@z);
a185 1

@


1.1.1.1
log
@gmproxyd, for real. All Proxy perl code will live here.
@
text
@@
