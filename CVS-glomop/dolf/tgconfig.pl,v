head	1.6;
access;
symbols;
locks; strict;
comment	@# @;


1.6
date	96.12.03.10.01.29;	author gribble;	state Exp;
branches;
next	1.5;

1.5
date	96.12.03.09.39.05;	author fox;	state Exp;
branches;
next	1.4;

1.4
date	96.12.03.08.50.08;	author gribble;	state Exp;
branches;
next	1.3;

1.3
date	96.12.03.05.38.31;	author gribble;	state Exp;
branches;
next	1.2;

1.2
date	96.12.03.05.34.01;	author gribble;	state Exp;
branches;
next	1.1;

1.1
date	96.12.03.01.46.07;	author gribble;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Took out an extraneous print.
@
text
@#
# tgconfig.pl
#
# This file contains code that reads a typegraph from a configuration
# file, and is able to actually run a pipeline, given data, an input
# mimetype, and a list of tokens that were in the configuration file.
#

package tgconfig;
require "typegraph.pl";

# return a configuration object, which includes a typegraph object.  The
# first argument is the name of a configuration file.

sub new {
    my $class = shift(@@_);
    my $filename = shift(@@_);
    my $self = bless {
	"filename" => $filename,     # config file name
        "outarcs" => {},             # vertices (MIME types) that have outgoing arcs
        "inarcs" => {},              # vertices (MIME types) that have incoming arcs
	"token_to_inarg" => {},      # hash from token to "P" or "F"
	"token_to_outarg" => {},     # hash from token to "P" or "F"
	"token_to_pipe" => {},       # hash from token to pipline
	"token_to_sdpair" => {},     # hash from token to sdpair scalar
	"typegraph" => {}            # typegraph generated by accept_typegraph
	};
    $self->parse_configfile();
    return $self;
}

# returns the typegraph embedded in the config object
sub ret_tg {
    my $self = shift(@@_);
    return $self->{"typegraph"};
}

# given a token, returns an array with the source and destination
# mimetypes as the two elements.

sub token_arcs {
    my $self = shift(@@_);
    my $tok = shift(@@_);
    my ($retstr, @@tmparr, $ttosd);

    $ttosd = $self->{"token_to_sdpair"};
    $retstr = $$ttosd{$tok} or die "bogus token $tok passed to token_arcs";
    @@tmparr = split(/\s/, $retstr);
    return @@tmparr;
}

# given a MIME type, returns a defined value iff the MIME type corresponds to a
# vertex in the type graph with outgoing/incoming edges

sub is_source_type {
    my ($self, $type) = @@_;
    return defined($self->{"outarcs"}->{$type});
}

sub is_dest_type {
    my ($self, $type) = @@_;
    return defined($self->{"inarcs"}->{$type});
}

# parse_configfile will accept an unprepped tgconfig object, and will
# suck down a configuration file, and prep the object by building the
# pipe, inarg, and outarg hashes, and will build the typegraph by
# calling accept_typegraph for you.

sub parse_configfile {
    my $self = shift(@@_);            # tgconfig object
    my @@sd_array;
    my ($ttoi, $ttoo, $ttop, $ttosd, $tg);

    local($/) = "\n";
    $ttoi = $self->{"token_to_inarg"};
    $ttoo = $self->{"token_to_outarg"};
    $ttop = $self->{"token_to_pipe"};
    $ttosd = $self->{"token_to_sdpair"};

    open(CFGFILE, $self->{"filename"}) or die
	"Couldn't open config file " . $self->{"filename"} . "\n";
    while ($nextline = <CFGFILE>) {
	my ($im, $om, $tok, $inarg, $outarg, $pipe, $tmp);

	chomp($nextline);
	if ($nextline =~ /^(\s*)#/) {
	    next;
	}
	if (! (($im, $om, $tok, $inarg, $outarg, $pipe) =
	   ( $nextline =~ /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.+)$/ ))) {
	    next;
	}
	$tmp = "$im $om $tok FOO";
	push(@@sd_array, $tmp);
        $self->{"outarcs"}->{$im}++;
        $self->{"inarcs"}->{$om}++;
	$$ttoi{$tok} = $inarg;
	$$ttoo{$tok} = $outarg;
	$$ttop{$tok} = $pipe;
	$$ttosd{$tok} = "$im $om";
    }
    close(CFGFILE);
    $self->{"typegraph"} = new typegraph;
    $tg = $self->{"typegraph"};
    $tg->accept_typegraph(@@sd_array);
    return $self;
}

#
# do_conversion accepts an input buffer (a scalar) and a string which is
# a list of tokens (another scalar, e.g. "pstotext striphtml rsynth"),
# and performs the sequence of transformations specified by that list
# of tokens.  do_conversion returns the transformed data.
#

sub do_conversions {
    my $self = shift(@@_);
    my $data = shift(@@_);
    my $tokens = shift(@@_);
    my (@@tarray, $tmpdata);
    my ($ttoi, $ttoo, $ttop, $tg);

    $ttoi = $self->{"token_to_inarg"};
    $ttoo = $self->{"token_to_outarg"};
    $ttop = $self->{"token_to_pipe"};

    local($/) = "\n";
    @@tarray = split(/\s/, $tokens);
    foreach $nexttok (@@tarray) {
	my $ifilename = "/tmp/if_tgconf_$$";
	my $ofilename = "/tmp/of_tgconf_$$";
	my $cmdline = $$ttop{$nexttok};

	if ($$ttoi{$nexttok} eq "F") {
	    # write data out to $ifilename
	    # substitute "%IF" for $ifilename
	    $cmdline =~ s/^(.*)(\%IF)(.*)$/$1$ifilename$3/;
	}
	if ($$ttoo{$nexttok} eq "F") {
	    # substitute "%OF" for $ofilename
	    $cmdline =~ s/^(.*)(\%OF)(.*)$/$1$ofilename$3/;
	} else {
	    # add "> $ofilename" to cmdline
	    $cmdline = "$cmdline > $ofilename";
	}
	if ($$ttoi{$nexttok} eq "F") {
	    my $res;

	    # dump data to file and just run the command line
	    open(DUMPFILE, ">$ifilename") or die
		"couldn't open tmp file $ifilename for writing.\n";
	    print DUMPFILE $data;
	    close(DUMPFILE);
	    $res = system($cmdline) / 256;
	    if ($res) {
		die "system($cmdline) died with status $res";
	    }
	} else {
	    my $res;

	    $cmdline = "| $cmdline";
	    open(TGCMDLINE, $cmdline) or die
		"couldn't open pipeline '$cmdline'\n";
	    print TGCMDLINE $data;
	    close(TGCMDLINE);
	}
	
	# now suck back in the data
	open(SUCKFILE, $ofilename) or die
	    "couldn't open '$ofilename' for reading back in\n";
	local($/) = undef;
	$tmpfile = <SUCKFILE>;
	close(SUCKFILE);
	$data = $tmpfile;
	system("/bin/rm -f $ifilename");
	system("/bin/rm -f $ofilename");
    }
    return $data;
}
@


1.5
log
@*** empty log message ***
@
text
@a48 1
    print "tmparr is @@tmparr\n";
@


1.4
log
@Added token_arcs function for Armando.
@
text
@d20 2
d53 13
d97 2
@


1.3
log
@Final bugfixes.
@
text
@d23 1
d30 1
d36 15
d59 1
a59 1
    my ($ttoi, $ttoo, $ttop, $tg);
d65 1
d85 1
@


1.2
log
@Seems to all work OK now.

  1) Fixed up a few bugs in typegraph.pl that perl -w caught for me.
  2) Added tgconfig.pl, which parses and deals with config files, and
     runs conversion pipelines for you (not very efficiently, though).
  3) Added tgconfig.txt, which is a sample configuration file.
  4) Modified test.pl to try out the tgconfig.pl routines.
  5) Got some test data to try stuff out on.
@
text
@a54 1
	print "nextline is $nextline\n";
d93 1
@


1.1
log
@FOobar
@
text
@d26 6
d38 1
d42 6
d55 1
d65 78
d144 1
a144 1
    return @@sd_array;
@
