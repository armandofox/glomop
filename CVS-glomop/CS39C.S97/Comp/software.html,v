head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	97.04.10.22.08.43;	author fox;	state Exp;
branches;
next	;


desc
@@


1.1
log
@*** empty log message ***
@
text
@<html> <head>
<title>Not Just for Number Crunching Anymore</title>
</head>

<body>
<h1>Discussion: Not Just for Number Crunching Anymore</h1>

<h3>Turing</h3>

<ul>
  <li> "Practical" contribution: Bletchley Park COLOSSUS computer, used
       for decryption during WW2.  The exact nature of COLOSSUS' work is
       still classified by the British Government.  COLOSSUS was
       operational about two years before ENIAC.

<!--        <br><b> Anecdote about Winston Churchill? </b> -->
       
  <li> Theoretical contribution: computating == algorithm.  Something is
       computable if and only if you can write an algorithm or program
       that either computes the answer after finite time, or declares
       conclusively that no answer exists.
  <li> What's an algorithm?  Turing framed it in terms of a conceptual
       machine model, the <i>Turing machine</i>:
       <ul>
         <li> Infinitely long paper tape divided into "cells"; each cell
              can contain one <i>symbol</i>
         <li> "Read/write head" can sense what symbol the cell contains
         <li> Motor on the read/write head can make it move left or
              right along the tape, one step at a time
         <li> At any given time the machine can be in one of a number of
              <i>states</i>.
         <li> To determine what to do next, look at the current state
              and the contents of the cell under the R/W head.  The
              <i>rule list</i> tells you what to do to the tape and what
              the <i>next state</i> should be.  Possible tape actions
              are:
              <ul>
                <li> Move left
                <li> Move right
                <li> Write symbol
              </ul>
       </ul>
       <a href="http://www.cs.brown.edu/people/ng/Turing/tmachine.html">Turing
       machine demo!</a>
  <li> So, something is computable if and only if a Turing machine
       program can be written that computes the answer.
  <li> The Universal Turing Machine:
       <ul>
         <li> A Turing Machine is a conceptual device that reads
              instructions and carries them out by operating on a paper
              tape.
         <li> But, the act of doing this can itself be expressed as such
              a set of instructions.
         <li> Therefore, you can build a <i>universal Turing machine</i>
              that is capable of imitating (emulating) any other Turing
              machine.
         <li> This survives today as the concept of <i>Turing-complete
              languages</i>.
       </ul>
  <li> Other theoretical contributions:
       <ul>
         <li> The Turing Test: "Can a machine think?"
         <li> The Halting Problem: can you write a program that
              determines whether other programs will ever terminate?
         <li> The Church/Turing Thesis: Is human intelligence a
              Turing-computable function?
       </ul>
  <li> Which of Turing's contributions do you think has had more impact: the
       "practical" one (Bletchley Park) or the "theoretical" ones?
  <li> In your opinion, which is more worthy of the distinction "the 
       prototype of the modern digital computer": Colossus or ENIAC?
</ul>

<h3>Grace Murray Hopper, Compilers, and Bugs</h3>

<ul>
  <li> Why did I have you read the ENIAC Simulator Manual?
  <li> What is cool about the Turing machine model?

<!--        <br><b> -->
<!--        it separates the notion of stored-program computation from the -->
<!--        implementation.<br> -->
<!--         hint: how do you implement a TM? Toothpix? Paper/pencil? -->
<!--         Electronics?  In your head?  Out of bricks? <br></b> -->
       
  <li> What's cool about compilers?

<!--        <br><b> -->
<!--        They bridge the gap between Turing's world and ENIAC's.<br> -->
<!--         first "big" compiler was FORTRAN.  Was GMH just in the wrong  -->
<!--         place at the wrong time?? <br> -->
<!--         GMH's insight: symbol manipulation (like Turing!) <br> -->
<!--         examples:  sorting; string searching; operations on sets and  -->
<!--         lists (LISP) <br> -->
<!--        First error message ("missing comma").  Revolutionary!</b> -->

  <li> What do programs in these various languages look like?
       <ul>
         <li> <a
              href="http://www2.ecst.csuchico.edu/~mpeter/cobol.html">COBOL</a>
         <li> <a href="notes/geompak.for">FORTRAN</a>
         <li> <a href="">BASIC</a>
         <li> <a href="notes/search.lisp">LISP</a>
       </ul>
  <li> Which languages survive today?  Have any new ones been added?
  <li> <b>Coming soon:</b> The Computer Languages Family Tree; the
       Computer Company Family Tree; the Operating Systems Family Tree.
</ul>

<h3>The Lighter Side of Programming?</h3>

<ul>
  <li> Bush's MEMEX device: is this the Web?  Why didn't it get
       deployed?  (What was missing, or what were the limitations?)

<!--        <br><b>Captured ideas: photocopying, doc annotation/markup, -->
<!--        hyperlinks, groupware (merge link databases). <br> -->
<!--        Who remembers when it was written? -->
<!--        </b> -->

  <li> Are video games and graphics just symbol manipulation?
  <li> Is there anything that is <i>not</i> symbol manipulation?
  <li> What do you think was the reaction to this stuff at the time?
       (What had computers been used for up to that point?)

<!--        <br><b>Sketchpad, Spacewar, Pong - (broke the first day!)<br></b> -->
  <li> The living embodiment of <i>Dungeon</i>:  <tt>M-x dunnet</tt> in
       Emacs
</ul>

<hr>

<address>Copyright 1997 by Armando Fox, <a
href="mailto:fox@@cs.berkeley.edu">fox@@cs.berkeley.edu</a></address> 
<!-- hhmts start -->
<!-- hhmts end -->
</body> </html>
@
