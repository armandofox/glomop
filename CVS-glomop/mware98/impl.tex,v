head	1.29;
access;
symbols;
locks; strict;
comment	@% @;


1.29
date	98.06.04.23.15.37;	author gribble;	state Exp;
branches;
next	1.28;

1.28
date	98.06.04.20.46.56;	author gribble;	state Exp;
branches;
next	1.27;

1.27
date	98.06.04.00.32.42;	author fox;	state Exp;
branches;
next	1.26;

1.26
date	98.06.03.20.51.01;	author gribble;	state Exp;
branches;
next	1.25;

1.25
date	98.06.03.19.22.34;	author gribble;	state Exp;
branches;
next	1.24;

1.24
date	98.06.03.00.57.26;	author gribble;	state Exp;
branches;
next	1.23;

1.23
date	98.05.30.22.35.19;	author fox;	state Exp;
branches;
next	1.22;

1.22
date	98.05.30.00.38.27;	author fox;	state Exp;
branches;
next	1.21;

1.21
date	98.05.26.19.37.06;	author gribble;	state Exp;
branches;
next	1.20;

1.20
date	98.03.21.00.38.09;	author fox;	state Exp;
branches;
next	1.19;

1.19
date	98.03.20.21.52.55;	author gribble;	state Exp;
branches;
next	1.18;

1.18
date	98.03.20.19.53.24;	author gribble;	state Exp;
branches;
next	1.17;

1.17
date	98.03.19.22.52.46;	author gribble;	state Exp;
branches;
next	1.16;

1.16
date	98.03.19.21.41.04;	author gribble;	state Exp;
branches;
next	1.15;

1.15
date	98.03.19.20.22.04;	author fox;	state Exp;
branches;
next	1.14;

1.14
date	98.03.19.19.21.17;	author fox;	state Exp;
branches;
next	1.13;

1.13
date	98.03.19.06.47.41;	author fox;	state Exp;
branches;
next	1.12;

1.12
date	98.03.19.03.09.55;	author gribble;	state Exp;
branches;
next	1.11;

1.11
date	98.03.18.23.08.51;	author fox;	state Exp;
branches;
next	1.10;

1.10
date	98.03.18.22.33.22;	author fox;	state Exp;
branches;
next	1.9;

1.9
date	98.03.17.17.07.55;	author fox;	state Exp;
branches;
next	1.8;

1.8
date	98.03.17.17.02.07;	author fox;	state Exp;
branches;
next	1.7;

1.7
date	98.03.16.19.39.08;	author gribble;	state Exp;
branches;
next	1.6;

1.6
date	98.03.16.14.31.38;	author aspolito;	state Exp;
branches;
next	1.5;

1.5
date	98.03.15.00.59.12;	author fox;	state Exp;
branches;
next	1.4;

1.4
date	98.03.14.08.56.49;	author fox;	state Exp;
branches;
next	1.3;

1.3
date	98.03.12.19.26.59;	author fox;	state Exp;
branches;
next	1.2;

1.2
date	98.03.11.22.28.07;	author fox;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.00.36.19;	author fox;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Final edit.
@
text
@\section{ARCHITECTURE AND IMPLEMENTATION}
\label{impl}

%In this section we motivate the client-proxy-server architecture for
%applications such as Wingman, and briefly describe the TACC programming model
%our middleware provides.  This is followed by a detailed description of
%the Wingman implementation in terms of the TACC model and some
%performance data comparing Wingman to other browsers,  on both the
%PalmPilot and the desktop.

% Detailed description/implementation [DL,AP] - 2.5 pgs
%         Proxy implementation
%         Client implementation
%               screenshots, features, anecdotes, zip support, etc.
%         Interesting implementation details
%               ADU/ALF
%               2-bit hacks
%               screenshots
%         Performance (and specs: code size, mem usage, etc)
%                 compare to other browsers on Pilot [claim: AMWP gives
%                         better performance]
%                 compare to desktop performance [claim: AMWP is a better
%                         way to support legacy clients, even over
%                         existing  low-bw]
%                 compare features to both desktop and Pilot browsers:
%                         transparent upgrades, weird file format
%                         capabilities, extrapolate to possible other
%                         features like Powerpoint browsing [claim: AMWP
%                         enables richer feature set, for lower cost]
%               report Tbmp-munger as upper bound on expected latency
%               compare Perl html vs C html
%         TACC cluster server brief descr  [AF]
%                 scaling, F/T, availabilty; why important
%                 cost of operation [claim: cost effectiveness]
%                 BASE semantics; why good for this app [omit?]
%                 other TACC apps (1 paragraph) [claim: generalizable,
%                         means code can be re-used, etc]

% Client-proxy-server model [AF] - 1 pg
%         Middleware Philosophy: client/network variation
%         Examples of past middleware (TranSend, etc)
%         Building middleware apps with TACC (very brief)
%         Why a Web browser as a middleware app? (``horizontal'' vs
%            ``vertical'') 
%         Rough arch. of Wingman as a C-P-S app (general description only,
%            no details at this point; eg ``proxy transforms pages to
%            simple binary markup and serves them in simple ALF protocol'')

We argue for a {\em proxy-based approach} for middleware applications, in
which proxy agents placed between clients and servers perform computation-
and storage-intensive tasks, such as datatype-specific lossy compression,
on behalf of clients.  Properly applied, this approach reduces the
bandwidth demands on the infrastructure through lossy compression
\cite{pythia,sosp16}, and allows legacy and other nonstandard (including
thin) clients to interoperate with existing servers.

%\begin{figure}[tbh]
%\begin{tabular}{@@{}cc@@{}}
%\epsfxsize 0.60\hsize
%\makebox{
%\epsfbox[0 0 328 143]{./figures/cps.eps}
%}
%&
%\caption{\textbf{Client-proxy-server}
%applications rely on a middleware proxy to interact with servers on the
%client's behalf, and possibly perform value-added computation on the
%server data before passing it to the client.  The interaction is
%typically transparent to both clients and servers, as is the case with
%(for example) HTTP proxies.}
%\\
%\end{tabular}
%\end{figure}

%%% TBD refs to motivate transparent proxy-based approach; why thin clients
%%% and legacy clients are two sides of the same coin

Furthermore, by performing client adaptation at a shared infrastructural
proxy, we avoid inserting adaptation machinery at each origin server.
Application partitioning arguments have long been used to keep clients
simple (as in \cite{wit}); we simply split the application between
client and proxy, rather than between client and server.  From the
client's perspective, the proxy is simply a server that gets the data
from someplace else.

\subsection{TACC: A Programming Model for AMWP Applications}
\label{taccmodel}

We have evolved a programming model for proxy-based applications called TACC
\cite{casefortacc,sosp16}: 
{\em transformation} (distillation \cite{asplos}, filtering, format
conversion, etc.), {\em aggregation} (collecting and collating data from
various sources, either offline or on-the-fly), {\em caching} (both
original and transformed content), and {\em customization} (persistent
store of user profiles, allowing the service to tailor its output to each
user's needs or device characteristics).  Each {\em TACC worker}
specializes in a particular task, for example, scaling/dithering of images
in a particular format, conversion between specific data formats,
extracting ``landmark'' information from specific Web pages, etc.  Complete
applications are built by \textit{composing} workers, by {\em chaining}
them (in the Unix pipeline sense), or allowing one worker to {\em call}
another as a subroutine or (parallel, asynchronous) coroutine.  The {\em
dispatch rules} that determine which workers are invoked to satisfy a
particular user request can either be hardcoded for each application, or
controlled dynamically by the workers themselves.  A runtime platform
called a {\em TACC server} is expected to provide mechanisms for hosting
workers, instantiating dispatch rules, providing high availability, and
recovering from errors such as dispatch loops, infinite mutual recursion,
or worker instability; we describe our prototype TACC server in the next
section.

Workers serially process tasks from a task queue; each task
corresponds to some component of satisfying a user request, e.g. scaling
and transforming an inline image on a Web page.  Each worker is expected
to be \textit{atomic and restartable}, in order that the TACC server (a
prototype implementation of which we describe below) be able to exploit
a repertoire of availability and scaling mechanisms.  There are several
ways in which a worker can achieve this goal, including 
being completely stateless (as in Wingman),
performing only idempotent operations, or
sharing reconstructable group state via mechanisms such as Scalable
Reliable Multicast (SRM) \cite{srm}.

\textit{Customization} is central to TACC: the TACC server is expected
to manage persistent {\em user profiles} (lists of key/value pairs) that
allow workers to provide user-customized service.  The TACC server
identifies a user via incoming IP address, cookies, or some other
client-specific identifier, and automatically routes the appropriate
profile information to the worker(s) that will be used to satisfy the
request.  API's are provided for workers to modify or access profile
data directly, and to generate HTML forms that allow users to edit their
profiles without requiring direct worker involvement.

TACC provides a very general programming model that subsumes
transformation proxies
\cite{transend}, proxy filters \cite{proxyfilter}, customized
information aggregators, and search engines.  The TACC programming
environment, which currently consists of Unix-hosted interface files and build/test
harnesses, provides the inter-worker and intra-worker API's,
composition rule API's, and glue that allows workers to be authored in a
variety of languages (currently C/C++, Perl 5, Java, and Tcl).

\subsection{Scalable Cluster-Based TACC Server}

A {\em TACC server} is a platform that instantiates TACC workers and the
dispatch rules for routing network data traffic to and from them, and
provides support for the inter-worker calling and chaining API's.
Roughly,
a TACC
server is to TACC workers as the Unix shell and runtime are to Unix
programs.  Our decision to use a cluster of commodity PC's as the basis for
our TACC server implementation, as well as the design goals for the
cluster runtime software, were motivated by several
straightforward observations:
\begin{itemize}

\item The inherent hardware redundancy of clusters
can be harnessed to provide high system availability.

\item For ``embarrassingly parallel'' workloads
with favorable computation to communication
ratios, fast and inexpensive system-area networks
such as switched 100~Mb/s Ethernet or Myrinet \cite{MYRI_95} allow 
a cluster to be treated as a single large computing resource.

\item Using
commodity PC's as the unit of scaling allows the service to ride the
leading edge of the cost/performance curve as it is incrementally expanded.

\end{itemize}

\begin{figure}[tbh]
\epsfxsize 0.60\hsize
\epsfysize 0.30\vsize
\begin{center}
\makebox{
\epsfbox[0 0 340 303]{./figures/arch.eps}
}
\end{center}
\caption{{\bf Components of a cluster-based TACC server}
include front 
ends (FE), TACC workers (W) and caches (\$),
% $ to make emacs happy!!
a user profile database, a graphical monitor/administration interface,
and a fault-tolerant load
manager whose functionality logically extends into the manager stubs
(MS) and worker stubs (WS).}\label{arch_sns}
\end{figure}

We describe our system
architecture at a high level; a detailed description can be found in \cite{sosp16}.
The software-component block diagram of our scalable TACC server is shown
in Figure 
\ref{arch_sns}.  
{\em Front ends} receive client requests from the outside world and
``shepherd'' them through the system,
by fetching Internet content via the {\em caches},  matching the request
with the appropriate user profile from the {\em 
customization database},  and queueing the request for service by one or more
{\em TACC workers} that will process the data according to the user
preferences.   Front ends maximize system throughput by maintaining state for
many simultaneous outstanding requests, and can be replicated for both
scalability and availability.
The {\em Load Balancing/Fault Tolerance manager} is responsible for
internal reactive load balancing (including exploiting an {\em overflow
pool} of general-use machines), 
autostarting and reaping TACC workers, and
detecting and recovering from various system failures, including crashed
components and network partitions, via multicast heartbeat and
process-peer fault 
tolerance.
The entire system is administered through a 
{\em Graphical Monitor}, which supports asynchronous
error notification via email or pager, temporary disabling of system
components for hot upgrades, and visualization of the system's behavior
using Tcl/Tk \cite{tcltk}.  

Our working prototype of the cluster runtime
provides a set of mechanisms (described in \cite{sosp16})
to support incremental scaling,
internal load balancing,
and high availability for TACC applications.  Hiding this machinery 
behind the TACC API's keeps TACC applications 
easy to write even though they will be deployed to large user communities
who will expect continuous availability 
(so-called ``$24\times 7$ operation'').  
Our cluster has been hosting Wingman on
the Berkeley NOW (Network of Workstations) since October
1997, using four dedicated SPARCstation-10's and an
overflow pool of up to 100 SPARC Ultra-1 Enterprise servers, about
five of which are in use at any given time.

The availability mechanisms in the cluster runtime have kept the system
running virtually continuously\footnote{During February 1998, we
experienced frequent sporadic downtime, which was ultimately traced to a
configuration change on the cluster that caused remote execution to
sometimes break.}  despite a variety of observed failures (worker crashes,
temporary interconnect partitions, and unexpected node reboots, among
others), in addition to the aggressive fault-injection experiments
described in \cite{sosp16}.  Although (as described in that paper) the
cluster's availability mechanisms cannot completely mask front-end
failures, Wingman masks them using a client-side front-end failover
mechanism, similar to Netscape proxy auto-configuration
\cite{netscape_pac}.

\subsection{Wingman as a TACC Application}

The 3Com PalmPilot's austere graphics library supports a single native
bitmap format, and text objects are not automatically word-wrapped and must
consist entirely of text in a single visual style (bold, etc.).  The
principle of client competence (that the client should only perform tasks
for which it is competent) therefore suggests that HTML parsing and
tag-to-font mapping, page layout with client-specific font metrics, and
image scaling with conversion to native bitmap format all be left to the
TACC proxy.  The proxy side of the Wingman browser uses four TACC workers:
the image processor, the HTML processor, the zip processor, and the {\em
aggregator request service.}  The TACC model and API's allow parallelism to
be exploited in various ways; for example, all inline images are prefetched
in parallel with HTML parsing, and whenever possible multiple images are
converted in parallel by calling multiple workers.

%\begin{figure}[tbh]
%\epsfxsize 0.95\hsize
%\begin{center}
%% \makebox{
%% \epsfbox[0 0 340 303]{./figures/wingman_app.eps}
%% }
%\end{center}
%\caption{\textbf{Wingman's TACC workers}
%include the parser/executive, image conversion, and page layout, which
%is actually implemented as a library called by the executive.  The TACC
%model and API's allow parallelism to be exploited in various ways; for
%example, all inline images are prefetched in parallel with HTML parsing,
%and whenever possible multiple images are converted in parallel by
%calling multiple workers.}

%\end{figure}

%               screenshots, features, anecdotes, zip support, etc.

%  You can use the following text if you want, or else replace it.... i
%  started to write it and then realized it belongs in this section.

% NEED A BETTER NAME OTHER THAN AGGREGATOR REQUEST SERVICE


\subsubsection{Image and HTML Processors}

The {\bf image processor} reads GIF and JPEG images (the two most common
Web formats \cite{grib_97}), converts them to an intermediate bitmap form,
optionally scales, color-quantizes and dithers, and finally outputs the
result in either the PalmPilot's native image format (Tbmp) or our enhanced
2-bit-per-pixel format.
% Although the above
% steps are logically independent (and actually reside in separate files),
% it was more efficient to combine them into a single worker.  
 
% I'm actually not sure if what I wrote here is accurate.  It is
% my understanding of how the HTML munger works

The {\bf HTML processor} parses HTML markup, maps HTML tags to supported
font attributes, and generates an intermediate-form page layout.
Because the HTML processor knows the client's font metrics and display
properties, 
it can wrap text, flow text around inline images, etc.  (A client
identification token in the initial client-to-proxy handshake is
used to select the correct client profile.  The
layout code and intermediate layout form are client-independent.)

When inline image tags are encountered, the HTML processor fetches the image,
determines how much it should be scaled down using a simple set of
heuristics we developed,
\footnote{Roughly speaking, larger
images are shrunk more aggressively, imagemaps are
shrunk less aggressively to preserve embedded text,
and images are pinned to the screen size of the PalmPilot.}
% adds ``zoom-in'' information to allow later refinement by the user,
and dispatches the original image to an image processor to
do the actual scaling and format conversion.  Image processing is done
asynchronously and in parallel for all images; the HTML parser continues
laying out the page in the meantime, and arranges to rendezvous with the
image data before returning to the client a simple display
list of images and text, using a tokenized markup we have developed 
that allows the complete page (including all
inline images) to be sent as a single object.
%  The
% converted image is then cached by the HTML munger so that if the image
% found on the HTML page more than once there is no need to fetch and
% convert the image again.  

\subsubsection{Aggregators}

An {\it aggregator} queries one or more Web sites for specific content and
collates and formats the results for presentation to the client.  (The
Metacrawler \cite{metacrawler} service on the Web is a recent example of a
Web-based aggregator.)  Although Wingman's aggregator mechanism was
originally designed as a substitute for HTML forms support, aggregators
have become our general mechanism for retrieving information from multiple
content sources and filtering that information to best suit the needs of
the PalmPilot user.  The {\bf aggregator request service} allows access to
proxy-based content-aggregation applications.

In Wingman, an aggregator consists of a very simple PalmPilot-native UI
that allows the user to write some text describing what is being requested
(e.g. the query terms for a Web search, the ticker symbol for a stock
quote, etc.).  When the ``OK'' button is tapped, the contents of the form
are transmitted to the Wingman TACC proxy's aggregation worker.  The worker
uses the content of the first box to determine which service the user is
requesting (search engine, stock quote, etc.)  and the content of the
second box as parameters to the aggregator.  A site-specific aggregator
handler then converts this data to an HTML form submission on the proxy
side, and the results from the origin server are formatted by the HTML
processor.  We have deployed aggregators for Yahoo, HotBot, AltaVista,
DejaNews, Yahoo's stock quotes service, and TripQuest.

%%\begin{figure}[tbh]
%%\begin{tabular}{p{6cm}p{5.8cm}}
%%\parbox[b]{5cm}{{\bf Figure \ref{agg_interface}\hspace{0.05in} The Wingman
%%aggregator user interface:}  the example
%%aggregator shown is for the HotBot search engine.  The search terms in the
%%``Aggregator commands:'' text field will be passed to the HotBot aggregator
%%when the OK button is pressed, and the aggregator's results will be
%%transformed and sent back to the Wingman client.}
%%&
%%{\epsfxsize .80\hsize
%%\makebox{
%%\epsfbox[224 314 386 477]{./figures/aggregator_interface.epsi}
%%}
%%}
%%\\
%%\end{tabular}
%%\label{agg_interface}
%%\end{figure}

%\begin{figure}[tbh]
%\epsfxsize .40\hsize
%\begin{center}
%\makebox{
%\epsfbox[224 314 386 477]{./figures/aggregator_interface.epsi}
%}
%\end{center}
%\caption{{\bf The Wingman
%aggregator user interface:} the example aggregator shown is for the HotBot
%search engine.  The search terms in the ``Aggregator commands:'' text field
%will be passed to the HotBot aggregator when the OK button is pressed, and
%the aggregator's results will be transformed and sent back to the Wingman
%client.}
%\label{agg_interface}
%\end{figure}


%Because new aggregators can easily be added to the proxy, the aggregator
%request service includes a discovery mechanism, so that the client can
%piggyback a request for a listing of all aggregation services as part of a
%request for a Web page.  The client issues such a request at the beginning
%of each browsing session\footnote{A browsing session begins each time the
%Wingman client is launched.  This has the interesting side effect
%that we can deduce from log files how often a Wingman client is started.}
%and uses the information to construct the user-visible popup menu of
%available aggregators.

%The aggregator mechanism also serves as a stopgap mechanism to compensate
%for Wingman's lack of HTML forms support, which has since been remedied
%by a commercial version \cite{proxiweb}; we have chosen to focus our limited
%resources on other aspects of Wingman development.

\subsubsection{Zip, PalmOS, and Doc Support}

If the client fetches a Zip  file (a popular format for PalmPilot
software archives), the {\bf zip processor} 
formats a listing of the archive contents in HTML, such that 
following the  link for a particular archive member will cause the
zip processor to return the selected member.  The HTML 
created by the zip processor is then parsed by the HTML processor for
conversion to our binary markup, just as for normal Web pages.
This mechanism exploits TACC's ability to easily {\em compose} different
workers to quickly create new client abilities.

The proxy passes PalmOS {\em databases} (persistent object stores on the
PalmPilot) unmodified, which allows users to use Wingman to install new
data and applications onto their PalmPilots; for example, a proxy-side
AportisDoc \cite{aportisdoc} converter module allows users to immediately
save the text of a Web page in this popular e-book format.

% NEED SCRENSHOTS

\subsection{Client Implementation and User Experience}

The ``look and feel'' of the Wingman browser intentionally resembles
desktop browsers, but with specific additions and modifications
motivated by the  nature of the PalmPilot platform and small device UI's
in general.
% \item Wingman has a hotlist feature that works like the bookmark feature in
% Netscape.  Pages can be hotlisted and quickly visited through the
% hotlist window.
% \item Wingman has a local cache so that frequently visited Web sites
% will load quickly.  If a user wants to see a recent version of a
% cached page, there is a reload function that will send a new request
% for the page out to the proxy.
% \item In addition to a local cache of Webpages, Wingman has a second
% storage cache that is user maintained.  The user of Wingman must
% manually add and delete pages to the storage cache.  They can visit
% and store important pages and be assured that it will be locally
% cached at all times, even when their PalmPilot is not connected to the
% internet.
Like desktop browsers, Wingman has a hotlist (bookmark) feature, a local
user-controllable cache, and an automatic history cache.  Aggregators
(described above) are handled by a special aggregator request window
containing a popup menu of all available aggregators and a text area for
entering aggregation specific data, such as a search string.

The {\em refinement interface} allows users to zoom in on
scaled-down images (Figure \ref{popup_screenshots}).
Clicking on an image brings up a popup menu that allows the user to view
the original image or follow the link (if applicable).  Even for images
that have no link to follow, we chose to have the popup menu appear
anyway (with the ``follow link'' item disabled) to avoid disorienting
the user with different click behaviors for different image types.  
We originally proposed a mechanism of this kind for regular Web surfing
in \cite{pythia}, but Wingman completely integrates the refinement
interface into the user experience.

\begin{figure}[tbh]
\begin{center}
\begin{tabular}{@@{}cc@@{}}
\centering
{
\epsfxsize 0.25\hsize
\makebox{
\epsfbox[225 321 387 473]{./figures/content.epsi}
}
}
&
{
\epsfxsize 0.25\hsize
\makebox{
\epsfbox[225 319 387 473]{./figures/content_menu.epsi}
}
} \\
{\small(a)}&{\small(b)}\\
\multicolumn{2}{@@{}c@@{}}
{
\epsfxsize 0.25\hsize
\makebox{
\epsfbox[225 319 387 473]{./figures/content_zoom.epsi}
}
} \\
\multicolumn{2}{c}
{
\mbox{\small(c)}
} \\
\end{tabular}
\caption{{\bf Top Gun Wingman screenshots:}  (a) the Middleware '98 
conference Web page, (b) the refinement popup menu, and (c) the
refined image.}
\label{popup_screenshots}
\end{center}
\end{figure}

\subsection{Noteworthy Implementation Details}

%   ADU/ALF
%  here is some text you can use to talk about ALF and ADU's.

%Wingman was the one of the first applications  to exploit
%the PalmPilot's hardware support for 2-bit grayscale images, which reveal
%much more detail than 1 bit images do, especially at low resolutions and
%after scaling.  Wingman temporarily patches the PalmOS drawing routines to
%support 2-bit graphics; the PalmOS has since been revised to allow
%access to 2-bit graphics via standard system calls.

Following the long-standing recommendations of \cite{alf}, complete,
ready-to-render pages are delivered as application data units (ADU's).
This simplifies the client logic considerably: when the network layer
delivers a network event, it means that an entire, self-describing ADU is
waiting in a buffer ready to be rendered.  Contrast this with traditional
HTTP: in that protocol, a network event merely indicates that some number
of bytes has arrived, but framing is left entirely to the application.
Furthermore, in HTTP, inline images are generally fetched using independent
transactions (perhaps in parallel), requiring a nontrivial amount of
connection management overhead on the client.  Application-level framing
eliminates these concerns, makes the client simpler, and enables a
``push-friendly'' model of asynchrony that even allows out-of-order ADU
delivery.  Although Wingman was not explicitly designed to support
disconnected operation, the ADU-based network layer has no notion of
underlying ``connection state'', so it is possible for a page to be
split into ADU's whose arrival is separated by complete (but temporary)
network disconnection.  This behavior makes it possible to retarget a
Wingman-like application for connectionless datagram networks, such as
the paging network.
We return to these ideas in Section
\ref{lessons}.

%               2-bit hacks, aggregators

\subsection{Performance}\label{perf_impl}

%                 compare to other browsers on Pilot [claim: AMWP gives
%                         better performance]
%                 compare to desktop performance [claim: AMWP is a better
%                         way to support legacy clients, even over
%                         existing  low-bw]
%                 compare features to both desktop and Pilot browsers:
%                         transparent upgrades, weird file format
%                         capabilities, extrapolate to possible other
%                         features like Powerpoint browsing [claim: AMWP
%                         enables richer feature set, for lower cost]
%               report Tbmp-munger as upper bound on expected latency
%               compare Perl html vs C html

%%% TBD: are the ``percent'' numbers correct given that we are not
%%% necessarily using all of the data collected?

We measured the relative performance of Top Gun Wingman and its competitors
over the same bandwidth connection: Netscape Navigator for Windows 95, and
two PalmPilot-specific Web browsers, HandWeb and Palmscape.  Note that of
the three PalmPilot browsers tested, only Wingman supports display of
images.  As we show below, even with this significant additional
functionality, Wingman's performance is still often superior because of its
split design.

We measured the average end-to-end latency (elapsed time between clicking
on a link and completion of loading the page) for each of a collection of
15 different Web pages chosen to represent the various types of pages on
the Web today; we selected pages with varying but representative page
sizes, quantity of inline images, content, and location.  The pages were
initially fetched into the proxy's local cache, to eliminate the
highly-variable Internet latencies from the measurements.

Our Internet gateway is a Pentium 133/64MB running Red Hat Linux 5.0 and
connected to the Internet via a 128Kb/s ISDN connection to UC Berkeley.  To
simulate a variety of connection speeds, the PalmPilot browsers were
connected to the gateway machine via PPP over an RS-232 serial link.  By
varying the serial port speed between 57600 and 19200, we simulated low
speed connections with slightly lower latency than a typical modem (120ms).
19200 bps is representative of current wide-area and metropolitan-area
wireless networks, including Metricom Ricochet \cite{ricochet}, CDPD, and
PCS.  We believe that such technologies are of particular interest to the
mobile professionals who currently comprise a large market segment for
devices such as the PalmPilot.  57600 was chosen to represent fast wireline
(56K) modems as well as a variety of emerging metropolitan-area picocell
wireless data services.

%%% TBD which services are these?  i forget....

\subsubsection{Comparison to Other PalmPilot Browsers}

Despite the fact that Wingman is a graphical browser while Palmscape is a
text only browser, Wingman was still faster than Palmscape in 93\% of the
sites tested, not including those sites that caused Palmscape to crash (see
below).  At 19200 bps, Wingman was at least twice as fast as Palmscape 43\%
of the time.  At 57600 bps, as the time to display a page becomes more CPU
bound, this number rises to 54\%.  The PalmPilot's slow 16 MHz Motorola
DragonBall 68328 CPU and limited memory make HTML parsing and layout
painfully slow; Wingman relies on the cluster-based proxy for HTML parsing
and layout.

In 10\% of the test cases, Palmscape crashed while loading the page.  We
suspect the crashes occur because of the intricate HTML constructs often
found on commercial sites; stably capturing all HTML corner cases is
difficult, and unlike our TACC server, the PalmPilot client cannot
gracefully shield the user from such failures.  In this sense, our proxy
makes Wingman a more stable and reliable application than its peers.

\begin{figure}[htb]
\epsfxsize .70\hsize
\begin{center}
\makebox{
\epsfbox[53 91 738 520]{./figures/palm-dst.eps}
}
\end{center}
\caption{Comparison of end-to-end latency among Wingman, Palmscape, and
HandWeb at 57600 bps.}
\label{chart-pilotbrs}
\end{figure}


\subsubsection{Comparison to Desktop Browsers}

Compared to Netscape running on a Pentium II 300/128MB, Wingman was still
faster at downloading and displaying pages in 77\% of the test cases.  In
this situation the latency savings come from the image processor reducing
images' resolution and color depth of image before transmission over a slow
link (we demonstrated this savings originally in \cite{pythia}).  Although
Netscape receives and displays more data, that excess data is useless to a
device with limited display resolution and depth, such as the PalmPilot.
At 57600 bps Wingman is at least two times faster than Netscape 33\% of the
time, and at 19200 bps this number increases to 73\%.  This result
reinforces our original hypothesis that a proxy system for thin clients is
useful even when the client CPU's are fast enough to display and parse
complex pages.

Figure \ref{chart-speed} compares Wingman and Netscape Navigator at
19200 and 57600 bps for a number of different Web pages.  The top number
above each pair of bars is the total number of bytes transferred from
the TACC proxy to the Wingman client, i.e.\ the size of the Wingman ADU
corresponding to the delivered page with all inline images.  The bottom
number is the number of bytes transferred from the origin server to the
Netscape client, i.e.\ the total size of the HTML,
all inline images, and HTTP header overhead.  The relatively small
differences in Wingman's performance at 19200 and 57600 bps suggest that
back-end processing dominates latency, whereas with Netscape the network
bandwidth dominates latency.  

\begin{figure}[htb]
\epsfxsize 0.70\hsize
\begin{center}
\makebox{
\epsfbox[53 71 738 540]{./figures/wing-net.eps}
}
\end{center}
\caption{End-to-end latency: Wingman vs.\ Netscape Navigator at
19200 and 57600 bps for a selection Web pages.}
\label{chart-speed}
\end{figure}

% \subsubsection{Discussion}

% do we really want numbers taken from the transend distillers?  
% are they valid?  Do they seem valid to the reader even if they are?
% it seems that the numbers we have are good enough that adding this
% just hurts us.

Wingman's HTML processor was written in Perl for fast prototyping and to
exploit Perl's superior regular-expression and string manipulation
facilities.  We conservatively estimate that a factor of five to ten in
performance would result from rewriting the HTML processor in a faster
language (C/C++); this estimate is compatible with past work comparing the
performance of interpreted, compiled, and byte-compiled languages
\cite{romer96}.  This would make Wingman the fastest browser in virtually
all the test cases, even considering image processing latency, leaving only
the link bandwidth as the limiting factor in performance.

@


1.28
log
@Armando's mods.
@
text
@d431 1
a431 1
in general.  
@


1.27
log
@*** empty log message ***
@
text
@d4 6
a9 6
In this section we motivate the client-proxy-server architecture for
applications such as Wingman, and briefly describe the TACC programming model
our middleware provides.  This is followed by a detailed description of
the Wingman implementation in terms of the TACC model and some
performance data comparing Wingman to other browsers,  on both the
PalmPilot and the desktop.
d232 7
a238 9
The availability
mechanisms in the cluster runtime
have kept the system running continuously\footnote{During
February 1998, we experienced frequent sporadic downtime, which was
ultimately traced to a configuration change on the cluster that caused
remote execution to sometimes break.}  despite a variety of observed
failure types (worker crashes, temporary interconnect partitions, and
unexpected node reboots, among others),
in addition to the aggressive fault-injection experiments
d241 1
a241 1
failures,  Wingman masks them using a client-side front-end failover 
d250 2
a251 1
principle of client competence therefore suggests that HTML parsing and
d255 4
a258 4
the image munger, the HTML munger, the zip munger, and the {\em aggregator
request service.}  The TACC model and API's allow parallelism to be
exploited in various ways; for example, all inline images are prefetched in
parallel with HTML parsing, and whenever possible multiple images are
d286 1
a286 1
\subsubsection{Image and HTML Mungers}
d288 2
a289 2
The {\bf image munger} reads GIF and JPEG images (the two most common Web
formats \cite{grib_97}), converts them to an intermediate bitmap form,
d300 1
a300 1
The {\bf HTML munger} parses HTML markup, maps HTML tags to supported
d302 1
a302 1
Because the HTML munger knows the client's font metrics and display
d309 1
a309 1
When inline image tags are encountered, the HTML munger fetches the image,
d317 1
a317 1
and dispatches the original image to an image munger to
d322 1
a322 1
list of images and text, using a binary markup we have developed 
d332 9
a340 6
The {\bf aggregator request service} 
allows access to proxy-based content-aggregation applications.  An
aggregator, in the TACC sense, queries one or more Web sites for
specific content and collates and formats the results for presentation
to the client.  (The Metacrawler \cite{metacrawler} service on the Web is
a recent example of a Web-based aggregator.)
d352 1
a352 1
munger.  We have deployed aggregators for Yahoo, HotBot, AltaVista,
d409 1
a409 1
software archives), the {\bf zip munger} 
d412 2
a413 2
zip munger to return the selected member.  The HTML 
created by the zip munger is then parsed by the HTML munger for
d446 4
a449 5
user-controllable cache, and an automatic history cache (last $N$
pages visited).  Aggregators (described above) are handled by a special
aggregator request window containing a popup menu of all
available aggregators and a text area for entering aggregation specific
data, such as a search string.
d558 1
a558 1
functionality, Wingman's performance is still superior because of its
d593 1
a593 1
DragonBall 68349 CPU and limited memory make HTML parsing and layout
d621 6
a626 6
this situation the latency savings come from image munger reducing images'
resolution and color depth of image before transmission over a slow link (we
demonstrated this savings originally in \cite{pythia}).  Although Netscape
receives and displays more data, that excess data is useless to a device
with limited display resolution and depth, such as the PalmPilot.  At 57600
bps Wingman is at least two times faster than Netscape 33\% of the
d663 1
a663 1
Wingman's HTML munger was written in Perl for fast prototyping and to
d666 1
a666 1
performance would result from rewriting the HTML munger in a faster
@


1.26
log
@OK, we're there.
@
text
@d86 1
@


1.25
log
@Hacking away
@
text
@d159 1
a159 1
with favorable computation-to-communication
d172 1
d465 1
a465 1
\epsfxsize 0.31\hsize
d472 1
a472 1
\epsfxsize 0.31\hsize
d477 1
a477 1
(a)&(b)\\
d480 1
a480 1
\epsfxsize 0.31\hsize
d487 1
a487 1
\mbox{(c)}
d602 2
a603 2
\begin{figure}[tbh]
\epsfxsize .75\hsize
a629 13

\begin{figure}[tbh]
\epsfxsize 0.75\hsize
\begin{center}
\makebox{
\epsfbox[53 71 738 540]{./figures/wing-net.eps}
}
\end{center}
\caption{End-to-end latency: Wingman vs.\ Netscape Navigator at
19200 and 57600 bps for a selection Web pages.}
\label{chart-speed}
\end{figure}

d641 12
@


1.24
log
@Much changes
@
text
@d338 31
a368 14
In Wingman, an aggregator consists of a very simple PalmPilot-native
UI (see Figure \ref{agg_interface}) that allows the user to write some text 
describing what is being requested (e.g. the query terms for a Web
search, the ticker symbol for a stock quote, etc.).  When the ``OK''
button is tapped, the contents of the form are transmitted to the
Wingman TACC proxy's aggregation worker.  The worker uses the content of
the first box to determine which service the user is requesting (search
engine, stock quote, etc.)
and the content of the second box as parameters to the aggregator.
A site-specific aggregator handler then converts this data to an
HTML form submission on the proxy side, and the results from the origin
server are  formatted by the HTML munger.  We have deployed
aggregators for Yahoo, HotBot, AltaVista, DejaNews, Yahoo's stock quotes
service, and TripQuest.
d371 2
a372 9
%\begin{tabular}{p{6cm}p{5.8cm}}
%\parbox[b]{5cm}{{\bf Figure \ref{agg_interface}\hspace{0.05in} The Wingman
%aggregator user interface:}  the example
%aggregator shown is for the HotBot search engine.  The search terms in the
%``Aggregator commands:'' text field will be passed to the HotBot aggregator
%when the OK button is pressed, and the aggregator's results will be
%transformed and sent back to the Wingman client.}
%&
%{\epsfxsize .80\hsize
d376 7
a382 3
%}
%\\
%\end{tabular}
a385 16
\begin{figure}[tbh]
\epsfxsize .40\hsize
\begin{center}
\makebox{
\epsfbox[224 314 386 477]{./figures/aggregator_interface.epsi}
}
\end{center}
\caption{{\bf The Wingman
aggregator user interface:} the example aggregator shown is for the HotBot
search engine.  The search terms in the ``Aggregator commands:'' text field
will be passed to the HotBot aggregator when the OK button is pressed, and
the aggregator's results will be transformed and sent back to the Wingman
client.}
\label{agg_interface}
\end{figure}

d387 14
a400 14
Because new aggregators can easily be added to the proxy, the aggregator
request service includes a discovery mechanism, so that the client can
piggyback a request for a listing of all aggregation services as part of a
request for a Web page.  The client issues such a request at the beginning
of each browsing session\footnote{A browsing session begins each time the
Wingman client is launched.  This has the interesting side effect
that we can deduce from log files how often a Wingman client is started.}
and uses the information to construct the user-visible popup menu of
available aggregators.

The aggregator mechanism also serves as a stopgap mechanism to compensate
for Wingman's lack of HTML forms support, which has since been remedied
by a commercial version \cite{proxiweb}; we have chosen to focus our limited
resources on other aspects of Wingman development.
d501 6
a506 6
Wingman was the one of the first applications  to exploit
the PalmPilot's hardware support for 2-bit grayscale images, which reveal
much more detail than 1 bit images do, especially at low resolutions and
after scaling.  Wingman temporarily patches the PalmOS drawing routines to
support 2-bit graphics; the PalmOS has since been revised to allow
access to 2-bit graphics via standard system calls.
@


1.23
log
@armandos edits to impl.tex and related.tex
@
text
@d50 4
a53 6
which proxy agents placed between clients and servers perform
computation- and storage-intensive tasks, such as datatype-specific
lossy compression,
on behalf of clients.  Properly applied, this
approach reduces
the bandwidth demands on the infrastructure through lossy compression
d57 16
a72 15
\begin{figure}[tbh]
\epsfxsize 0.95\hsize
\begin{center}
\makebox{
\epsfbox[0 0 328 143]{./figures/cps.eps}
}
\end{center}
\caption{\textbf{Client-proxy-server}
applications rely on a middleware proxy to interact with servers on the
client's behalf, and possibly perform value-added computation on the
server data before passing it to the client.  The interaction is
typically transparent to both clients and servers, as is the case with
(for example) HTTP proxies.}
\end{figure}

d81 1
a81 1
client and {\em proxy}, rather than between client and server.  From the
d89 20
a108 26
{\em transformation} (distillation \cite{asplos},
filtering, format conversion, etc.),
{\em aggregation} (collecting and collating data from various sources,
either offline or on-the-fly), {\em caching} (both original and transformed
content), and {\em customization}  (persistent store of user profiles,
allowing the service to tailor its output to each
user's needs or device characteristics).
Each  {\em TACC
worker} specializes in a particular task, for example,
scaling/dithering of images in a particular format, conversion between
specific data formats, extracting ``landmark'' information from specific
Web pages, 
etc.  
Complete applications are built  by \textit{composing} workers, by
{\em chaining} them (in the Unix pipeline sense),
or allowing one worker to  {\em call} another as a
subroutine or (parallel, asynchronous) coroutine.  
The {\em dispatch rules} that determine which workers are invoked to
satisfy a particular user request can either be hardcoded for each
application, or controlled dynamically by the workers themselves.
A runtime platform called a
{\em TACC server}  is
expected to provide mechanisms for hosting workers, instantiating
dispatch rules, providing high availability, and recovering from errors
such as dispatch loops, infinite mutual recursion, or worker
instability; we describe our prototype TACC server in the next section.
d171 1
a171 1
\epsfxsize 0.95\hsize
d190 1
a190 1
in figure 
d339 1
a339 1
UI (see figure \ref{agg_interface}) that allows the user to write some text 
d353 19
d373 1
a373 1
\epsfxsize 0.55\hsize
d379 6
a384 5
\caption{{\bf The Wingman aggregator user interface:}  the example
aggregator shown is for the HotBot search engine.  The search terms in the
``Aggregator commands:'' text field will be passed to the HotBot aggregator
when the OK button is pressed, and the aggregator's results will be
transformed and sent back to the Wingman client.}
d388 1
d451 1
a451 1
scaled-down images (figure \ref{popup_screenshots}).
d466 1
a466 1
\epsfxsize 0.41\hsize
d473 1
a473 1
\epsfxsize 0.41\hsize
d481 1
a481 1
\epsfxsize 0.41\hsize
d529 1
a529 1
We return to these ideas in section
d604 1
a604 1
\epsfxsize 1.05\hsize
d633 1
a633 1
\epsfxsize 0.99\hsize
@


1.22
log
@expanded TACC and cluster server descriptions in impl.tex, probably exceeded my 1 page limit
@
text
@d50 5
a54 4
which proxy agents placed between clients and servers perform aggressive
computation and storage on behalf of clients.  Properly applied, this
approach allows us to transparently leverage the installed infrastructure:
Data and format transformation on an application-level proxy both reduces
d88 1
a88 7
Relevant aspects of TACC:
- composition by chaining or calling
- atomic, restartable workers
- separation of scal/avail from content
- simple worker model, reuse legacy code

Our programming model for proxy-based applications is called TACC
d125 1
a125 1
doing only idempotent operations, or
d229 2
a230 1
for $24\times 7$ operation.  
d237 3
a239 3
The cluster has been running TranSend since April 1997, and Wingman
since November 1997, with very little downtime.  The availability
mechanisms have kept the system running continuously\footnote{During
d243 3
a245 1
failure types, in addition to the aggressive fault-injection experiments
d248 1
a248 1
failures,  Wingman accomplishes this using a client-side front-end failover 
d310 3
a312 3
it can wrap text, flow text around inline images, etc.  (The client
identifies itself to the proxy in the initial handshake; the client
identification is used to select the correct client profile.  The
d317 5
a321 8
heuristics we developed,\footnote{
We shrink the image based on the size of the image (larger
images are shrunk more aggressively), the type of image (imagemaps are
shrunk less aggressively to preserve embedded text),
the screen size of the Palm Pilot (the image is always shrunk so that it
can entirely fit on the screen), and the memory constraints of the Palm
Pilot (no transformed image will ever exceed 32KB).
}
d323 1
a323 1
and dispatches the original Web image to an image munger to
d386 2
a387 3
for Wingman's lack of HTML forms support.  Although adding form interaction
is conceptually simple (in fact, we have already extended the binary markup
to support standard form elements), we have chosen to focus our limited
a415 1

a418 1

a422 1

a428 1

d489 1
a489 1
Wingman was the one of the first applications that we know of to exploit
d493 2
a494 1
support 2-bit graphics.
d508 8
a515 1
delivery.  We return to these ideas in section
@


1.21
log
@Many changes, related to the style the conference demands.  Much work on the bibliography will be necessary.
@
text
@d87 5
a91 5
\textit{[We can elaborate at length on specifics of the TACC
model and/or its implementation if the reviewers and program committee
feel it is more relevant to this forum.  We tried to keep this section
brief to avoid overlap with a previous paper \cite{sosp16}.]}

d107 16
a122 1
etc.  Workers serially process tasks from a task queue; each task
d124 22
a145 6
and transforming an inline image on a Web page.
Complete applications are built by {\em composing} workers;
roughly speaking, one worker can {\em chain} to another (similar to
processes in a Unix pipeline), or a worker can {\em call} another as a
subroutine or coroutine.  This model of composition results in a very
general programming model that subsumes transformation proxies
d148 2
a149 1
environment provides the inter-worker and intra-worker API's,
d153 2
d157 76
a232 6
provides support for the inter-worker calling and chaining API's.  A TACC
server is to TACC modules as the Unix shell and runtime are to Unix
programs.  In particular, our prototype implementation of a scalable,
commodity-PC cluster-based TACC server, described in \cite{sosp16},
hides the machinery that provides incremental scalability, load balancing,
and high availability to TACC applications.  This makes TACC applications
d234 19
a252 1
for $24\times 7$ operation.
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
\section{Architecture and Implementation}
@


1.19
log
@All there.  Complete draft.  woohoo.
@
text
@d87 6
d192 1
a192 1
identification is used to select the correct client profile.  The actual
d231 2
a232 2
search, the ticker symbol for a stock quote, etc.).  When the ``Submit''
button is clicked, the contents of the form are transmitted to the
d261 1
a261 1
request for a web page.  The client issues such a request at the beginning
d290 1
a290 1
save the text of a web page in this popular e-book format.
d305 1
a305 1
% \item Wingman has a local cache so that frequently visited web sites
d310 1
a310 1
% \item In addition to a local cache of webpages, Wingman has a second
d366 1
a366 1
conference web page, (b) the refinement popup menu, and (c) the
d428 2
a429 2
15 different web pages chosen to represent the various types of pages on
the web today; we selected pages with varying but representative page
d457 1
a457 1
bound, this number raises to 54\%.  The PalmPilot's slow 16 MHz Motorola
d487 1
a487 1
resolution and color depth of image before transmissionover a slow link (we
d490 3
a492 3
with limited display resolution and depth, such as the Palm Pilot.  At 57600
baud Wingman is at least two times faster than Netscape 33\% of the
time, and at 19200 baud this number increases to 73\%.  This result
d497 1
d505 2
a506 8
\caption{Comparison of end-to-end latency between Wingman and
Netscape Navigator at 19200 and 57600 bps for a number of different web
pages.  The two numbers above each pair of bars are the total number of
bytes transferred from the proxy to the Wingman client (on top) and from
the web server to the Netscape client (on bottom) for each page.  For
Wingman, this byte count is the size of the ADU constructed for the page,
and for Netscape it is the size of the HTML, all inline images, and HTTP
header overhead.}
d510 13
a522 1
\subsubsection{Discussion}
@


1.18
log
@Gargh.
@
text
@d74 2
a75 2
TBD refs to motivate transparent proxy-based approach; why thin clients
and legacy clients are two sides of the same coin
d88 1
a88 1
\cite{casefortacc}: 
d115 10
a124 12
A {\em TACC server} is a platform that instantiates TACC workers
and the dispatch rules for routing
network data traffic to and from them, and provides support for the
inter-worker calling and chaining API's.  A TACC server is to TACC
modules as the Unix shell and runtime are to Unix programs.
In particular, our prototype
implementation of a scalable, 
commodity-PC cluster-based TACC server, described in section \ref{impl},
hides the machinery that provides incremental scalability, load
balancing, and high availability to TACC applications.  This makes TACC
applications easy to write even though they will be deployed to large
user communities for $24\times 7$ operation.
d128 27
a154 10
The USR PalmPilot's austere graphics library supports a single native
bitmap format, and text objects are not automatically word-wrapped and
must consist entirely of text in a single visual style (bold, etc.).
The principle of client competence
therefore suggests that HTML parsing and tag-to-font
mapping, page layout with client-specific font metrics, and image
scaling with conversion to native bitmap format all be left to the TACC
proxy.  The proxy side of the Wingman browser uses four TACC workers:
the image munger, the HTML munger, the zip munger, and the
{\em aggregator request service.}
d156 1
a156 15
\begin{figure}[tbh]
\epsfxsize 0.95\hsize
\begin{center}
% \makebox{
% \epsfbox[0 0 340 303]{./figures/wingman_app.eps}
% }
\end{center}
\caption{\textbf{Wingman's TACC workers}
include the parser/executive, image conversion, and page layout, which
is actually implemented as a library called by the executive.  The TACC
model and API's allow parallelism to be exploited in various ways; for
example, all inline images are prefetched in parallel with HTML parsing,
and whenever possible multiple images are converted in parallel by
calling multiple workers.}
\end{figure}
d168 5
a172 5
The {\bf image munger} reads GIF and JPEG images (the two most
common Web formats \cite{sosp16}), converts them to the PPM \cite{PBM} intermediate
form, optionally scales, color-quantizes and dithers, and finally
outputs the result in either the PalmPilot's native image format (Tbmp)
or our enhanced 2-bit-per-pixel format.  
d189 10
a198 5
When
inline image tags are encountered, the HTML munger fetches
the image, 
determines how much it should be scaled down using a simple
set of heuristics we developed, 
d238 1
a238 1
\epsfxsize 0.65\hsize
d252 7
a258 8
Because new aggregators can be easily be added to the proxy, the
aggregator request service includes a discovery mechanism, so that
the client can piggyback a request for a listing of all aggregation
services as part of a request for a web page.  The client issues such a
request at the beginning of each browsing session\footnote{A browsing
session begins each time the Wingman client is launched.  This behavior
has the interesting side effect that we can deduce from log files how
often a Wingman client is started.} 
d262 5
a266 5
The aggregator mechanism also serves as a stopgap mechanism to
compensate for Wingman's lack of HTML forms support.  Although adding
form interaction is conceptually simple (in fact, we have already
extended the markup to support standard form elements), we have chosen
to focus our limited resources on other aspects of Wingman development.
d280 5
a284 7
The proxy passes PalmOS {\em databases} (persistent object
stores on the PalmPilot) 
unmodified, which allows users to use Wingman to install new data and
applications onto their PalmPilots; for example, a proxy-side AportisDoc
\cite{aportisdoc} converter module
allows users to immediately save the text of a web page in this popular
e-book format.
d371 19
a389 21
Wingman was the first application that we know of to exploits the
PalmPilot's hardware support for 2-bit grayscale images, which 
reveal much more detail than 1 bit images do, especially at low
resolutions and after scaling.  
Wingman temporarily patches the PalmOS drawing routines to support 2-bit
graphics.

Following the long-standing recommendations of \cite{alf}, 
complete, ready-to-render pages are delivered as application data
units (ADU's).  This simplifies the client logic considerably: when
the network layer delivers a network event, it means that an entire,
self-describing ADU is waiting in a buffer ready to be rendered.
Contrast this with traditional HTTP: in that protocol, a network event
merely indicates that some number of bytes has arrived, but framing is
left entirely to the application.  Furthermore, in HTTP, inline images
are generally fetched using independent transactions (perhaps in
parallel), requiring a nontrivial amount of connection management
overhead on the client.  Application-level framing eliminates these
concerns, makes the client simpler, and enables a ``push-friendly''
model of asynchrony that even allows out-of-order ADU delivery.
We return to these ideas in section
d394 1
a394 1
\subsection{Performance}
d409 10
a418 2
TBD: are the ``percent'' numbers correct given that we are not
necessarily using all of the data collected?
a419 6
We measured the relative performance of Top Gun Wingman and its
competitors over the same bandwidth connection: 
Netscape Navigator for Windows 95,
and two PalmPilot-specific Web browsers, HandWeb and Palmscape.
(Of the three PalmPilot browsers tested, only Wingman supports display
of images.)  
d421 20
a440 23
on a link and completion of loading the page) for each of a collection
of 15 different web pages chosen to represent the
various types of pages on the web today (different page sizes, quantity
of inline images,
content, location, etc.).  The pages were initially fetched into a local
(UC Berkeley) cache, to eliminate highly-variable Internet latencies
from the measurements.

Our Internet gateway is a Pentium 133/64MB running Red Hat Linux 5.0
and connected to the Internet via a 128Kb/s ISDN connection to UC Berkeley.
To simulate a variety of connection speeds,
the PalmPilot  browsers were connected to the gateway machine via PPP
over an RS-232 serial link.  By varying the serial port speed
between 57600 and 19200, we simulated low speed connections with slightly
lower latency than a typical modem (120ms).  19200 bps 
is  representative  of current
wide-area and metropolitan-area 
wireless networks, including Metricom Ricochet \cite{ricochet}, CDPD,
and PCS.  We believe that such technologies are of particular interest
to the mobile professionals who currently comprise a large market
segment for devices such as the PalmPilot.
57600 was chosen to represent fast wireline (56K) modems as well as a
variety of emerging metropolitan-area picocell wireless data services.
d442 1
a442 1
TBD which services are these?  i forget....
d446 16
a461 22
Despite the fact that Wingman is a graphical browser while Palmscape is
a text only browser, Wingman was still faster than Palmscape in 93
percent of the sites tested, not including those sites that caused
Palmscape to crash (see below).  At 19200 bps, Wingman
was at least twice as fast as Palmscape 43 percent of the time.  At
57600 bps, as the time to display a page becomes more CPU bound,
this number raises to 54 percent.  The PalmPilot's slow CPU (25 MHz
Motorola DragonBall, an embedded 68000 derivative) and 
limited memory make  HTML parsing and layout painfully slow;
Wingman relies on the proxy (running on a powerful workstation)
for HTML parsing and layout,
which speeds up transfer time significantly
while providing more content to the user.

In 10\% of the test cases, Palmscape
crashed while loading the page.  We suspect the crashes occur because of
the intricate HTML constructs often found on commercial sites;
stably capturing all HTML corner cases is difficult, and unlike our TACC
server, the PalmPilot client cannot gracefully
shield  the user from such failures.
In this sense, our proxy makes Wingman
more stable and reliable as well as faster.
d478 12
a489 16
Compared to Netscape running on a Pentium II 300/128MB,
Wingman was still faster at downloading and
displaying pages in 77 percent of the test cases.  In this situation
the savings come from image munger reducing the resolution of
images both in color depth and image size before sending the image
over a slow link (we demonstrated this savings originally in
\cite{pythia}).
Although Netscape receives and displays more data,
that excess data is useless to a device with limited display resolution
and depth,
such as the PalmPilot.  At 57600 baud Wingman is at least two times
faster than Netscape 33 percent of the time, and at 19200 baud this
number increases to 73 percent.
This result reinforces our original hypothesis that
a proxy system for thin clients is useful even when the client CPU's
are fast enough to display and parse complex pages.
d518 7
a524 8
facilities.  We conservatively
estimate that a factor of five in performance would result from rewriting
the HTML munger in a faster language (C/C++); this estimate is compatible
with past work comparing the performance of interpreted, compiled, and
byte-compiled languages \cite{romer96}.  This would make Wingman
the fastest browser in virtually all the test cases, even considering image
processing latency, leaving only the link bandwidth as the limiting
factor in performance.
@


1.17
log
@More changes.
@
text
@d470 1
a470 1
\epsfxsize 0.95\hsize
d473 1
a473 1
\epsfbox[-36 161 648 630]{./figures/chart-pilotbrs.eps}
d502 1
a502 1
\epsfxsize 0.95\hsize
d505 1
a505 1
\epsfbox[-36 161 648 630]{./figures/chart-speed.eps}
d508 8
a515 2
\caption{Comparison of end-to-end latency between Wingman, Palmscape, and
Netscape Navigator at 19200 and 57600 bps.}
@


1.16
log
@Added screenshots.
@
text
@d62 1
a62 1
\epsfbox[0 0 340 303]{./figures/cps.eps}
@


1.15
log
@*** empty log message ***
@
text
@d316 1
a316 1
scaled-down images.
d326 36
a361 3
TBD need sequence of screenshots: (1) page with shrunken image, (2)
popup menu appearing over image with ``Zoom in'' selected, (3) screen
showing zoomed image
@


1.14
log
@*** empty log message ***
@
text
@d180 9
a188 1
font attributes, and generates an intermediate-form page layout.  When
d216 1
a216 1
In Wingman, an aggregator consists of a a very simple PalmPilot-native
d257 6
a497 54
\subsection{Other TACC Proxy Applications}

Here we give a few examples of some of the proxy-based applications we
have built and deployed using the TACC model, to demonstrate the model's
flexibility for constructing applications out of existing building
blocks, as well as our cluster-based platform's viability for deploying
these applications to large groups of real users who expect continuous
availability. 

\textbf{TranSend} \cite{transend} is a Web acceleration proxy that
performs on-the-fly, datatype-specific compression, in particular on GIF
and JPEG images.  TranSend allows each user to customize the
``aggressiveness level'' of lossy compression as well as various other
options, and results in a $3-7\times$ speedup for browsing over a slow
link such as a 28.8K modem.  TranSend was deployed for public use on a
UC Berkeley cluster in April 1997 and has been running since then with
minimal unscheduled downtime, serving a user community of about
10,000.  TranSend's ideas have recently been instantiated commercially
as Intel QuickWeb, although there is no connection between QuickWeb and
TranSend.

\textbf{Top Gun Mediaboard} is an electronic shared whiteboard
application for the PalmPilot.  This is a derivation of the the desktop
{\em mediaboard} application, which uses SRM (Scalable Reliable
Multicast) as the underlying communication protocol.  A reliable
multicast proxy (RMX) TACC worker participates in the SRM session on
behalf of the PDA clients.  The Mediaboard TACC workers perform
four types of client
adaptation: tunneling multicast over unicast (since the PalmPilot
doesn't support multicast), conversion of {\em mediaboard} commands into
draw-ops on a ``pseudo-canvas'' that the client maintains (using a
binary markup that is an extension of the Top Gun Wingman markup),
conversion of GIF and JPEG background images into
simple PalmPilot bitmaps, and intelligent forwarding of data from the
mediaboard session to the client (for example, eliminating redundant
draw-ops and forwarding only the data associated with the virtual page
currently being viewed on the client).  Top Gun Mediaboard is in
prealpha use at UC Berkeley, and performs satisfactorily even over slow
links such as the Metricom Ricochet wireless packet radio modem
\cite{ricochet}.

\textbf{Charon}\footnote{The
Charon module 
has not yet been encapsulated as a TACC worker.}
illustrates a similar use of adaptation by proxy, for
performing indirect authentication.  In particular, Charon mediates
between thin clients and a Kerberos \cite{kerberos} infrastructure.
Charon is necessary because, as we describe in \cite{charon}, the
computing resources required for a direct port of Kerberos to thin
clients are forbidding.  Charon relieves the client of a significant
amount of Kerberos protocol processing, while limiting the amount of
trust that must be placed in the proxy.  Our Charon prototype client for
the Sony MagicLink \cite{sony_magic_link}, a then-popular PDA, had a
client footprint of only 45KB, including stack and heap usage.  
@


1.13
log
@*** empty log message ***
@
text
@d1 1
a1 1
\section{Implementation Description}
d4 7
a38 2
\label{proxy}

d58 16
d81 3
a83 1
client and {\em proxy}, rather than between client and server.
d133 1
a133 1
Our philosophy of client competence
d171 4
a174 3
or our enhanced 2-bit-per-pixel format.  Although the above
steps are logically independent (and actually reside in separate files),
it was more efficient to combine them into a single worker.  
d185 1
a185 1
adds ``zoom-in'' information to allow later refinement by the user,
d206 4
a209 10
a recent example of an aggregator.)  In Wingman, aggregators also 
compensate for the  client's lack of forms support: 
% , it needs some
% mechanism for performing such tasks as web searches, or to access
% useful web databases such as Tripquest (www.tripquest.com).  The {\em
% aggregator request service} exists to perform this function.  Rather
% than passing aggregator requests one of the three mungers, the proxy
% sends these requests to the aggregator request service, which then
% determines what service is being requested, and then runs a service
a very simple PalmPilot-native UI allows the user to write some text
d211 7
a217 1
search),  site-specific aggregator programs convert this data to an
d223 15
d301 2
a302 2
The {\em refinement interface}, which allows users to zoom in on
scaled-down images, separates Wingman from desktop browsers.   
d308 3
a310 2

TBD need a ref for the above UI point....anthony, do you know any?
d340 2
a341 1
model of asynchrony.  We return to these ideas in section
d385 2
a386 2
lower latency than a typical modem (120ms).  19200 bps was chosen
because it is (somewhat optimistically) representative  of current
d395 1
a395 1
TBDS which services are these?  i forget....
d416 4
a419 3
stably capturing all the corner cases
on such a limited resource machine as
the PalmPilot is especially hard.  Therefore our proxy makes Wingman
d450 3
a452 4
This result suggests that
a proxy system for thin clients will be useful even when the CPUs of
small devices are fast enough that displaying and parsing web pages is
no longer  CPU-bound.
d475 1
a475 2
facilities.  In addition the HTML parsing routines in the HTML munger were
optimized for ease of use rather than execution speed.  We conservatively
d479 4
a482 2
byte-compiled languages \cite{romer96}.  This would make the Wingman
browser the fastest in virtually all the test cases.
d500 1
a500 1
virtually no unscheduled downtime, serving a user community of about
d505 1
a505 1
\textbf{TopGun Mediaboard} is an electronic shared whiteboard
@


1.12
log
@blorg hack
@
text
@d145 1
a145 1
common Web formats \cite{sosp16}), converts them to the PPM \cite{netpbm} intermediate
d181 1
a181 1
to the client.  (The Metasearch \cite{metasearch} service on the Web is
d389 1
a389 1
\label{chart-speed}
d442 1
d444 52
@


1.11
log
@*** empty log message ***
@
text
@d44 6
a49 8
We argue for a {\em proxy-based approach} for middleware applications,
in which proxy agents placed between clients and servers perform
aggressive computation and storage on behalf of clients.  Properly
applied, this approach allows us to transparently
leverage the installed infrastructure:
Data and format transformation on an application-level
proxy both reduces the bandwidth
demands on the infrastructure through lossy compression
d384 1
a384 1
\epsfbox[0 0 438 294]{./figures/chart-pilotbrs.eps}
d417 1
a417 1
\epsfbox[0 0 438 294]{./figures/chart-speed.eps}
d433 8
a440 10
exploit Perl's superior regular-expression and string manipulation facilities.
In addition the HTML parsing
routines in the HTML munger were optimized for ease of use rather than
execution speed.  We conservatively estimate that a factor of five in
performance would result from  rewriting the HTML munger in a faster
language (C/C++); this estimate is compatible with past work comparing
the performance of interpreted, compiled, and byte-compiled languages
\cite{romer96}.
This would make the Wingman browser the fastest in
virtually all the test cases.
@


1.10
log
@*** empty log message ***
@
text
@d1 1
a1 1
\section{Implementation}
d32 103
a134 1
\subsection{Proxy implementation}
a142 3
The proxy side of the Wingman browser uses four TACC workers:
the image munger, the HTML munger, the zip munger, and the
{\em aggregator request service.}
d147 1
a147 1
common Web formats), converts them to the PPM \cite{netpbm} intermediate
d168 4
a171 3
image data before returning the client a simple display
list of images and text, whose format is optimized for
download and display speed.
d258 1
a258 1
and user-controllable cache, and an automatic history cache (last $N$
d283 2
a284 2
Wingman was the first application that we know of that exploits the
PalmPilot's hardware ability to support 2-bit grayscale images, which 
a289 3
TBD need an approrpiate anecdote/ref for the Haeberli munger here, and
don't forget to ack Haeberli!

d358 1
a358 1
\subsection{Comparison to Other PalmPilot Browsers}
d395 1
a395 1
\subsection{Comparison to Desktop Browsers}
d427 1
a427 1
\subsection{Discussion}
d440 1
a440 1
language (C/C++); this estimate is consistent with past work comparing
a445 85

%
%  TACC cluster server description
%

\subsection{Cluster-Based TACC Server Architecture}

Our cluster-based TACC server is motivated by the observation that
clusters of workstations interconnected by a fast system-area network
(such as switched 100-Mb/s Ethernet or Myrinet \cite{MYRI_95}) are in
many ways a good match for large-scale network services.  Using
commodity PC's as the unit of scaling allows the service to ride the
leading edge of the cost/performance curve (cost effectiveness and
incremental growth).  The inherent redundancy of clusters can be used
to mask transient failures (high availability).  Finally,
``embarrassingly parallel'' network service workloads map well onto
networks of commodity workstations.  Since the development of cluster
software and administration of a running cluster remain complex, we
have isolated much of the machinery needed to support high
availability and incremental growth into a lower layer of our cluster
software.  The upper layer supports the TACC programming model API's
alluded to in section \ref{proxy}, so that new TACC services can use
our cluster server as an off-the-shelf solution to scalability,
availability, and several other problems.  We describe our system
architecture at a high level; a detailed discussion of the
architecture and the performance of our cluster can be found in
\cite{sosp16}.

\begin{figure}[tbh]
\epsfxsize 0.95\hsize
\begin{center}
\makebox{
\epsfbox[0 0 340 303]{./figures/arch.eps}
}
\end{center}
\caption{{\bf Components of a cluster-based TACC server}
include front 
ends (FE), TACC workers (W) and caches (\$),
% $ to make emacs happy!!
a user profile database, a graphical monitor/administration interface,
and a fault-tolerant load
manager whose functionality logically extends into the manager stubs
(MS) and worker stubs (WS).}\label{arch_sns}
\end{figure}

The software-component block diagram of a scalable TACC server is shown
in figure 
\ref{arch_sns}.  
{\em Front ends} receive client requests from the outside world and
``shepherd'' them through the system,
by fetching Internet content via the {\em caches},  matching the request
with the appropriate user profile from the {\em 
customization database},  and queueing the request for service by one or more
{\em TACC workers} that will process the data according to the user
preferences.   Front ends maximize system throughput by maintaining state for
many simultaneous outstanding requests, and can be replicated for both
scalability and availability.
The {\em Load Balancing/Fault Tolerance manager} is responsible for
internal reactive load balancing, autostarting and reaping workers, and
detecting and recovering from various system failures, including crashed
components and network partitions, via multicast heartbeat and
process-peer fault 
tolerance.  In addition to machines dedicated to running the service,
the manager can exploit an {\em overflow pool} of general-use machines,
which are harnessed and released as needed.
The entire system is administered through a 
{\em Graphical Monitor}, which supports asynchronous
error notification via email or pager, temporary disabling of system
components for hot upgrades, and visualization of the system's behavior
using Tcl/Tk \cite{tcltk}.  

Our cluster software has been hosting TranSend
\cite{transend} and Wingman on
the Berkeley NOW (Network of Workstations \cite{Ande95b}) since April
1997.  The dedicated pool consists of four SPARCstation-10's and the
overflow pool consists of up to 100 SPARC Ultra-1 Enterprise servers.
Under typical load, about five Ultra-1's are serving TranSend and
Wingman users.  The cluster has been running TranSend since April 1997,
and Wingman since November 1997, with very little
downtime.\footnote{During February 1998, we experienced frequent
sporadic downtime, which was ultimately traced to a configuration change
on the cluster that caused remote execution to sometimes break.}

TBD how many hits/second are TranSend and Wingman getting, and what does
this translate into in terms of subscribers?
@


1.9
log
@*** empty log message ***
@
text
@d225 2
d228 68
a295 24
% Need to chose which data to use, how to present it.  I want to talk
% to you about this before I make the tables.  Current numbers assume
% all data used.

% need to indroduce the browsers used.

\item Despite the fact that Wingman is a graphical browser while
Palmscape is a text only browser, Wignman was still faster than
Palmscape in 93 percent of the sites tested, not including those sites
that caused Palmscape to crash.  At a 19200 baud transfer rate,
Wingman was at least two times faster than Palmscape 43 percent of the
time.  At 56700 baud, as the time to display a page becomes relatively
CPU bound, this number raises to 54 percent.  The PalmPilot has a slow
CPU and a limited amount of memory, and therefore parsing HTML on the
PalmPilot can be painfully slow.  By using the proxy to do all HTML
parsing on a vastly more powerful machine we can speed up transfer
time significantly while providing more content to the user.

Also notble is that in ten percent of the test cases Palmscape
crashed upon loading the page.  Because of the difficulty in writing
code to parse and display HTML on such a limited resource machine as
the PalmPilot, writing stable code is especially hard.  Our proxy not
only allows Wingman to display web pages faster, it also makes Wingman
more stable and reliable.
d297 5
a301 2
\item Compared to Netscape running on a 300mhz Pentium II machine with
128 mbs of memory, Wingman was still faster at downloading and
d303 1
a303 1
the savings are caused by the image munger reducing the resolution of
d305 5
a309 2
over a slow link.  Although Netscape receives and displays more data,
that excess data is useless to a device with such a limited display
d312 2
a313 3
number shoots up to 73 percent!  Any non-proxy based web browser that
supports images must download the entire image before displaying it,
even if the image ends up being reduced in quality when displayed.  So
d316 15
a330 1
no longer a CPU bound task.
d337 3
a339 3
\item The HTML munger used was written in perl rather than a faster
language such as C, because perl's string functions are more suited to
the tasks required by such a program.  In addition the HTML parsing
d341 8
a348 14
execution speed.  If the HTML munger was rewritten and optimized for
execution speed we can expect an order of magitude decrease in
distillation.  This would make the Wingman browser the fastest in
almost all the test cases.

\item It is not only through increased download times that the proxy
architecture is a win for web browsing.  By moving the parsing of pages
and images off to the proxy server new file formats can be
transparently supported.  All the would be needed to support a new
format would be the addition of a new munger that understood that
format.  In this way we can support new formats such as XML, without
requiring any changes to the browser.  Not only is this easier for the
development of the browser, it also means that Wingman users don't
need to upgrade their browser just to view new formats.
@


1.8
log
@*** empty log message ***
@
text
@d165 6
a170 1
scaled-down images, separates Wingman from desktop browsers.  
d172 5
a176 11
 is unique to Wingman, although we have
reported on orthogonal
Because the image munger returns a scaled down version of an
image, important image detail, such as text, may be lost.  In order
for a user to view a closer-to-original version of the image (one that
is scaled down in color depth but not in height or width), the user
may click through an image in order to view the larger version.
Because clicking through an image can perform two distinct functions
(the user may want to follow a link or see the unshruken image),
clicking on an image brings up a popup list of choices and the user
can select which function is desired.
d183 9
a191 6
\item Although the PalmPilot OS is designed for 1 bit graphics, the
hardware supports a 2 bit gray-scale display.  2 bit images display
much more detail than 1 bit images do, especially at low resolutions,
and because images are and important part of the Wingman browser, 
Wingman overrides the PalmPilot OS drawing routines to provide support
for a 2 bit display.
d193 1
a193 1
\item Following the long-standing recommendations of \cite{alf}, 
@


1.7
log
@Argh.
@
text
@d1 373
a373 343
\section{Implementation}
\label{impl}

% Umm, my style is quite different from the rest of this paper, is
% this a problem?  


% Detailed description/implementation [DL,AP] - 2.5 pgs
%         Proxy implementation
%         Client implementation
%               screenshots, features, anecdotes, zip support, etc.
%         Interesting implementation details
%               ADU/ALF
%               2-bit hacks
%               screenshots
%         Performance (and specs: code size, mem usage, etc)
%                 compare to other browsers on Pilot [claim: AMWP gives
%                         better performance]
%                 compare to desktop performance [claim: AMWP is a better
%                         way to support legacy clients, even over
%                         existing  low-bw]
%                 compare features to both desktop and Pilot browsers:
%                         transparent upgrades, weird file format
%                         capabilities, extrapolate to possible other
%                         features like Powerpoint browsing [claim: AMWP
%                         enables richer feature set, for lower cost]
%               report Tbmp-munger as upper bound on expected latency
%               compare Perl html vs C html
%         TACC cluster server brief descr  [AF]
%                 scaling, F/T, availabilty; why important
%                 cost of operation [claim: cost effectiveness]
%                 BASE semantics; why good for this app [omit?]
%                 other TACC apps (1 paragraph) [claim: generalizable,
%                         means code can be re-used, etc]

\subsection{Proxy implementation}

%               screenshots, features, anecdotes, zip support, etc.

%  You can use the following text if you want, or else replace it.... i
%  started to write it and then realized it belongs in this section.

% NEED A BETTER NAME OTHER THAN AGGREGATOR REQUEST SERVICE

The proxy for the Wingman browser has four main functions.  These
are the image munger, the HTML munger, the zip munger, and the
aggregator request service.

\item The {\em image munger} reads GIF and JPEG images (the two most
common Web formats), converts them to the PPM \cite{netpbm} intermediate
form, optionally scales, color-quantizes and dithers, and finally
outputs the result in either the PalmPilot's native image format (Tbmp)
or our enhanced 2-bit-per-pixel format.  Although the above
steps are logically independent (and actually reside in separate files),
it was more efficient to combine them into a single worker.  
 
% I'm actually not sure if what I wrote here is accurate.  It is
% my understanding of how the HTML munger works

\item The {\em HTML munger} parses HTML markup, maps HTML tags to supported
font attributes, and generates an intermediate-form page layout.  When
inline image tags are encountered, the HTML munger fetches and
converts the image to the pilot bitmap format via the image munger,
scaled down in size so that the text size/image size ratio is roughly
equivalent to regular desktop browsing.  It also adds information to
the image so that the originally sized image can be requested in case
important detail was lost when the image was scaled down.  The
converted image is then cached by the HTML munger so that if the image
found on the HTML page more than once there is no need to fetch and
convert the image again.  The HTML munger returns a simple display
list of images and text to the client, the format being optimized for
download and display speed.

\item If the client fetches a zip file the {\em zip munger} takes zip
compressed files and converts them to a simple html page that is a
listing of all the files contained by the zip file.  The listing is
created as a set of links so that following these links will allow the
zip munger to then return the file that was selected.  The HTML that is
created by the zip munger is then parsed by the HTML munger and
converted to a format the client understands.

\item Although the client does not support forms, it needs some
mechanism for performing such tasks as web searches, or to access
useful web databases such as Tripquest (www.tripquest.com).  The {\em
aggregator request service} exists to perform this function.  Rather
than passing aggregator requests one of the three mungers, the proxy
sends these requests to the aggregator request service, which then
determines what service is being requested, and then runs a service
specific aggregator program that creates an HTML file that is then
passed onto the HTML munger to convert.  Current aggregators include
search interfaces to yahoo, hotbot, altavista, deja news, yahoo stock
quotes, and tripquest. 

Because new aggregators can be easily be added to the proxy, the
client needs a way to discover what aggregator services are available.
The aggregator request service includes a discovery mechanism, so that
the client can piggyback a request for a listing of all aggregation
services as part of a request for a web page.  This sends a listing of
currently available aggregators as a header to the data returned from
the original request.  The client adds this discovery request as part
the first request of any session, so that current list of aggregators
is available at all times.

\item The proxy also recognizes palmos databases and files, and passes them
through unmodified, merely adding a header along with the file sent
to the client so that the client knows to treat it as a file to be
saved on the pilot, and not as web pages to display.  This way users
can use the browser to install new applications onto their pilots.

% NEED SCRENSHOTS

\subsection{Client implementation}

The Wingman browser is similer in use to desktop browsers such as
Netscape.  The nature of the PalmPilot platform, however, requires
some additions to the features a web browser provides.

\item Wingman has a hotlist feature that works like the bookmark feature in
Netscape.  Pages can be hotlisted and quickly visited through the
hotlist window.

\item Wingman has a local cache so that frequently visited web sites
will load quickly.  If a user wants to see a recent version of a
cached page, there is a reload function that will send a new request
for the page out to the proxy.

\item In addition to a local cache of webpages, Wingman has a second
storage cache that is user maintained.  The user of Wingman must
manually add and delete pages to the storage cache.  They can visit
and store important pages and be assured that it will be locally
cached at all times, even when their PalmPilot is not connected to the
internet.

\item Wingman handles aggregators (described above) by a special aggregator
request window.  This window has a dropdown listing of all available
aggregators and an area where aggregation specific data (such as a
search string) can be inputted.

\item Because the image munger returns a scaled down version of an
image, important image detail, such as text, may be lost.  In order
for a user to view a closer-to-original version of the image (one that
is scaled down in color depth but not in height or width), the user
may click through an image in order to view the larger version.
Because clicking through an image can perform two distinct functions
(the user may want to follow a link or see the unshruken image),
clicking on an image brings up a popup list of choices and the user
can select which function is desired.

\subsection{Noteworthy Implementation Details}

%   ADU/ALF
%  here is some text you can use to talk about ALF and ADU's.

\item Although the PalmPilot OS is designed for 1 bit graphics, the
hardware supports a 2 bit gray-scale display.  2 bit images display
much more detail than 1 bit images do, especially at low resolutions,
and because images are and important part of the Wingman browser, 
Wingman overrides the PalmPilot OS drawing routines to provide support
for a 2 bit display.

\item Following the long-standing recommendations of \cite{alf}, 
complete, ready-to-render pages are delivered as application data
units (ADU's).  This simplifies the client logic considerably: when
the network layer delivers a network event, it means that an entire,
self-describing ADU is waiting in a buffer ready to be rendered.
Contrast this with traditional HTTP: in that protocol, a network event
merely indicates that some number of bytes has arrived, but framing is
left entirely to the application.  Furthermore, in HTTP, inline images
are generally fetched using independent transactions (perhaps in
parallel), requiring a nontrivial amount of connection management
overhead on the client.  Application-level framing eliminates these
concerns, makes the client simpler, and enables a ``push-friendly''
model of asynchrony.  We return to these ideas in section
\ref{lessons}.

%               2-bit hacks, aggregators

\subsection{Performance}

%                 compare to other browsers on Pilot [claim: AMWP gives
%                         better performance]
%                 compare to desktop performance [claim: AMWP is a better
%                         way to support legacy clients, even over
%                         existing  low-bw]
%                 compare features to both desktop and Pilot browsers:
%                         transparent upgrades, weird file format
%                         capabilities, extrapolate to possible other
%                         features like Powerpoint browsing [claim: AMWP
%                         enables richer feature set, for lower cost]
%               report Tbmp-munger as upper bound on expected latency
%               compare Perl html vs C html


% Need to chose which data to use, how to present it.  I want to talk
% to you about this before I make the tables.  Current numbers assume
% all data used.

% need to indroduce the browsers used.

\item Despite the fact that Wingman is a graphical browser while
Palmscape is a text only browser, Wignman was still faster than
Palmscape in 93 percent of the sites tested, not including those sites
that caused Palmscape to crash.  At a 19200 baud transfer rate,
Wingman was at least two times faster than Palmscape 43 percent of the
time.  At 56700 baud, as the time to display a page becomes relatively
CPU bound, this number raises to 54 percent.  The PalmPilot has a slow
CPU and a limited amount of memory, and therefore parsing HTML on the
PalmPilot can be painfully slow.  By using the proxy to do all HTML
parsing on a vastly more powerful machine we can speed up transfer
time significantly while providing more content to the user.

Also notble is that in ten percent of the test cases Palmscape
crashed upon loading the page.  Because of the difficulty in writing
code to parse and display HTML on such a limited resource machine as
the PalmPilot, writing stable code is especially hard.  Our proxy not
only allows Wingman to display web pages faster, it also makes Wingman
more stable and reliable.

\item Compared to Netscape running on a 300mhz Pentium II machine with
128 mbs of memory, Wingman was still faster at downloading and
displaying pages in 77 percent of the test cases.  In this situation
the savings are caused by the image munger reducing the resolution of
images both in color depth and image size before sending the image
over a slow link.  Although Netscape receives and displays more data,
that excess data is useless to a device with such a limited display
such as the PalmPilot.  At 57600 baud Wingman is at least two times
faster than Netscape 33 percent of the time, and at 19200 baud this
number shoots up to 73 percent!  Any non-proxy based web browser that
supports images must download the entire image before displaying it,
even if the image ends up being reduced in quality when displayed.  So
a proxy system for thin clients will be useful even when the CPUs of
small devices are fast enough that displaying and parsing web pages is
no longer a CPU bound task.

% do we really want numbers taken from the transend distillers?  
% are they valid?  Do they seem valid to the reader even if they are?
% it seems that the numbers we have are good enough that adding this
% just hurts us.

\item The HTML munger used was written in perl rather than a faster
language such as C, because perl's string functions are more suited to
the tasks required by such a program.  In addition the HTML parsing
routines in the HTML munger were optimized for ease of use rather than
execution speed.  If the HTML munger was rewritten and optimized for
execution speed we can expect an order of magitude decrease in
distillation.  This would make the Wingman browser the fastest in
almost all the test cases.

\item It is not only through increased download times that the proxy
architecture is a win for web browsing.  By moving the parsing of pages
and images off to the proxy server new file formats can be
transparently supported.  All the would be needed to support a new
format would be the addition of a new munger that understood that
format.  In this way we can support new formats such as XML, without
requiring any changes to the browser.  Not only is this easier for the
development of the browser, it also means that Wingman users don't
need to upgrade their browser just to view new formats.

%
%  TACC cluster server description
%

\subsection{Cluster-Based TACC Server Architecture}

Our cluster-based TACC server is motivated by the observation that
clusters of workstations interconnected by a fast system-area network
(such as switched 100-Mb/s Ethernet or Myrinet \cite{MYRI_95}) are in
many ways a good match for large-scale network services.  Using
commodity PC's as the unit of scaling allows the service to ride the
leading edge of the cost/performance curve (cost effectiveness and
incremental growth).  The inherent redundancy of clusters can be used
to mask transient failures (high availability).  Finally,
``embarrassingly parallel'' network service workloads map well onto
networks of commodity workstations.  Since the development of cluster
software and administration of a running cluster remain complex, we
have isolated much of the machinery needed to support high
availability and incremental growth into a lower layer of our cluster
software.  The upper layer supports the TACC programming model API's
alluded to in section \ref{proxy}, so that new TACC services can use
our cluster server as an off-the-shelf solution to scalability,
availability, and several other problems.  We describe our system
architecture at a high level; a detailed discussion of the
architecture and the performance of our cluster can be found in
\cite{sosp16}.

\begin{figure}[tbh]
\epsfxsize 0.95\hsize
\begin{center}
\makebox{
\epsfbox[0 0 340 303]{./figures/arch.eps}
}
\end{center}
\caption{{\bf Components of a cluster-based TACC server}
include front 
ends (FE), TACC workers (W) and caches (\$),
% $ to make emacs happy!!
a user profile database, a graphical monitor/administration interface,
and a fault-tolerant load
manager whose functionality logically extends into the manager stubs
(MS) and worker stubs (WS).}\label{arch_sns}
\end{figure}

The software-component block diagram of a scalable TACC server is shown
in figure 
\ref{arch_sns}.  
{\em Front ends} receive client requests from the outside world and
``shepherd'' them through the system,
by fetching Internet content via the {\em caches},  matching the request
with the appropriate user profile from the {\em 
customization database},  and queueing the request for service by one or more
{\em TACC workers} that will process the data according to the user
preferences.   Front ends maximize system throughput by maintaining state for
many simultaneous outstanding requests, and can be replicated for both
scalability and availability.
The {\em Load Balancing/Fault Tolerance manager} is responsible for
internal reactive load balancing, autostarting and reaping workers, and
detecting and recovering from various system failures, including crashed
components and network partitions, via multicast heartbeat and
process-peer fault 
tolerance.  In addition to machines dedicated to running the service,
the manager can exploit an {\em overflow pool} of general-use machines,
which are harnessed and released as needed.
The entire system is administered through a 
{\em Graphical Monitor}, which supports asynchronous
error notification via email or pager, temporary disabling of system
components for hot upgrades, and visualization of the system's behavior
using Tcl/Tk \cite{tcltk}.  

Our cluster software has been hosting TranSend
\cite{transend} and Wingman on
the Berkeley NOW (Network of Workstations \cite{Ande95b}) since April
1997.  The dedicated pool consists of four SPARCstation-10's and the
overflow pool consists of up to 100 SPARC Ultra-1 Enterprise servers.
Under typical load, about five Ultra-1's are serving TranSend and
Wingman users.  The cluster has been running TranSend since April 1997,
and Wingman since November 1997, with very little
downtime.\footnote{During February 1998, we experienced frequent
sporadic downtime, which was ultimately traced to a configuration change
on the cluster that caused remote execution to sometimes break.}

TBD how many hits/second are TranSend and Wingman getting, and what does
this translate into in terms of subscribers?

@


1.6
log
@first draft of implementation I'm willing to let other people see.
I have no idea if this is acceptable or not.
@
text
@d36 1
a36 1
\subsection{{Proxy implementation}
@


1.5
log
@*** empty log message ***
@
text
@d1 343
a343 173
\section{Implementation}
\label{impl}

% Detailed description/implementation [DL,AP] - 2.5 pgs
%         User's view of the client
%               screenshots, features, anecdotes, zip support, etc.
%         Interesting implementation details
%               ADU/ALF
%               2-bit hacks, aggregators
%               screenshots
%         Performance (and specs: code size, mem usage, etc)
%                 compare to other browsers on Pilot [claim: AMWP gives
%                         better performance]
%                 compare to desktop performance [claim: AMWP is a better
%                         way to support legacy clients, even over
%                         existing  low-bw]
%                 compare features to both desktop and Pilot browsers:
%                         transparent upgrades, weird file format
%                         capabilities, extrapolate to possible other
%                         features like Powerpoint browsing [claim: AMWP
%                         enables richer feature set, for lower cost]
%               report Tbmp-munger as upper bound on expected latency
%               compare Perl html vs C html
%         TACC cluster server brief descr  [AF]
%                 scaling, F/T, availabilty; why important
%                 cost of operation [claim: cost effectiveness]
%                 BASE semantics; why good for this app [omit?]
%                 other TACC apps (1 paragraph) [claim: generalizable,
%                         means code can be re-used, etc]

\subsection{User Experience}

%               screenshots, features, anecdotes, zip support, etc.

%  You can use the following text if you want, or else replace it.... i
%  started to write it and then realized it belongs in this section.

\item The {\em image munger} reads GIF and JPEG images (the two most
common Web formats), converts them to the PPM \cite{netpbm} intermediate
form, optionally scales, color-quantizes and dithers, and finally
outputs the result in either the PalmPilot's native image format (Tbmp)
or our enhanced 2-bit-per-pixel format.  Although the above
steps are logically independent (and actually reside in separate files),
it was more efficient to combine them into a single worker.  

\item The {\em HTML munger} parses HTML markup, maps HTML tags to supported
font attributes, and generates an intermediate-form page layout.  When
inline image tags are encountered, the HTML munger 

\subsection{Noteworthy Implementation Details}

%   ADU/ALF
%  here is some text you can use to talk about ALF and ADU's.

Following the long-standing recommendations of \cite{alf}, 
complete, ready-to-render pages are delivered as application data units
(ADU's).  This simplifies the client logic considerably: when the
network layer delivers a network event, it means that an entire,
self-describing ADU is waiting in a buffer ready to be rendered.
Contrast this with traditional HTTP: in that protocol, a network event
merely indicates that some number of bytes has arrived, but framing is
left entirely to the application.  Furthermore, in HTTP, inline images
are generally fetched using independent transactions (perhaps in
parallel), requiring a nontrivial amount of connection management
overhead on the client.  Application-level framing eliminates these
concerns, makes the client simpler, and enables a ``push-friendly''
model of asynchrony.  We return to these ideas in section
\ref{lessons}.

%               2-bit hacks, aggregators

\subsection{Performance}

%                 compare to other browsers on Pilot [claim: AMWP gives
%                         better performance]
%                 compare to desktop performance [claim: AMWP is a better
%                         way to support legacy clients, even over
%                         existing  low-bw]
%                 compare features to both desktop and Pilot browsers:
%                         transparent upgrades, weird file format
%                         capabilities, extrapolate to possible other
%                         features like Powerpoint browsing [claim: AMWP
%                         enables richer feature set, for lower cost]
%               report Tbmp-munger as upper bound on expected latency
%               compare Perl html vs C html


%
%  TACC cluster server description
%

\subsection{Cluster-Based TACC Server Architecture}

Our cluster-based TACC server is motivated by the observation that
clusters of workstations interconnected by a fast system-area network
(such as switched 100-Mb/s Ethernet or Myrinet \cite{MYRI_95})
are in many ways a good match for large-scale
network services.  Using commodity PC's as the unit of scaling allows
the service to ride the leading edge of the cost/performance curve (cost
effectiveness and incremental growth).  The inherent redundancy of
clusters can be used to mask transient failures (high availability).
Finally, ``embarrassingly parallel'' network service workloads map well
onto networks of commodity workstations.
Since the  development of cluster software and administration of a
running cluster 
remain complex, we have isolated much of the machinery needed to support
high availability and incremental growth into a lower layer of our
cluster software.  The upper layer supports the TACC programming model
API's alluded to in section \ref{proxy}, 
so that new TACC services can use our cluster server
as an off-the-shelf solution to scalability, availability, and
several other problems.    We describe our system architecture at a high level; a detailed
discussion of the architecture and the  performance of our cluster can be 
found in \cite{sosp16}.

\begin{figure}[tbh]
\epsfxsize 0.95\hsize
\begin{center}
\makebox{
\epsfbox[0 0 340 303]{./figures/arch.eps}
}
\end{center}
\caption{{\bf Components of a cluster-based TACC server}
include front 
ends (FE), TACC workers (W) and caches (\$),
% $ to make emacs happy!!
a user profile database, a graphical monitor/administration interface,
and a fault-tolerant load
manager whose functionality logically extends into the manager stubs
(MS) and worker stubs (WS).}\label{arch_sns}
\end{figure}

The software-component block diagram of a scalable TACC server is shown
in figure 
\ref{arch_sns}.  
{\em Front ends} receive client requests from the outside world and
``shepherd'' them through the system,
by fetching Internet content via the {\em caches},  matching the request
with the appropriate user profile from the {\em 
customization database},  and queueing the request for service by one or more
{\em TACC workers} that will process the data according to the user
preferences.   Front ends maximize system throughput by maintaining state for
many simultaneous outstanding requests, and can be replicated for both
scalability and availability.
The {\em Load Balancing/Fault Tolerance manager} is responsible for
internal reactive load balancing, autostarting and reaping workers, and
detecting and recovering from various system failures, including crashed
components and network partitions, via multicast heartbeat and
process-peer fault 
tolerance.  In addition to machines dedicated to running the service,
the manager can exploit an {\em overflow pool} of general-use machines,
which are harnessed and released as needed.
The entire system is administered through a 
{\em Graphical Monitor}, which supports asynchronous
error notification via email or pager, temporary disabling of system
components for hot upgrades, and visualization of the system's behavior
using Tcl/Tk \cite{tcltk}.  

Our cluster software has been hosting TranSend
\cite{transend} and Wingman on
the Berkeley NOW (Network of Workstations \cite{Ande95b}) since April
1997.  The dedicated pool consists of four SPARCstation-10's and the
overflow pool consists of up to 100 SPARC Ultra-1 Enterprise servers.
Under typical load, about five Ultra-1's are serving TranSend and
Wingman users.  The cluster has been running TranSend since April 1997,
and Wingman since November 1997, with very little
downtime.\footnote{During February 1998, we experienced frequent
sporadic downtime, which was ultimately traced to a configuration change
on the cluster that caused remote execution to sometimes break.}

TBD how many hits/second are TranSend and Wingman getting, and what does
this translate into in terms of subscribers?

@


1.4
log
@*** empty log message ***
@
text
@d31 1
a31 2
% here's some free text you can use, that i started typing and then
% realized it doesn't belong in my section:
d33 1
d35 2
a36 14
% \begin{itemize}
% \item The {\em image munger} reads GIF and JPEG images (the two most
% common Web formats), converts them to the PPM \cite{netpbm} intermediate
% form, optionally scales, color-quantizes and dithers, and finally
% outputs the result in either the PalmPilot's native image format (Tbmp)
% or our enhanced 2-bit-per-pixel format.  Although the above
% steps are logically independent (and actually reside in separate files),
% it was more efficient to combine them into a single worker.  

% \item The {\em HTML munger} parses HTML markup, maps HTML tags to supported
% font attributes, and generates an intermediate-form page layout.  When
% inline image tags are encountered, the HTML munger 
% 
%  \end{itemize}
d38 48
@


1.3
log
@*** empty log message ***
@
text
@a43 3
% TBD more to
% say about this later.

d76 1
a76 3
several other problems.  Our prototype cluster software has been running
on the Berkeley NOW (Network of Workstations \cite{Ande95b}) since April
1997.  We describe our system architecture at a high level; a detailed
d87 1
a87 1
\caption{{\bf Architecture of a cluster-based TACC server}:  Components
d89 1
a89 1
ends (FE), a pool of TACC workers (W) some of which may be caches (\$),
d91 3
a93 2
a user profile database, a graphical monitor, and a fault-tolerant load
manager, whose functionality logically extends into the manager stubs
d100 1
a100 1
{\em Front Ends} receive client requests from the outside world and
d114 4
a117 1
tolerance.  The entire system is administered through a 
d123 15
a137 3
% UC Berkeley cluster shared by transend and wingman
% number of machines typ in use
% upness
@


1.2
log
@*** empty log message ***
@
text
@d31 96
@


1.1
log
@*** empty log message ***
@
text
@d1 30
@
