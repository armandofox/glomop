head	1.44;
access;
symbols
	v15b:1.44
	v10b3:1.41
	v10b2:1.35
	v10b1:1.35;
locks; strict;
comment	@ * @;


1.44
date	97.11.15.00.26.10;	author aspolito;	state Exp;
branches;
next	1.43;

1.43
date	97.11.09.21.43.27;	author iang;	state Exp;
branches;
next	1.42;

1.42
date	97.11.05.22.02.05;	author iang;	state Exp;
branches;
next	1.41;

1.41
date	97.10.27.22.32.12;	author iang;	state Exp;
branches;
next	1.40;

1.40
date	97.10.26.19.41.00;	author iang;	state Exp;
branches;
next	1.39;

1.39
date	97.10.25.19.50.26;	author iang;	state Exp;
branches;
next	1.38;

1.38
date	97.10.24.16.02.41;	author iang;	state Exp;
branches;
next	1.37;

1.37
date	97.10.24.03.30.30;	author iang;	state Exp;
branches;
next	1.36;

1.36
date	97.10.23.23.02.29;	author lcddave;	state Exp;
branches;
next	1.35;

1.35
date	97.10.07.22.42.05;	author iang;	state Exp;
branches;
next	1.34;

1.34
date	97.10.06.17.57.19;	author iang;	state Exp;
branches;
next	1.33;

1.33
date	97.09.25.03.28.46;	author iang;	state Exp;
branches;
next	1.32;

1.32
date	97.09.22.23.38.23;	author iang;	state Exp;
branches;
next	1.31;

1.31
date	97.09.22.21.31.18;	author aspolito;	state Exp;
branches;
next	1.30;

1.30
date	97.09.19.22.22.58;	author aspolito;	state Exp;
branches;
next	1.29;

1.29
date	97.09.18.21.48.19;	author aspolito;	state Exp;
branches;
next	1.28;

1.28
date	97.09.17.00.34.46;	author iang;	state Exp;
branches;
next	1.27;

1.27
date	97.09.16.22.51.25;	author iang;	state Exp;
branches;
next	1.26;

1.26
date	97.09.15.23.08.55;	author lcddave;	state Exp;
branches;
next	1.25;

1.25
date	97.09.15.22.59.54;	author lcddave;	state Exp;
branches;
next	1.24;

1.24
date	97.09.14.23.41.11;	author lcddave;	state Exp;
branches;
next	1.23;

1.23
date	97.09.14.21.31.59;	author lcddave;	state Exp;
branches;
next	1.22;

1.22
date	97.09.13.00.36.49;	author iang;	state Exp;
branches;
next	1.21;

1.21
date	97.09.12.21.46.09;	author iang;	state Exp;
branches;
next	1.20;

1.20
date	97.09.12.17.30.10;	author aspolito;	state Exp;
branches;
next	1.19;

1.19
date	97.09.11.19.59.29;	author iang;	state Exp;
branches;
next	1.18;

1.18
date	97.09.11.00.47.17;	author aspolito;	state Exp;
branches;
next	1.17;

1.17
date	97.09.10.23.49.25;	author iang;	state Exp;
branches;
next	1.16;

1.16
date	97.09.10.02.44.26;	author aspolito;	state Exp;
branches;
next	1.15;

1.15
date	97.09.09.23.25.02;	author iang;	state Exp;
branches;
next	1.14;

1.14
date	97.09.08.20.31.56;	author iang;	state Exp;
branches;
next	1.13;

1.13
date	97.09.08.00.24.30;	author lcddave;	state Exp;
branches;
next	1.12;

1.12
date	97.09.06.02.19.00;	author aspolito;	state Exp;
branches;
next	1.11;

1.11
date	97.09.03.00.49.23;	author aspolito;	state Exp;
branches;
next	1.10;

1.10
date	97.08.29.23.25.04;	author lcddave;	state Exp;
branches;
next	1.9;

1.9
date	97.08.28.01.16.26;	author aspolito;	state Exp;
branches;
next	1.8;

1.8
date	97.08.26.00.32.49;	author lcddave;	state Exp;
branches;
next	1.7;

1.7
date	97.08.22.00.59.51;	author lcddave;	state Exp;
branches;
next	1.6;

1.6
date	97.08.22.00.46.50;	author lcddave;	state Exp;
branches;
next	1.5;

1.5
date	97.08.09.00.10.21;	author aspolito;	state Exp;
branches;
next	1.4;

1.4
date	97.08.08.00.10.30;	author lcddave;	state Exp;
branches;
next	1.3;

1.3
date	97.08.06.22.25.22;	author lcddave;	state Exp;
branches;
next	1.2;

1.2
date	97.08.05.00.10.56;	author aspolito;	state Exp;
branches;
next	1.1;

1.1
date	97.08.01.23.08.28;	author aspolito;	state Exp;
branches;
next	;


desc
@@


1.44
log
@sendURL much changed and much prettier...history works now.
@
text
@#include <Pilot.h>
#include "globals.h"
#include "callback.h"
#include "mainform.h"
#include "pagedisplay.h"
#include "history.h"
#include "hotlist.h"
#include "cache.h"
#include "send.h"
#include "notify.h"

Boolean MainFormHandleEvent (EventPtr e) {
  Boolean handled = false;
  FormPtr frm;
  int sendRes;
  static int dragX = -1;
  static int dragY = -1;

  CALLBACK_PROLOGUE
  
  switch (e->eType) {
  case keyDownEvent:
    if (e->data.keyDown.chr == pageUpChr) {	
      ScrollPage(0, -scrollSize);
      handled = true;
    } else if (e->data.keyDown.chr == pageDownChr) {
      ScrollPage(0, scrollSize);
      handled = true;
    }
    break;

  case frmCloseEvent:
    EraseMainWindow();
    handled = false;
    break;

  case frmOpenEvent:
    frm = FrmGetActiveForm();
    /* I'm going to try getting rid of this; let me know if there
       are droppings left over from something... - Ian */
    /* WinEraseWindow(); */
    FrmDrawForm(frm);
    StatusDraw(0);
    ScrollRefresh();
    if (hPage) {
      WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);
    }
    handled = true;
    break;

  case menuEvent:
    MenuEraseStatus(NULL);

    switch(e->data.menu.itemID) {
      char * url;
      void * data;
      VoidHand tcurURL;
      ULong tcurURLLength;

    case GetMenu: 
      FrmPopupForm(URLForm);
      break;

    case AggregatorMenu:
      FrmPopupForm(AggForm);
      break;

    case StopMenu:
      cancelSend(conID);
      break;      

    case BackMenu:
      if (MoveInHistory(1)) { 
	EraseMainWindow();
	ScrollReset();
	if (hPage) {
	  WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);
	}
      }
      break;
    case ForwardMenu:
      if (MoveInHistory(-1)) {
	EraseMainWindow();		  
	ScrollReset();
	if (hPage) {
	  WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);
	}
      }
      break;
    case SourceMenu:
    case DocMenu:
      if (curURL) {
	char *t, *c;
	int isdoc = (e->data.menu.itemID == DocMenu);

	c = MemHandleLock(curURL);
	/* View source:
	     o If curURL starts with src: or doc:, remove it
	     o Otherwise, prepend src:
	   View source as Doc:
	     o If curURL starts with src: or doc:, remove it
	     o _As well_, prepend doc:
	*/
	if (curURLLength >= 4 && ((c[0] == 's' && c[1] == 'r') ||
	    (c[0] == 'd' && c[1] == 'o')) && c[2] == 'c' && c[3] == ':') {
	    tcurURLLength = curURLLength - (isdoc ? 0 : 4);
	    tcurURL = MemHandleNew(tcurURLLength);
	    t = MemHandleLock(tcurURL);
	    if (isdoc) {
		MemMove(t, "doc:", 4);
	    }
	    MemMove(t + (isdoc ? 4 : 0), c+4, tcurURLLength);
	} else {
	    tcurURLLength = curURLLength + 4;
	    tcurURL = MemHandleNew(tcurURLLength);
	    t = MemHandleLock(tcurURL);
	    MemMove(t, isdoc ? "doc:" : "src:", 4);
	    MemMove(t+4, c, curURLLength);
	}
	
	MemHandleUnlock(curURL);
	MemHandleUnlock(tcurURL);

	if (!SendURL(&conID, tcurURL, true, true, false, true)) {
	  if (tcurURL) {
	    MemHandleFree(tcurURL);
	  }
	}
      }
      break;
    case PrefsMenu:
      FrmGotoForm(PrefsForm);
      break;
    case HotListMenu:
      FrmGotoForm(HotListForm);
      break;    
    case AddHotListMenu:
      AddUrlToHotList();
      break;
    case ReloadMenu: 
      if (curURL) {
	void *t, *c;
	
	if (transURL) {
	  MemHandleFree(transURL);
	}
	transURLLength = curURLLength;
	transURL = MemHandleNew(transURLLength);
	
	t = MemHandleLock(transURL);
	c = MemHandleLock(curURL);

	MemMove(t, c, transURLLength);
	
	MemHandleUnlock(curURL);
	MemHandleUnlock(transURL);
	
	SendURL(&conID, transURL, false, false, true, false);

      }
      break;
    case AddCacheMenu:
      if (hPage && curURL) {
	url = (char *) MemHandleLock(curURL); 
	data = MemHandleLock(hPage); 
	AddToCache(url, MemHandleSize(curURL), data, MemHandleSize(hPage),
		   0, offlineInfoDB, offlineDB);
	MemHandleUnlock(hPage);
	MemHandleUnlock(curURL);
      }
      break;
    case EditCacheMenu:
      FrmGotoForm(OfflineCacheForm);
      break;
    case FlushCacheMenu:
      FlushCache(cacheInfoDB, cacheDB);
      break;
    case InfoMenu:
      tcurURLLength = StrLen(INFO_URL) + 1;
      tcurURL = MemHandleNew((ULong)tcurURLLength);
      if (tcurURL) {
	char *urltxt = MemHandleLock(tcurURL);
        StrCopy(urltxt, INFO_URL);
        MemHandleUnlock(tcurURL);
      } else {
	ErrFatalDisplayIf(tcurURLLength, "Out of memory!");
      }
      sendRes = SendURL(&conID, tcurURL, true, true, false, true);
      if (!sendRes) {
	if (tcurURL) {
	  MemHandleFree(tcurURL);
	}
      }
      break;
    }

    handled = true;
    break;    
  case penDownEvent:
    if (hPage) {
      char *outURL;
      int eventPieceOff;
      SWord xcoord, ycoord;
      dragX = -1;
      dragY = -1;
      if (ScrollHandleEvent(e)) {
        handled = true;
      } else {
	eventPieceOff = PieceClicked(hPage, e->screenX, e->screenY, 
				     currXPosOffset, currYPosOffset,
				     &xcoord, &ycoord);
	if (eventPieceOff >= 0) {
	  int imgClkResult;
	  SWord *hPtr, *eventPiece;

	  hPtr = MemHandleLock(hPage);
	  ErrFatalDisplayIf(!hPtr, "Cannot lock hPage");
	  eventPiece = hPtr + eventPieceOff;

	  imgClkResult = ClickImage(e, eventPiece, currXPosOffset,
					currYPosOffset);

	  MemHandleUnlock(hPage);

	  if (imgClkResult == -1) {
	    if (UpdateHiLiPiece(-1, eventPieceOff, currXPosOffset,
		currYPosOffset)) {
		handled = true;
	    }
	  } else if (imgClkResult == 0) {
	    handled = true;
	  } else {
	    /* This is an IMAGE */
	    VoidHand tcurURL;
	    ULong tcurURLLength;

	    hPtr = MemHandleLock(hPage);
	    ErrFatalDisplayIf(!hPtr, "Cannot lock hPage");
	    eventPiece = hPtr + eventPieceOff;

	    if (imgClkResult == 1) { /* if sending the first URL */
	      int ismap = eventPiece[6] & IMAGE_ISMAP;
	      int hasserv = eventPiece[6] & IMAGE_HAS_SERV_SIZE;
	      char coordbuf[15];

	      /* create buffer for sending info */
	      tcurURLLength = eventPiece[hasserv ? 9 : 7];
	      if (ismap) {
		  SWord cli_x = eventPiece[4];
		  SWord cli_y = eventPiece[5];
		  SWord serv_x, serv_y;
		  if (hasserv) {
		    serv_x = eventPiece[7]; serv_y = eventPiece[8];
		  } else {
		    serv_x = cli_x; serv_y = cli_y;
		  }
		  if (!cli_x) cli_x = 1;
		  if (!cli_y) cli_y = 1;
		  /* %d can be at most 6 chars ("-32768") */
		  StrPrintF(coordbuf, "?%d,%d",
			     (int)((Long)xcoord * (Long)serv_x / (Long)cli_x),
			     (int)((Long)ycoord * (Long)serv_y / (Long)cli_y));
		  tcurURLLength += StrLen(coordbuf);
	      }
	      tcurURL = MemHandleNew((ULong) tcurURLLength);
	      if (tcurURL) {
		outURL = MemHandleLock(tcurURL);
		/* data out setup */
		StrCopy (outURL, (char*) &eventPiece[hasserv ? 10 : 8]);
		if (ismap) {
		    StrCat(outURL, coordbuf);
		}
		MemHandleUnlock(tcurURL);
	      } else {
		ErrFatalDisplayIf (tcurURLLength, "Not enough memory!");
	      }
	    } else if (imgClkResult == 2) { /* if sending second URL */
	      int hasserv = eventPiece[6] & IMAGE_HAS_SERV_SIZE;

	      /* skip past first URL */
	      int index = hasserv ? 9 : 7;
	      tcurURLLength = eventPiece[index++];	    
	      if ((tcurURLLength % 2) == 0) {
		index += (tcurURLLength >> 1);
	      } else {
		index += ((tcurURLLength + 1) >> 1);
	      }
	      /* create buffer for sending info */
	      tcurURLLength = eventPiece[index++];
	      tcurURL = MemHandleNew((ULong) tcurURLLength);
	      if (tcurURL) {
		outURL = MemHandleLock(tcurURL);
		/* data out setup */
		StrCopy (outURL, (char *) &eventPiece[index]);
		MemHandleUnlock(tcurURL);
	      } else {
		ErrFatalDisplayIf (tcurURLLength, "Not enough memory!");
	      }
	    } else {
	      tcurURLLength = 0;
	      tcurURL = 0;
	      ErrFatalDisplayIf (tcurURLLength, "Internal Error");
	    }

	    MemHandleUnlock(hPage);

	    /* send out request */	    
	    sendRes = SendURL(&conID, tcurURL, true, true, false, true);
	    if (!sendRes) {
	      MemHandleFree (tcurURL);
	    }

	    handled = true;
	  }
	}
	if (!handled && e->screenX < MAIN_DISPLAY_WIDTH &&
		    e->screenY < MAIN_DISPLAY_HEIGHT) {
	    /* A penDown in the main screen that didn't do anything else */
	    dragX = e->screenX;
	    dragY = e->screenY;
	    handled = true;
	}
      } /* end drag test else */
    }
  break;
  
  case penMoveEvent:
    {
      if (hPage) {
	if (ScrollHandleEvent(e)) {
	  handled = true;
	} else if (dragX >= 0) {
	    int diffx, diffy, sx, sy;
	    sx = e->screenX;
	    sy = e->screenY;
	    if (sx >= MAIN_DISPLAY_WIDTH) sx = MAIN_DISPLAY_WIDTH - 1;
	    if (sy >= MAIN_DISPLAY_HEIGHT) sy = MAIN_DISPLAY_HEIGHT - 1;
	    diffx = sx - dragX;
	    diffy = sy - dragY;
	    if (((diffx > 0) ? diffx : -diffx) > SCROLL_THRESH ||
	        ((diffy > 0) ? diffy : -diffy) > SCROLL_THRESH) {
		ScrollPage(-diffx, -diffy);
		dragX = sx;
		dragY = sy;
	    }
	} else {
	  /* standard link & image click handler */
	  int eventPieceOff = PieceClicked(hPage, e->screenX, e->screenY, 
					   currXPosOffset, currYPosOffset,
					   NULL, NULL);
	  /* no event piece chk because it must track movement off piece */
	  UpdateHiLiPiece(0, eventPieceOff, currXPosOffset, currYPosOffset);
	  handled = true;
	}
      }
    }
  break;

  case penUpEvent:
    if (hPage) {
      if (ScrollHandleEvent(e)) {
        handled = true;
      } else if (dragX >= 0) {
	    int diffx, diffy, sx, sy;
	    sx = e->screenX;
	    sy = e->screenY;
	    if (sx >= MAIN_DISPLAY_WIDTH) sx = MAIN_DISPLAY_WIDTH - 1;
	    if (sy >= MAIN_DISPLAY_HEIGHT) sy = MAIN_DISPLAY_HEIGHT - 1;
	    diffx = sx - dragX;
	    diffy = sy - dragY;
	    ScrollPage(-diffx, -diffy);
	    dragX = -1;
	    dragY = -1;
      } else {
	char *outURL;
	/* standard link & image click handler */
	int eventPieceOff = PieceClicked(hPage, e->screenX, e->screenY, 
					 currXPosOffset, currYPosOffset,
					 NULL, NULL);
	if (eventPieceOff >= 0) {
	  SWord *hPtr, *eventPiece;
	  Word attributes;
	  
	  hPtr = MemHandleLock(hPage);
	  ErrFatalDisplayIf(!hPtr, "Cannot lock hPage");
	  eventPiece = hPtr + eventPieceOff;
	  
	  attributes = eventPiece[6];
	  
	  MemHandleUnlock(hPage);
	  
	  if (UpdateHiLiPiece(1, eventPieceOff, currXPosOffset,
				currYPosOffset) && (attributes & LINK)
				&& !(attributes & IMAGE)) {
	    /* create buffer for sending info */
	    ULong tcurURLLength;
	    VoidHand tcurURL;
	    
	    hPtr = MemHandleLock(hPage);
	    ErrFatalDisplayIf(!hPtr, "Cannot lock hPage");
	    eventPiece = hPtr + eventPieceOff;
	    
	    tcurURLLength = eventPiece[7];
	    tcurURL = MemHandleNew((ULong) tcurURLLength);
	    if (tcurURL) {
	      outURL = MemHandleLock(tcurURL);
	      /* data out setup */
	      StrCopy (outURL, (char*) &eventPiece[8]);
	      MemHandleUnlock(tcurURL);
	    } else {
	      ErrFatalDisplayIf (tcurURLLength, "Not enough memory!");
	    }
	    
	    MemHandleUnlock(hPage);
	    
	    /* set out link request */
	    sendRes = SendURL(&conID, tcurURL, true, true, false, true);
	    if (!sendRes) {
	      if (tcurURL) {
		MemHandleFree(tcurURL);
	      }		
	    }
	    /* cleanup */	    
	    handled = true;
	  }
	}
      } /* end link drag test */
    }
    break;  

  case winEnterEvent:
    /* Refresh the screen */
    if (e->data.winEnter.enterWindow == FrmGetWindowHandle(FrmGetActiveForm()) &&
        e->data.winEnter.enterWindow !=	e->data.winEnter.exitWindow) {
	if (hPage) {
	  WinEraseWindow();
	  ScrollRefresh();
	  WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);	      
	}
    }
    StatusDraw(0);
    break;

  default:
    break;
  }


  CALLBACK_EPILOGUE

  return handled;
}

@


1.43
log
@Recover from CVS repository crash.  Changes include:
o Editing of entries in hotlist and storage
o Server-side imagemaps
o Recognition of ImageViewer .pdb files
@
text
@d69 1
a69 1
      cancelSend();
d124 4
a127 25
	sendRes = SendURL(tcurURL, &hPage);
	if (sendRes == 2) {
	    if (curURL) {
	      MemHandleFree(curURL);
	    }
	    curURL = tcurURL;
	    curURLLength = tcurURLLength;
	    PutInHistory(curURL, curURLLength);
	    firstOpen = 0;
	    EraseMainWindow();
	    ScrollReset();
	    if (hPage) {
	      WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);
	    }
	} else if (sendRes == 1) {
	    firstOpen = 0;
	    if (transURL) {
	      MemHandleFree(transURL);
	    }
	    transURL = tcurURL;
	    transURLLength = tcurURLLength;
	} else {
	    if (tcurURL) {
		MemHandleFree(tcurURL);
	    }
d143 1
d157 2
a159 1
	SendURLNoCache(transURL, 1);
d188 2
a189 22
      sendRes = SendURL(tcurURL, &hPage);
      if (sendRes == 2) {
        if (curURL) {
	  MemHandleFree(curURL);
	}
	curURL = tcurURL;
	curURLLength = tcurURLLength;
	PutInHistory(curURL, curURLLength);
	firstOpen = 0;
	EraseMainWindow();
	ScrollReset();
	if (hPage) {
	  WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);
	}
      } else if (sendRes == 1) {
	firstOpen = 0;
	if (transURL) {
	  MemHandleFree(transURL);
	}
	transURL = tcurURL;
	transURLLength = tcurURLLength;
      } else {
d191 1
a191 1
	    MemHandleFree(tcurURL);
d196 1
d198 1
a198 2
    break;

d307 4
a310 20
	  /* send out request */	    
	    sendRes = SendURL(tcurURL, &hPage);
	    if (sendRes == 2) {
	      if (curURL) {
		MemHandleFree(curURL);
	      }
	      curURL = tcurURL;
	      curURLLength = tcurURLLength;
	      PutInHistory(curURL, curURLLength);
	      EraseMainWindow();
	      ScrollReset();
	      if (hPage) {
		WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);
	      }
	    } else if (sendRes == 1) {
	      if (transURL) {
		MemHandleFree(transURL);
	      }
	      transURL = tcurURL;
	      transURLLength = tcurURLLength;
d312 1
d417 2
a418 22
	    sendRes = SendURL(tcurURL, &hPage);
	    if (sendRes == 2) {
	      if (curURL) {
		MemHandleFree(curURL);
	      }
	      curURL = tcurURL;
	      curURLLength = tcurURLLength;
	      PutInHistory(curURL, curURLLength);
	      /* redraw the page */
	      EraseMainWindow();
	      ScrollReset();
	      if (hPage) {
		WinDrawProxyString(hPage, currXPosOffset, currYPosOffset);
	      }
	    } else if (sendRes == 1) {
	      /* don't redraw, just let the status bar work */
	      if (transURL) {
		MemHandleFree(transURL);
	      }
	      transURL = tcurURL;
	      transURLLength = tcurURLLength;		  
	    } else {
@


1.42
log
@Added Doc support (load source as a Doc file)
@
text
@d242 1
d249 2
a250 1
				     currXPosOffset, currYPosOffset);
d272 1
d280 5
a284 1
	    if (imgClkResult == 1) { /* if sending the first URL (not the ALT)*/
d286 18
a303 1
	      tcurURLLength = eventPiece[7];
d308 4
a311 1
		StrCopy (outURL, (char*) &eventPiece[8]);
d317 2
d320 1
a320 1
	      int index = 7;
d403 2
a404 1
					   currXPosOffset, currYPosOffset);
d432 2
a433 1
					 currXPosOffset, currYPosOffset);
d447 2
a448 1
				currYPosOffset) && (attributes & LINK)) {
@


1.41
log
@Added "View source" menu option
@
text
@d91 1
d94 1
d97 10
a106 3
	if (curURLLength >= 4 && c[0] == 's' && c[1] == 'r' && c[2] == 'c'
	    && c[3] == ':') {
	    tcurURLLength = curURLLength - 4;
d109 4
a112 1
	    MemMove(t, c+4, tcurURLLength);
d117 1
a117 1
	    MemMove(t, "src:", 4);
@


1.40
log
@Added a "smarter" scrolling routine; copy the overlapping rectangle, and only
erase and update the remaining gnomon
@
text
@d90 50
d149 1
a149 1
    case RefreshCacheMenu: 
@


1.39
log
@o Added a horizontal scrollbar
o Added panning when you drag on the main form (as long as your penDown wasn't
  on something interesting); if we want to do "select text" later, something
  will have to be done.
@
text
@d200 1
a200 1
	  if (imgClkResult == 0) {
d205 2
@


1.38
log
@Added some missing "handled = true;"s
@
text
@d16 2
d24 1
a24 1
      ScrollPage(-scrollSize);
d27 1
a27 1
      ScrollPage(scrollSize);
d46 1
a46 1
      WinDrawProxyString(hPage, currYPosOffset);
a74 1
	currYPosOffset = 0;
d77 1
a77 1
	  WinDrawProxyString(hPage, currYPosOffset);
a83 1
	currYPosOffset = 0;
d86 1
a86 1
	  WinDrawProxyString(hPage, currYPosOffset);
a154 1
	currYPosOffset = 0;
d157 1
a157 1
	  WinDrawProxyString(hPage, currYPosOffset);
d180 2
d186 1
a186 1
				     currYPosOffset);
d195 2
a196 1
	  imgClkResult = ClickImage(e, eventPiece, currYPosOffset);
d201 4
a204 1
	    UpdateHiLiPiece(-1, eventPieceOff, currYPosOffset);
a262 1
	      currYPosOffset = 0;
d265 1
a265 1
		WinDrawProxyString(hPage, currYPosOffset);
d274 1
d276 7
a282 1
	  handled = true;
d293 14
d310 1
a310 1
					   currYPosOffset);
d312 1
a312 1
	  UpdateHiLiPiece(0, eventPieceOff, currYPosOffset);
d323 11
d338 1
a338 1
					 currYPosOffset);
d351 2
a352 2
	  if (UpdateHiLiPiece(1, eventPieceOff, currYPosOffset) &&
	      (attributes & LINK)) {
a384 1
	      currYPosOffset = 0;
d387 1
a387 1
		WinDrawProxyString(hPage, currYPosOffset);
d416 1
a416 1
	  WinDrawProxyString(hPage, currYPosOffset);	      
@


1.37
log
@Added a scroll bar
@
text
@d181 3
a183 1
      if (!ScrollHandleEvent(e)) {
d271 1
d280 3
a282 1
	if (!ScrollHandleEvent(e)) {
d288 1
d296 3
a298 1
      if (!ScrollHandleEvent(e)) {
@


1.36
log
@adding in drag scrolling functionality in the right most 5 pixels
(buttons now disabled in that area.

need to implement the delay so the screen won't flicker with small2 or
3 pixel moves. dragScrollDelayedY was supposed to do it, but the code
I wrote for it didn't work. Now the variable just sits there without
ever being set.
@
text
@a11 7
#define SCROLL_TEST_FACTOR 1

static int dragScrollPageStartY = 0; /* unused, may not be needed */
static int dragScrollPenStartY = 0;
static int dragScrollFlag = 0;
static int dragScrollDelayedY = 0;

d22 1
a22 9
      if (hPage && currYPosOffset) {
	if (currYPosOffset < scrollSize) {
	  currYPosOffset = 0;
	} else {
	  currYPosOffset -= scrollSize;
	}
	EraseMainWindow();
	WinDrawProxyString(hPage, currYPosOffset);
      }
d24 2
a25 8
      break;
    }
    else if (e->data.keyDown.chr == pageDownChr) {
      if (hPage && moreOffscreen) {
	currYPosOffset += scrollSize;
	EraseMainWindow();
	WinDrawProxyString(hPage, currYPosOffset);
      }
d42 1
d74 1
d84 1
d156 1
d181 1
a181 8
      /* temporary drag bar test */
      if (e->screenX > 154) {
	/* starting in drag region, link functions disabled */
	dragScrollFlag = 1;
	dragScrollPageStartY = currYPosOffset;
	dragScrollPenStartY = e->screenY;
	dragScrollDelayedY = 0;
      } else { /* standard link & image click handler */
d257 1
d277 1
a277 15
	if (dragScrollFlag == 1) {
	  /* starting in drag region, link functions disabled */
	  int scrollRedrawOffset = e->screenY - dragScrollPenStartY;
	  if (((scrollRedrawOffset > 0) && moreOffscreen) ||
	      (scrollRedrawOffset < 0))   { /* limit down */
	    currYPosOffset = dragScrollPageStartY +
	      (SCROLL_TEST_FACTOR * (scrollRedrawOffset + dragScrollDelayedY));
	    dragScrollDelayedY = 0;
	    if (currYPosOffset < 0) { /* limit upward */
	      currYPosOffset = 0;
	    }
	    EraseMainWindow();
	    WinDrawProxyString(hPage, currYPosOffset);
	  }
	} else { /* standard link & image click handler */
d290 1
a290 18
      if (dragScrollFlag == 1) {
	/* starting in drag region, link functions disabled */
	int scrollRedrawOffset = e->screenY - dragScrollPenStartY;
	  if (((scrollRedrawOffset > 0) && moreOffscreen) ||
	      (scrollRedrawOffset < 0))   { /* limit down */
	    currYPosOffset = dragScrollPageStartY +
	      (SCROLL_TEST_FACTOR * (scrollRedrawOffset + dragScrollDelayedY));
	    if (currYPosOffset < 0) { /* limit upward */
	      currYPosOffset = 0;
	    }
	  }
	EraseMainWindow();
	WinDrawProxyString(hPage, currYPosOffset);
	dragScrollFlag = 0;
	dragScrollPenStartY = 0;
	dragScrollPageStartY = 0;
	dragScrollDelayedY = 0;
      } else { /* standard link & image click handler */
d342 1
d372 1
@


1.35
log
@Silly screen draw error
@
text
@d12 7
d197 14
a210 9
      int eventPieceOff = PieceClicked(hPage, e->screenX, e->screenY, 
				       currYPosOffset);
      if (eventPieceOff >= 0) {
	int imgClkResult;
        SWord *hPtr, *eventPiece;

        hPtr = MemHandleLock(hPage);
        ErrFatalDisplayIf(!hPtr, "Cannot lock hPage");
	eventPiece = hPtr + eventPieceOff;
d212 3
a214 1
	imgClkResult = ClickImage(e, eventPiece, currYPosOffset);
d216 1
a216 1
	MemHandleUnlock(hPage);
d218 1
a218 5
	if (imgClkResult == 0) {
	  UpdateHiLiPiece(-1, eventPieceOff, currYPosOffset);
	} else {
	  VoidHand tcurURL;
	  ULong tcurURLLength;
d220 5
a224 3
          hPtr = MemHandleLock(hPage);
          ErrFatalDisplayIf(!hPtr, "Cannot lock hPage");
	  eventPiece = hPtr + eventPieceOff;
d226 36
a261 18
	  if (imgClkResult == 1) { /* if sending the first URL (not the ALT)*/
	    /* create buffer for sending info */
	    tcurURLLength = eventPiece[7];
	    tcurURL = MemHandleNew((ULong) tcurURLLength);
	    if (tcurURL) {
	      outURL = MemHandleLock(tcurURL);
	      /* data out setup */
	      StrCopy (outURL, (char*) &eventPiece[8]);
	      MemHandleUnlock(tcurURL);
	    } else {
	      ErrFatalDisplayIf (tcurURLLength, "Not enough memory!");
	    }
	  } else if (imgClkResult == 2) { /* if sending second URL */
	    /* skip past first URL */
	    int index = 7;
	    tcurURLLength = eventPiece[index++];	    
	    if ((tcurURLLength % 2) == 0) {
	      index += (tcurURLLength >> 1);
d263 3
a265 1
	      index += ((tcurURLLength + 1) >> 1);
a266 16
	    /* create buffer for sending info */
	    tcurURLLength = eventPiece[index++];
	    tcurURL = MemHandleNew((ULong) tcurURLLength);
	    if (tcurURL) {
	      outURL = MemHandleLock(tcurURL);
	      /* data out setup */
	      StrCopy (outURL, (char *) &eventPiece[index]);
	      MemHandleUnlock(tcurURL);
	    } else {
	      ErrFatalDisplayIf (tcurURLLength, "Not enough memory!");
	    }
	  } else {
	    tcurURLLength = 0;
	    tcurURL = 0;
	    ErrFatalDisplayIf (tcurURLLength, "Internal Error");
	  }
d268 1
a268 1
	  MemHandleUnlock(hPage);
d271 19
a289 4
	  sendRes = SendURL(tcurURL, &hPage);
	  if (sendRes == 2) {
	    if (curURL) {
	      MemHandleFree(curURL);
a290 14
	    curURL = tcurURL;
	    curURLLength = tcurURLLength;
	    PutInHistory(curURL, curURLLength);
	    EraseMainWindow();
	    currYPosOffset = 0;
	    if (hPage) {
	      WinDrawProxyString(hPage, currYPosOffset);
	    }
	  } else if (sendRes == 1) {
	    if (transURL) {
	      MemHandleFree(transURL);
	    }
	    transURL = tcurURL;
	    transURLLength = tcurURLLength;
d293 1
a293 1
      }
d300 21
a320 4
	int eventPieceOff = PieceClicked(hPage, e->screenX, e->screenY, 
				  currYPosOffset);
	/* no event piece chk because it must track movement off piece */
	UpdateHiLiPiece(0, eventPieceOff, currYPosOffset);
d327 26
a352 21
      char *outURL;
      int eventPieceOff = PieceClicked(hPage, e->screenX, e->screenY, 
				      currYPosOffset);
      if (eventPieceOff >= 0) {
        SWord *hPtr, *eventPiece;
	Word attributes;

        hPtr = MemHandleLock(hPage);
        ErrFatalDisplayIf(!hPtr, "Cannot lock hPage");
	eventPiece = hPtr + eventPieceOff;

	attributes = eventPiece[6];

	MemHandleUnlock(hPage);

	if (UpdateHiLiPiece(1, eventPieceOff, currYPosOffset) &&
	    (attributes & LINK)) {
	  /* create buffer for sending info */
	  ULong tcurURLLength;
	  VoidHand tcurURL;

d356 3
a358 12

	  tcurURLLength = eventPiece[7];
	  tcurURL = MemHandleNew((ULong) tcurURLLength);
	  if (tcurURL) {
	    outURL = MemHandleLock(tcurURL);
	    /* data out setup */
	    StrCopy (outURL, (char*) &eventPiece[8]);
	    MemHandleUnlock(tcurURL);
	  } else {
	    ErrFatalDisplayIf (tcurURLLength, "Not enough memory!");
	  }

d360 20
a379 6

	  /* set out link request */
	  sendRes = SendURL(tcurURL, &hPage);
	  if (sendRes == 2) {
	    if (curURL) {
	      MemHandleFree(curURL);
d381 29
a409 13
	    curURL = tcurURL;
	    curURLLength = tcurURLLength;
	    PutInHistory(curURL, curURLLength);
	    /* redraw the page */
	    EraseMainWindow();
	    currYPosOffset = 0;
	    if (hPage) {
	      WinDrawProxyString(hPage, currYPosOffset);
	    }
	  } else if (sendRes == 1) {
	    /* don't redraw, just let the status bar work */
	    if (transURL) {
	      MemHandleFree(transURL);
d411 2
a412 6
	    transURL = tcurURL;
	    transURLLength = tcurURLLength;		  
	  } else {
	    if (tcurURL) {
		MemHandleFree(tcurURL);
	    }		
a413 2
	  /* cleanup */	    
	  handled = true;
d415 1
a415 1
      }
@


1.34
log
@Added the aggregator form
@
text
@d370 1
@


1.33
log
@Fixed more nasty memory errors
@
text
@d75 4
@


1.32
log
@o When loading a page with the Open form, the yoffset would incorrectly
  be set to 0 (top) when the request was _sent_.  This caused a ghost
  image to appear, overlaid on the real one.  Fixed.
o If a download was canceled in the middle, and then you "Open" a URL in
  your cache, the partway-done status bar would remain on the screen.  Fixed.
@
text
@d186 1
a186 1
      SWord *eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
d188 12
a199 2
      if (eventPiece) {
	int imgClkResult = ClickImage(e, eventPiece, currYPosOffset);
d201 1
a201 1
	  UpdateHiLiPiece(-1, eventPiece, currYPosOffset);
d206 4
d247 3
d279 1
a279 2
	SWord *eventPiece;
	eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
d282 1
a282 1
	UpdateHiLiPiece(0, eventPiece, currYPosOffset);
d290 15
a304 5
      Word *eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
				      currYPosOffset);;
      if (eventPiece) {
	Word attributes = eventPiece[6];
	if (UpdateHiLiPiece(1, eventPiece, currYPosOffset) &&
d307 9
a315 2
	  ULong tcurURLLength = eventPiece[7];
	  VoidHand tcurURL = MemHandleNew((ULong) tcurURLLength);
d324 3
@


1.31
log
@*** empty log message ***
@
text
@d10 1
d55 1
a55 1
    StatusDraw();
d333 1
a333 1
    StatusDraw();
@


1.30
log
@FIXED UGLY BUG
@
text
@d106 1
a106 1
      {
@


1.29
log
@This time I actually WIL LTEST MY FIXES!
@
text
@d43 5
d71 1
a71 1
      FrmGotoForm(URLForm);
d76 1
a76 1
      break;
@


1.28
log
@o Clicking in status bar no longer follows links drawn under it
o URLForm is now a popup form
@
text
@d66 1
a66 1
      FrmPopupForm(URLForm);
@


1.27
log
@fixed usage of freed handles
@
text
@d66 1
a66 2
      EraseMainWindow();
      FrmGotoForm(URLForm);
d142 1
a145 1
      MemHandleUnlock(tcurURL);
a267 1
      VoidHand tempHand = hPage;
a269 1
      MemHandleLock(tempHand);
a313 1
	  MemHandleUnlock(tempHand);
@


1.26
log
@fixed memory locking problem associated with code cleanup
@
text
@d199 1
d219 1
a247 4
	  }
	  MemHandleUnlock(tcurURL);
	  if (tcurURL) {
	    MemHandleFree(tcurURL);
@


1.25
log
@1. Eliminated flash due to frmgotofrm/winenter events happening right
after each other

2. cleanup mainform.c/eliminated redundant code; fixed some sendURL
bugs

3. minor text string changes

4. fixed event loop -1 time back to 200

Known Bugs:

Canceling in the middle of a load will leave the network layer in an
unstable state. This is a transport layer bug that needs to be fixed.
@
text
@a198 1
	      MemHandleUnlock(tcurURL);
a217 1
	      MemHandleUnlock(tcurURL);
d246 4
a249 4
	  } else {
	    if (tcurURL) {
	      MemHandleFree(tcurURL);
	    }
@


1.24
log
@Following has been added

1. Stop/cancel load functionality (but buggy, transport layer state not reset)

2. Moved PutInHistory to only when a new page is loaded
   (this is a consequence of the cancel function/otherwise URL is
    put in history even if cancel is hit; this lead to history
    errors.)

3. changed event loop to drop every 200 ticks; my pilot batteries go dead
   way to fast

4. can now move back and forward by backspace/space
@
text
@d14 1
a14 1
  int send;
d147 2
a148 2
      send = SendURL(tcurURL, &hPage);
      if (send == 2) {
d155 2
a157 1
	firstOpen = 0;
a158 1
	  EraseMainWindow();
d161 1
a161 1
      } else if (send == 1) {
a167 1
	/* PutInHistory(transURL, transURLLength); */
d179 13
a191 23
    {
      if (hPage) {
 	SWord *eventPiece, attributes;
	char *outURL;
	eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
				  currYPosOffset);
	if (eventPiece) {
	  int result = ClickImage(e, eventPiece, currYPosOffset);
	  if (result == 0) {
	    UpdateHiLiPiece(-1, eventPiece, currYPosOffset);
	  } else if (result == 1) {
	    VoidHand tcurURL;
	    ULong tcurURLLength;
	    attributes = eventPiece[6];
#if 0
	    /* Clear the page so they know something happened */
	    if (hPage)
	      {
		currYPosOffset = 0;
		hPage = NULL;
		EraseMainWindow();
	      }
#endif
d203 3
a205 30
	    /* set out link request */	    
	    send = SendURL(tcurURL, &hPage);
	    if (send == 2) {
	      if (curURL) {
		MemHandleFree(curURL);
	      }
	      curURL = tcurURL;
	      curURLLength = tcurURLLength;
	      PutInHistory(curURL, curURLLength);
	    } else if (send == 1) {
	      if (transURL) {
		MemHandleFree(transURL);
	      }
	      transURL = tcurURL;
	      transURLLength = tcurURLLength;
	      /* PutInHistory(transURL, transURLLength); */
	    } else {
	      if (tcurURL) {
		MemHandleFree(tcurURL);
	      }
	    }	  
	    if (hPage) {
	      WinDrawProxyString(hPage, currYPosOffset);
	    }
	  } else if (result == 2) {
	    VoidHand tcurURL;
	    SWord tcurURLLength;

	    int index = 6;
	    attributes = eventPiece[index++];
a206 12

#if 0

	    /* Clear the page so they know something happened */
	    if (hPage)
	      {
		currYPosOffset = 0;
		hPage = NULL;
		EraseMainWindow();
	      }
#endif

d212 1
a212 1

a214 1

d223 10
a232 21

	    /* set out link request */	  	    
	    send = SendURL(tcurURL, &hPage);
	    if (send == 2) {
	      if (curURL) {
		MemHandleFree(curURL);
	      }
	      curURL = tcurURL;
	      curURLLength = tcurURLLength;
	      PutInHistory(curURL, curURLLength);
	    } else if (send == 1) {
	      if (transURL) {
		MemHandleFree(transURL);
	      }
	      transURL = tcurURL;
	      transURLLength = tcurURLLength;
	      /* PutInHistory(transURL, transURLLength); */
	    } else {
	      if (tcurURL) {
		MemHandleFree(tcurURL);
	      }
d234 5
a238 1
	  
d240 11
a250 1
	      WinDrawProxyString(hPage, currYPosOffset);	      
a251 2
	    currYPosOffset = 0;

d271 40
a310 61
    {
      if (hPage) {
	Word attributes, *eventPiece;
	char *outURL;
	VoidHand tempHand;
	
	if (hPage) {	
	  tempHand = hPage;
	  MemHandleLock(tempHand);
	  eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
				    currYPosOffset);
	  if (eventPiece) {
	    if (UpdateHiLiPiece(1, eventPiece, currYPosOffset)) {
	    /* if it penUp and penDown in same piece */
	      int res;
	      attributes = eventPiece[6];
	      if (attributes & LINK) {
		VoidHand tcurURL;
		ULong tcurURLLength;
		/* create buffer for sending info */
		tcurURLLength = eventPiece[7];
		tcurURL = MemHandleNew((ULong) tcurURLLength);
		if (tcurURL) {
		  outURL = MemHandleLock(tcurURL);
		  /* data out setup */
		  StrCopy (outURL, (char*) &eventPiece[8]);
		  MemHandleUnlock(tcurURL);
		} else {
		  ErrFatalDisplayIf (tcurURLLength, "Not enough memory!");
		}
		/* set out link request */
		res = SendURL(tcurURL, &hPage);
		if (res == 2) {
		  /* redraw the page */
		  if (hPage) {
		    EraseMainWindow();
		    currYPosOffset = 0;
		    WinDrawProxyString(hPage, currYPosOffset);
		  }
		  if (curURL) {
		    MemHandleFree(curURL);
		  }
		  curURL = tcurURL;
		  curURLLength = tcurURLLength;
		  PutInHistory(curURL, curURLLength);
		} else if (res == 1) {
		  /* don't redraw, just let the status bar work */
		  if (transURL) {
		    MemHandleFree(transURL);
		  }
		  transURL = tcurURL;
		  transURLLength = tcurURLLength;		  
		  /* PutInHistory(transURL, transURLLength); */
		} else {
		  if (tcurURL) {
		    MemHandleFree(tcurURL);
		  }		
		}
		/* cleanup */	    
		handled = true;
	      }
d312 6
d319 2
d325 1
a325 1
  break;  
d329 2
a330 3
    if (e->data.winEnter.enterWindow ==
	    FrmGetWindowHandle(FrmGetActiveForm())) {
	StatusDraw();
d335 1
@


1.23
log
@fixed scroll value reset problem
 (scroll was reset to 0 even though user could still operate current
  web page)
eliminated most unnecessary "erase/redraw" locations
 (however, one still exits when your leave a form; this has to do with
  a frmgotofrm and winenter being done at the same time; unsure how to
  resolve)
@
text
@d69 5
d168 1
a168 1
	PutInHistory(transURL, transURLLength);	
d229 1
a229 1
	      PutInHistory(transURL, transURLLength);	      
d290 1
a290 1
	      PutInHistory(transURL, transURLLength);
d373 1
a373 1
		  PutInHistory(transURL, transURLLength);
@


1.22
log
@o Removed some (not all) of the "blinking" when loading pages
o Made 2-bit images reappear after being obscured and unobscured by
  a popup window
@
text
@d66 1
d189 1
d197 1
a197 1

d241 2
d250 1
d349 6
a354 2
		  /* Clear the page so they know something happened */
		  EraseMainWindow();
d362 1
a362 2
		  /* Clear the page so they know something happened */
		  EraseMainWindow();
a373 4
		if (hPage) {
		  WinDrawProxyString(hPage, currYPosOffset);	      
		}
		currYPosOffset = 0;
@


1.21
log
@o UI fixed up: scroll bar at bottom.  It goes all black when the page is
  requested, and disappears when the page has arrived completely.  The
  view area is now 150 pixels high.
o Various bugfixes
@
text
@d45 3
d49 1
a50 1
      EraseMainWindow();
d55 1
a380 3
#if 0
  /* This totally isn't working right...  - Ian */

d383 5
a387 10
    {
       WinPtr w = WinGetWindowPointer(e->data.winEnter.enterWindow);
	/* I can't figure out how to get the handle of the "main" window
	   in advance.  For now, do this: */
	if (w->displayWidth == 160 && w->displayHeight == 160) {
	    WinEraseWindow();
	    StatusDraw();
	    if (hPage) {
	      WinDrawProxyString(hPage, currYPosOffset);	      
	    }
a390 1
#endif
@


1.20
log
@*** empty log message ***
@
text
@d27 1
a27 1
	WinEraseWindow();
d36 1
a36 1
	WinEraseWindow();
d47 1
a47 1
      WinEraseWindow();
d66 1
a66 1
	WinEraseWindow();
d75 1
a75 1
	WinEraseWindow();		  
d148 1
a148 1
	  WinEraseWindow();
d189 1
a189 1
		WinEraseWindow();
d240 1
a240 1
		WinEraseWindow();
d341 1
a341 1
		  WinEraseWindow();
d350 1
a350 1
		  WinEraseWindow();
d376 20
@


1.19
log
@Added ability for browser to send "Pragma: no-cache" is the user hits "Reload"
@
text
@d14 1
d91 19
a109 2
    case RefreshCacheMenu:
      SendURLNoCache(curURL, 1);
d137 2
a138 1
      if (SendURL(tcurURL, &hPage)) {
d151 8
d203 3
a205 2
	    /* set out link request */
	    if (SendURL(tcurURL, &hPage)) {
d212 7
d261 3
a263 2
	    /* set out link request */
	    if (SendURL(tcurURL, &hPage)) {
d270 7
d339 1
a339 1
		if (res) {
d348 9
@


1.18
log
@*** empty log message ***
@
text
@d91 1
a91 1
      SendURLNoCache(curURL);
@


1.17
log
@*** empty log message ***
@
text
@d106 3
@


1.16
log
@lots.  I dont remember
@
text
@d275 1
d292 2
a293 1
		if (SendURL(tcurURL, &hPage)) {
d295 1
a295 5
		  if (hPage) {
		    currYPosOffset = 0;
		    hPage = NULL;
		    WinEraseWindow();
		  }
@


1.15
log
@*** empty log message ***
@
text
@d97 2
a98 1
	AddToCache(url, MemHandleSize(curURL), data, MemHandleSize(hPage), offlineInfoDB, offlineDB);
@


1.14
log
@About menu
@
text
@d124 4
@


1.13
log
@splash screen
pick your proxy host
reload changed to refresh
@
text
@d57 3
d104 25
@


1.12
log
@version numbers added to the protocol
@
text
@a38 1
      break;
d40 1
a79 3
      break;
    case ProxyForm:
      FrmGotoForm(ProxyForm);
@


1.11
log
@various on/off-line fixes
@
text
@a248 7
		/* Clear the page so they know something happened */
		if (hPage)
		  {
		    currYPosOffset = 0;
		    hPage = NULL;
		  WinEraseWindow();
		  }
d262 6
@


1.10
log
@fixed ALT_LINK bad URL problem, now viewing original and following link on an
image work properly when there are both a LINK and an ALT_LINK url.
@
text
@d112 1
a112 1
	SWord *eventPiece, attributes;
@


1.9
log
@OFFLINE MODE WORKS
@
text
@a122 2

	    /* follow link */
d131 1
d161 6
a166 5
	    ULong tcurURLLength;
	    
	    /* goto original */
	    SWord* altURLLength;
	    attributes = eventPiece[6];
d174 5
a178 9
	    /* create buffer for sending info */
	    tcurURLLength = eventPiece[7];
	    if (attributes & LINK) {
	      /* skip past to LINK_ALT entry */
	      if ((tcurURLLength % 2) == 0) {
		altURLLength = &eventPiece[7] + (tcurURLLength >> 1);
	      } else {
		altURLLength = &eventPiece[7] + ((tcurURLLength + 1) >> 1);
	      }
d180 4
a183 4
	    else {
	      altURLLength = &eventPiece[7];
	    }
	    tcurURL = MemHandleNew((ULong) *altURLLength);
d187 1
a187 1
	      StrCopy (outURL, (char*) ((&altURLLength) + 1));
d190 1
a190 1
	      ErrFatalDisplayIf (altURLLength, "Not enough memory!");
d192 1
d199 1
a199 1
	      curURLLength = *altURLLength;
d205 2
a206 1
	    }	  
d211 1
@


1.8
log
@fixes link screen refresh bug.
@
text
@d16 1
a16 1

a50 1

a52 1
    ignoreUp = true;
a56 1
      Chunk c;
d91 1
a91 8
      c.dataSize = curURLLength;
      c.dataHand = curURL;
      c.requestID = 0;
      c.metaSize = 0;
      c.metaHand = NULL;
      c.conID = conID;
      SendChunk(&c);
      currRequestID = c.requestID;
d121 3
d134 4
a137 7
	    curURLLength = eventPiece[7];
	    if (curURL) {
	      MemHandleFree(curURL);
	    }
	    curURL = MemHandleNew((ULong) curURLLength);
	    if (curURL) {
	      outURL = MemHandleLock(curURL);
d140 1
a140 1
	      MemHandleUnlock(curURL);
d142 1
a142 1
	      ErrFatalDisplayIf (curURLLength, "Not enough memory!");
d145 12
a156 2
	    PutInHistory(curURL, curURLLength);
	    hPage = SendURL(curURL, conID);
d158 1
a158 1
	      WinDrawProxyString(hPage, currYPosOffset);	      
a159 1
	    currYPosOffset = 0;
d161 3
d175 1
a175 1
	    curURLLength = eventPiece[7];
d178 2
a179 2
	      if ((curURLLength % 2) == 0) {
		altURLLength = &eventPiece[7] + (curURLLength >> 1);
d181 1
a181 1
		altURLLength = &eventPiece[7] + ((curURLLength + 1) >> 1);
d187 3
a189 6
	    if (curURL) {
	      MemHandleFree(curURL);
	    }
	    curURL = MemHandleNew((ULong) *altURLLength);
	    if (curURL) {
	      outURL = MemHandleLock(curURL);
d192 1
a192 1
	      MemHandleUnlock(curURL);
d194 1
a194 1
	      ErrFatalDisplayIf (curURLLength, "Not enough memory!");
d197 12
a208 2
	    PutInHistory(curURL, curURLLength);
	    hPage = SendURL(curURL, conID);
a237 5
	if (ignoreUp) {
	ignoreUp = false;
	break;
	}
      
d248 2
d258 4
a261 7
		curURLLength = eventPiece[7];
		if (curURL) {
		  MemHandleFree(curURL);
		}
		curURL = MemHandleNew((ULong) curURLLength);
		if (curURL) {
		  outURL = MemHandleLock(curURL);
d264 1
a264 1
		  MemHandleUnlock(curURL);
d266 1
a266 1
		  ErrFatalDisplayIf (curURLLength, "Not enough memory!");
d269 12
a280 2
		PutInHistory(curURL, curURLLength);
		hPage = SendURL(curURL, conID);
d299 1
@


1.7
log
@fixed minor addressing bug in the LINK_ALT feature. Still untested
since there is no server support.
@
text
@d84 3
d225 1
a225 1
	SWord attributes, *eventPiece;
@


1.6
log
@Added view image popup functionality. Supports view original
functionality (though server support is still lacking.)
CVS:----------------------------------------------------------------------
CVS:
@
text
@d171 10
a180 5
	    /* skip past to LINK_ALT entry */
	    if ((curURLLength % 2) == 0) {
	      altURLLength = &eventPiece[7] + (curURLLength >> 1);
	    } else {
	      altURLLength = &eventPiece[7] + ((curURLLength + 1) >> 1);
a181 1
	    curURLLength = *altURLLength;
d185 1
a185 1
	    curURL = MemHandleNew((ULong) curURLLength);
@


1.5
log
@bug fixes and offline cache
@
text
@d119 2
a120 1
	SWord *eventPiece;
d124 74
a197 1
	  UpdateHiLiPiece(-1, eventPiece, currYPosOffset);
@


1.4
log
@Fixed click memory bug. Implemented a possible catch to down server
bug that destorys the pilot.
@
text
@d93 1
d98 1
d104 1
a104 1
	AddToCache(url, MemHandleSize(curURL), data, MemHandleSize(hPage));
d110 1
a110 3
      /*
      FrmPopupForm(CacheForm);
      */
@


1.3
log
@Visual ack of penDown on links now work. Bugs:
Destroys 2 -bit images. Doesn't handle multiple line links very well.
@
text
@d118 7
a124 5
      SWord *eventPiece;
      eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
				currYPosOffset);
      if (eventPiece) {
	UpdateHiLiPiece(-1, eventPiece, currYPosOffset);
d131 7
a137 5
      SWord *eventPiece;
      eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
				currYPosOffset);
      /* no event piece chk because it must track movement off piece */
      UpdateHiLiPiece(0, eventPiece, currYPosOffset);
d143 6
a148 5
      SWord attributes, *eventPiece;
      char *outURL;
      VoidHand tempHand;

      if (ignoreUp) {
d151 1
a151 1
      }
d153 7
a159 7
      if (hPage) {	
	tempHand = hPage;
	MemHandleLock(tempHand);
	eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
				  currYPosOffset);
	if (eventPiece) {
	  if (UpdateHiLiPiece(1, eventPiece, currYPosOffset)) {
d161 7
a167 7
	    attributes = eventPiece[6];
	    if (attributes & LINK) {
	      /* Clear the page so they know something happened */
	      if (hPage)
		{
		  currYPosOffset = 0;
		  hPage = NULL;
d169 5
d175 18
a192 19
	      /* create buffer for sending info */
	      curURLLength = eventPiece[7];
	      if (curURL) {
		MemHandleFree(curURL);
	      }
	      curURL = MemHandleNew((ULong) curURLLength);
	      if (curURL) {
		outURL = MemHandleLock(curURL);
		/* data out setup */
		StrCopy (outURL, (char*) &eventPiece[8]);
		MemHandleUnlock(curURL);
	      } else {
		ErrFatalDisplayIf (curURLLength, "Not enough memory!");
	      }
	      /* set out link request */
	      PutInHistory(curURL, curURLLength);
	      hPage = SendURL(curURL, conID);
	      if (hPage) {
		WinDrawProxyString(hPage, currYPosOffset);	      
a193 3
	    currYPosOffset = 0;
	    /* cleanup */	    
	    handled = true;
d196 1
a197 1
	MemHandleUnlock(tempHand);
@


1.2
log
@*** empty log message ***
@
text
@d116 21
d154 5
a158 3
	  attributes = eventPiece[6];
	  if (attributes & LINK) {
	    /* Clear the page so they know something happened */
d165 20
a184 20
	    /* create buffer for sending info */
	    curURLLength = eventPiece[7];
	    if (curURL) {
	      MemHandleFree(curURL);
	    }
	    curURL = MemHandleNew((ULong) curURLLength);
	    if (curURL) {
	      outURL = MemHandleLock(curURL);
	      /* data out setup */
	      StrCopy (outURL, (char*) &eventPiece[8]);
	      MemHandleUnlock(curURL);
	    } else {
	      ErrFatalDisplayIf (curURLLength, "Not enough memory!");
	    }
	    /* set out link request */
	    PutInHistory(curURL, curURLLength);
	    hPage = SendURL(curURL, conID);
	    if (hPage) {
	      WinDrawProxyString(hPage, currYPosOffset);	      
	    }
d188 1
@


1.1
log
@Code massivly split
@
text
@d159 3
@
