head	1.30;
access;
symbols
	pre:1.1.1.1
	lcd:1.1.1.3;
locks; strict;
comment	@ * @;


1.30
date	97.08.01.23.08.38;	author aspolito;	state dead;
branches;
next	1.29;

1.29
date	97.07.31.21.21.49;	author aspolito;	state Exp;
branches;
next	1.28;

1.28
date	97.07.31.03.47.49;	author aspolito;	state Exp;
branches;
next	1.27;

1.27
date	97.07.29.23.47.00;	author aspolito;	state Exp;
branches;
next	1.26;

1.26
date	97.07.29.23.01.25;	author aspolito;	state Exp;
branches;
next	1.25;

1.25
date	97.07.25.01.55.07;	author aspolito;	state Exp;
branches;
next	1.24;

1.24
date	97.07.18.22.21.09;	author aspolito;	state Exp;
branches;
next	1.23;

1.23
date	97.07.18.21.34.52;	author aspolito;	state Exp;
branches;
next	1.22;

1.22
date	97.07.14.22.58.03;	author aspolito;	state Exp;
branches;
next	1.21;

1.21
date	97.07.14.17.28.19;	author iang;	state Exp;
branches;
next	1.20;

1.20
date	97.07.11.17.45.51;	author iang;	state Exp;
branches;
next	1.19;

1.19
date	97.07.11.00.04.01;	author aspolito;	state Exp;
branches;
next	1.18;

1.18
date	97.07.10.23.11.46;	author aspolito;	state Exp;
branches;
next	1.17;

1.17
date	97.07.08.01.57.36;	author aspolito;	state Exp;
branches;
next	1.16;

1.16
date	97.07.07.21.24.33;	author aspolito;	state Exp;
branches;
next	1.15;

1.15
date	97.06.23.03.03.44;	author iang;	state Exp;
branches;
next	1.14;

1.14
date	97.06.23.02.37.27;	author lcddave;	state Exp;
branches;
next	1.13;

1.13
date	97.06.23.00.54.48;	author iang;	state Exp;
branches;
next	1.12;

1.12
date	97.06.22.22.07.19;	author lcddave;	state Exp;
branches;
next	1.11;

1.11
date	97.06.22.22.03.48;	author iang;	state Exp;
branches;
next	1.10;

1.10
date	97.06.22.22.01.43;	author lcddave;	state Exp;
branches;
next	1.9;

1.9
date	97.06.22.21.40.16;	author lcddave;	state Exp;
branches;
next	1.8;

1.8
date	97.06.22.03.12.12;	author lcddave;	state Exp;
branches;
next	1.7;

1.7
date	97.06.21.02.34.57;	author lcddave;	state Exp;
branches;
next	1.6;

1.6
date	97.06.20.03.19.15;	author lcddave;	state Exp;
branches;
next	1.5;

1.5
date	97.06.19.03.52.48;	author lcddave;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.00.53.29;	author lcddave;	state Exp;
branches;
next	1.3;

1.3
date	97.06.19.00.35.40;	author lcddave;	state Exp;
branches;
next	1.2;

1.2
date	97.06.19.00.25.57;	author lcddave;	state Exp;
branches;
next	1.1;

1.1
date	97.06.17.02.20.01;	author lcddave;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.06.17.02.20.01;	author lcddave;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.06.17.21.49.31;	author lcddave;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.06.18.03.28.13;	author lcddave;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Code massivly split
@
text
@/* UI and Data Processing Code for Top Gun Wing Man
   (a proxy based WWW browser for the USRobotics Pilots)
   See the README file for copyright/licensing terms */

/****************************************************************************
 *
 * * Proxy String Format
 *
 * A proxy string is a string resource which has text information encoded
 * in the proxy string format which is defined as follows:
 *
 *   string - an entire string resource, contains zero or more pieces,
 *            followed by an end token of 0xFFFF (16 bits)
 *   piece  - a subpart of the string resource, contains zero or more frags,
 *            followed by an end token of 0x0000 (16 bits)
 *            each piece is associated with attribute and position data
 *   frag   - a subpart of a piece, composed of a 16-bit length followed by
 *            8-bit chars
 *            (the number of which should be equal to the length, except when
 *             the length is odd in which one blank char is added to maintain
 *             16-bit word-alignment for purposes of addressing)
 *
 * (admittedly, this nomenclature sucks)
 *
 * graphically speaking:
 *
 * string:
 * +--------+--------+
 * | pieces | 0xFFFF |
 * | x byte | 2 byte |
 * +--------+--------+
 *
 * piece:
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * | Back*  | For*   | Xpos   | Ypos   | Xextnt | Yextnt | Attrib | data   |
 * | 2 byte | 2 byte | 2 byte | 2 byte | 2 byte | 2 byte | 2 byte | x byte |
 * +--------+--------+--------+--------+--------+--------+--------+--------+
 * (lines have no data, Xextnt and Yextnt are the x and y lengths of the line)
 *
 * data:
 * (when it is a line of text)
 * +--------+--------+         
 * | frag(s | 0x0000 | 
 * | x byte | 2 byte |  
 * +--------+--------+
 *
 * (or when the 5th bit is on, meaning a bitmap)
 * +--------+
 * | bitmap |
 * | x byte |
 * +--------+
 *
 * (or when it is a link) 
 * +--------+--------+--------+--------+
 * | length | link   | frag(s | 0x0000 |
 * | 2 byte | x byte | x byte | 2 byte |
 * +--------+--------+--------+--------+
 *
 * (link must be a NULL terminated string, the NULL is included in the length)
 *
 *
 * frag:
 * (when it is not a link)
 * +--------+--------+
 * | length | char(s |
 * | 2 byte | x byte |
 * +--------+--------+
 * 
 * (as a general rule, Y position are constructed increasing order)
 *
 * ==> where x is always a multiple of 2 bytes to maintain 16-bit alignment <==
 *
 * attribute masks: (see #defines below for actual values)
 *   BOLD       0x1
 *   ITALIC     0x2
 *   UNDERLINE  0x4
 *   SIZE       0x18
 *   IMAGE      0x20  (IMAGE|BOLD means 2-bit greyscale)
 *   LINK       0x40
 *   LINE       0x80  
 *
 *
 * minimal example:
 * byte#  field
 *  0     BackPtr (SWord), an offset to the previous BackPtr
 *  2     ForPtr  (SWord), an offset to the next ForPtr
 *  4     Xpos    (SWord), starting X coord on drawing surface (see note)
 *  6     Ypos    (SWord), starting Y coord on drawing surface (see note)
 *  8     Attrib  (SWord), text attributes, see below
 * 10     Length  (SWord), length of line string
 * 12-XX  Text, must be word (16-bit) aligned
 *          text of odd length is padded with an blank char
 * XX+1   Piece End Token (0x0000)
 * XX+3   String End Token (0xFFFF)
 *
 * Note: Xpos and Ypos are relative to an page absolute coordinate, which is
 *       independent of the screen on the pilot
 *
 ***************************************************************************/ 

/***************************************************************************
 *
 * Proxy HTML "Page" Resource Layout (currently unused) 
 * 
 * Resources are in a database of type 'PRpg' (Proxy Page)
 *                             creator 'TGwm' (Top Gun Wing Man)
 *
 * 
 * ID Number Allocation
 *
 * String Segment is ID 1999 only
 * Bitmap segment 2000 thru 2999 (currently unimplemented)
 * (more segments to be defined as needed)
 *
 * The browser will do layout by scanning thru each of the segments
 * consecutively. On first lookup miss, it will assume it has finished
 * reading all the segments
 *
 ***************************************************************************/

#pragma pack(2)

#include <Pilot.h>
#include "callback.h"
#include "trans.h"
#include "2bit.h"
#include "wintextRsc.h"

/* defines for fonts */

#define BOLD         0x1
#define ITALIC       0x2
#define UNDERLINE    0x4
#define FONT_MASK    0x18
#define FONT_STD     0x0
#define FONT_BIG1    0x8
#define FONT_BIG2    0xf
#define FONT_BIG3    0x18
#define IMAGE        0x20
#define LINK         0x40
#define LINE         0x80

#define VERSION "0.6a"
#define WELCOME_URL  "splash-" VERSION
#define APPTYPE 'Wtxt'

DmOpenRef cacheDB;
DmOpenRef cacheInfoDB;
DmOpenRef hotlistDB;
DmOpenRef storageDB;
DmOpenRef historyDB;

/* function prototypes */
void displayInit();
void displayClose();
static VoidHand SendURL(VoidHand URL, ConID conID);
static void PutInHistory(VoidHand URL, Word URLLength);
SWord WinDrawProxyString(VoidHand hText, int scrollOffset);
SWord WinEraseProxyString(VoidHand hText, int scrollOffset);
SWord INTWinProxyString(VoidHand hText, int scrollOffset, int mode);
SWord INTWinProxyStringPiece(SWord *startPoint, int scrollOffset, int mode);
SWord* PieceClicked(VoidHand proxyString, SWord xClick, SWord yClick, int scrollOffset);
int INTPieceClicked(SWord *startPoint, SWord xClick, SWord yClick, int scrollOffset);
 
/* global variables */
static ConID conID;           /* connection id for network subsystem */
static VoidHand hPage;        /* handle to the current page */
static WinHandle disp;        /* handle to the display window */
static Word dispError;        /* error for window, needed to create window */
static int moreOffscreen;     /* have we displayed to the end of doc yet? */
static int currYPosOffset;    /* scrolling position for the page */
static int lastLayoutYExtent; /* a trick to maybe get scroll limit working */
SWord winXextent , winYextent;/* x,y of big window */
char *proxyServer;
int proxyPort;

ChunkHand curChunk;
VoidHand curURL;
Word curURLLength;
int curHistory;
Int curTop;
Boolean ignoreUp;

#define REMAP_PREF 1
#define DEF_REMAP_VAL false
Boolean remap;
#define SCROLL_PREF 2
#define DEF_SCROLL_VAL 50
Int scrollSize;
#define HIST_PREF 3
#define DEF_HIST_VAL 15
Int histSize;
#define DEF_CACHE_VAL 102400
#define CACHE_PREF 4
ULong cacheSize;

static VoidHand InCache(char *URL, Word URLSize);

static void SetGlobals() {
  conID = 0;
  hPage = NULL;
  disp = 0;
  dispError = 0;
  moreOffscreen = 0;
  currYPosOffset = 0;
  lastLayoutYExtent = 0;
  winXextent = 0;
  winYextent = 0;
  proxyServer = "128.32.131.63";
  proxyPort =  4444;

  curChunk = NULL;
  curURL = NULL;
  curURLLength = 0;
  curHistory = -1;
  curTop = 0;
  ignoreUp = false;

  remap = DEF_REMAP_VAL;
  scrollSize = DEF_SCROLL_VAL;
  histSize = DEF_HIST_VAL;
  cacheSize = DEF_CACHE_VAL;
}

static void ReadPrefs() {
  SWord size;
  void * prefs;
  Word prefSize = 20;
  
  prefs = MemPtrNew(prefSize);
  

  size = PrefGetAppPreferences(APPTYPE, HIST_PREF, prefs, &prefSize, true);
  if (size != noPreferenceFound) {    
    histSize = *((UInt *) prefs);
  }
  size = PrefGetAppPreferences(APPTYPE, CACHE_PREF, prefs, &prefSize, true);
  if (size != noPreferenceFound) {
    cacheSize = *((UInt *) prefs);
    cacheSize *= 1024;
  }
  size = PrefGetAppPreferences(APPTYPE, SCROLL_PREF, prefs, &prefSize, true);
  if (size != noPreferenceFound) { 
    scrollSize = *((UInt *) prefs);
  }
  size = PrefGetAppPreferences(APPTYPE, REMAP_PREF, prefs, &prefSize, true);
  if (size != noPreferenceFound) {    
    remap = *((Boolean *) prefs);
  }
  MemPtrFree(prefs);
}

static void SetPrefs() {

  ULong t = cacheSize / (ULong) 1024;
  UInt tc = (UInt) t;

  PrefSetAppPreferences(APPTYPE, REMAP_PREF, 1, &remap, sizeof(Boolean), true);
  PrefSetAppPreferences(APPTYPE, HIST_PREF, 1, &histSize, sizeof(UInt), true);
  PrefSetAppPreferences(APPTYPE, CACHE_PREF, 1, &tc, sizeof(UInt), true);
  PrefSetAppPreferences(APPTYPE, SCROLL_PREF, 1, &scrollSize, sizeof(UInt), true);
}

/* returns true if it actually could move in the history */
static Boolean MoveInHistory(int amt) {  
  UInt cardNo;
  LocalID localID;
  ULong numRecs;
  int ch = curHistory;
  VoidHand URL;
  void *url;
  void *cururl;

  ch += amt;
  if (ch < 0) ch = 0;
  if (ch >= histSize) ch = histSize-1;
  
  DmOpenDatabaseInfo(historyDB, &localID, NULL, NULL, &cardNo, NULL);
  DmDatabaseSize(cardNo, localID, &numRecs, NULL, NULL);

  if ((numRecs > ch) && (ch != curHistory)) {

    if (curURL) {
      MemHandleFree(curURL);
    }

    
    URL = DmGetRecord(historyDB, ch);        
    curURLLength = MemHandleSize(URL);
    curURL = MemHandleNew(curURLLength);
    cururl = MemHandleLock (curURL);
    url = MemHandleLock (URL);
    MemMove (cururl, url, curURLLength);
    MemHandleUnlock(URL);
    MemHandleUnlock(curURL);
    hPage = SendURL(curURL, conID);
    DmReleaseRecord(historyDB, ch, false);
    curHistory = ch;
    return true;
  }
  return false;
}

static void PutInHistory(VoidHand URL, Word length) {
  ULong numRecs;
  void * url;
  VoidHand recH;
  void * recP;
  UInt index;
  UInt cardNo;
  LocalID localID;


  /* 
  ** we start out with curHistory at -1 so you can do a back right away
  ** and get the last page oyu visited, but we need to handle what
  ** happens if you don't hit the back button
  */
  if (curHistory < 0) curHistory = 0;
  
  while (curHistory) {
    DmRemoveRecord(historyDB, 0);
    curHistory--;
  }

  index = 0;
  recH = DmNewRecord(historyDB, &index, (ULong) length);
  url = MemHandleLock(URL);  
  recP = MemHandleLock(recH);
  DmWrite(recP, 0, url, length);
  MemHandleUnlock(recH);
  MemHandleUnlock(URL);
  DmReleaseRecord(historyDB, index, true);

  DmOpenDatabaseInfo(historyDB, &localID, NULL, NULL, &cardNo, NULL);
  DmDatabaseSize(cardNo, localID, &numRecs, NULL, NULL);

  while (numRecs > histSize) {
    numRecs--;
    DmRemoveRecord(historyDB, (UInt) numRecs);
  }
}

/* 
** returns a handle to the current url if it is in the cache, and 0 if
** it has to send out to the net for the url.  Yah, it isn't pretty 
*/
static VoidHand SendURL(VoidHand URL, ConID conID) {
  Word URLLength;
  char * url;
  Chunk c;
  VoidHand data;

  URLLength = MemHandleSize(URL);
  url = MemHandleLock(URL);
  data = InCache(url, URLLength);
  MemHandleUnlock(URL);
  if (data) {
    return data;
  }
  c.conID = conID;
  c.metaSize = 0;
  c.metaHand = NULL;
  c.dataSize = URLLength;
  c.dataHand = URL;
  SendChunk(&c);
  return 0;
}

static VoidHand InCache(char *URL, Word URLSize) {  
  ULong numRecs;
  ULong i;
  UInt cardNo;
  LocalID localID;
  ULong ID;  
  VoidHand rec;
  void * recPtr;
  UInt index;

  DmOpenDatabaseInfo(cacheInfoDB, &localID, NULL, NULL, &cardNo, NULL);
  DmDatabaseSize(cardNo, localID, &numRecs, NULL, NULL);
  
  if (numRecs) {    
    for (i = 0; i < numRecs; i++) {
      Boolean match = false;
      rec = DmGetRecord(cacheInfoDB, i);
      recPtr = MemHandleLock(rec);
      if (*((Word *) (recPtr + sizeof(ULong))) == URLSize) {
	match = !(MemCmp(URL, recPtr+sizeof(ULong)+sizeof(Word), 
			 (ULong) URLSize));
      } else { 
	match = false;
      }
      ID = *((ULong*) recPtr);
      MemHandleUnlock(rec);
      DmReleaseRecord(cacheInfoDB, i, false);      
      if (match) {
	DmMoveRecord(cacheInfoDB, (UInt) i, 0);
	DmFindRecordByID(cacheDB, ID, &index);
	rec = DmGetRecord(cacheDB, index);
	DmReleaseRecord(cacheDB, index, false);      
	return rec;
      }
    }
  }
  return 0;
}

/* if url was in the cache, remove it, otherise do nothing */
static void RemoveFromCache(char *URL, Word URLSize) {  
  ULong numRecs;
  ULong i;
  UInt cardNo;
  LocalID localID;
  ULong ID;  
  VoidHand rec;
  void * recPtr;
  UInt index;

  DmOpenDatabaseInfo(cacheInfoDB, &localID, NULL, NULL, &cardNo, NULL);
  DmDatabaseSize(cardNo, localID, &numRecs, NULL, NULL);
  
  if (numRecs) {
    for (i = 0; i < numRecs; i++) {
      Boolean match = false;
      rec = DmGetRecord(cacheInfoDB, i);
      recPtr = MemHandleLock(rec);
      if (*((Word *) (recPtr + sizeof(ULong))) == URLSize) {
	match = !(MemCmp(URL, recPtr+sizeof(ULong)+sizeof(Word), 
			 (ULong) URLSize));
      } else { 
	match = false;
      }
      ID = *((ULong*) recPtr);
      MemHandleUnlock(rec);
      DmReleaseRecord(cacheInfoDB, i, false);      
      if (match) {
	DmRemoveRecord(cacheInfoDB, i);
	DmFindRecordByID(cacheDB, ID, &index);
	DmRemoveRecord(cacheDB, index);
	break;	  
      }
    }
  }
}

static void TrimCache(ULong size) {  
  ULong numRecs;
  ULong i;
  UInt cardNo;
  LocalID localID;
  ULong ID;  
  VoidHand rec;
  void * recPtr;
  ULong curSize;
  UInt index;

  
  DmOpenDatabaseInfo(cacheInfoDB, &localID, NULL, NULL, &cardNo, NULL);
  DmDatabaseSize(cardNo, localID, &numRecs, NULL, NULL);
  
  if (numRecs) {
    for (i = numRecs-1; i >= 0; i--) {
      DmOpenDatabaseInfo(cacheDB, &localID, NULL, NULL, &cardNo, NULL);
      DmDatabaseSize(cardNo, localID, NULL, &curSize, NULL);
      if (curSize <= size) {
	break;
      } 
      rec = DmGetRecord(cacheInfoDB, i);
      recPtr = MemHandleLock(rec);
      ID = *((ULong*) recPtr);
      MemHandleUnlock(rec);
      DmReleaseRecord(cacheInfoDB, i, false);      
      DmRemoveRecord(cacheInfoDB, i);
      DmFindRecordByID(cacheDB, ID, &index);
      DmRemoveRecord(cacheDB, index);
    }
  }
}

static void AddToCache(char * URL, Word URLSize, void * data, UInt dataSize) {
  ULong ID;
  VoidHand rec;
  UInt index;
  void * recPtr;

  RemoveFromCache(URL, URLSize);
  if (dataSize < cacheSize) {
    TrimCache(cacheSize-dataSize);
  } else {
    TrimCache(0);
  }
  index = 0;
  rec = DmNewRecord(cacheDB, &index, dataSize);
  recPtr = MemHandleLock(rec);
  DmWrite(recPtr, 0, data, dataSize);
  MemHandleUnlock(rec);
  DmReleaseRecord(cacheDB, index, true);
  ErrFatalDisplayIf(DmRecordInfo(cacheDB, index, NULL, &ID, NULL), 
		    "Error geting record info");
  index = 0;
  rec = DmNewRecord(cacheInfoDB, &index, URLSize + 
		    sizeof(ULong) + sizeof(Word));
  recPtr = MemHandleLock(rec);
  DmWrite(recPtr, 0, &ID, sizeof(ULong));
  DmWrite(recPtr, sizeof(ULong), &URLSize, sizeof(Word));
  DmWrite(recPtr, sizeof(ULong) + sizeof(Word), URL, URLSize);
  MemHandleUnlock(rec);
  DmReleaseRecord(cacheInfoDB, index, true);  
}


static void AddUrlToHotList(void) {
  VoidHand dataHand;
  VoidPtr dataPtr;
  VoidPtr urlPtr;
  UInt index = 65535;

  if (curURL && curURLLength) {
    dataHand = DmNewRecord(hotlistDB, &index, (ULong) curURLLength);
    ErrFatalDisplayIf(!dataHand, "Out of memory!");
    dataPtr = MemHandleLock(dataHand);
    urlPtr =  MemHandleLock(curURL);
    DmWrite(dataPtr, 0, urlPtr, curURLLength);
    MemHandleUnlock(dataHand);
    MemHandleUnlock(curURL);
    DmReleaseRecord(hotlistDB, index, true);
  }
}

static void HotListDrawRecord(VoidPtr tableP, Word row, Word column, 
			     RectanglePtr bounds) {
  VoidHand recHandle;
  CharPtr recText;
  Int textLen, width;
  Boolean fits;
  UInt recordNum = 0;
  FontID currFont;

  CALLBACK_PROLOGUE

  WinEraseRectangle(bounds, 0); 
  recordNum = (UInt) TblGetItemInt (tableP, row, column);

  currFont = FntSetFont (stdFont);
  
  recHandle = DmGetRecord(hotlistDB, recordNum);
  recText = MemHandleLock(recHandle);
  width = bounds->extent.x - 2;
  textLen = StrLen(recText);
  FntCharsInWidth(recText, &width, &textLen, &fits);
  
  WinDrawChars(recText, textLen, bounds->topLeft.x, bounds->topLeft.y);
  
  MemHandleUnlock(recHandle);    
  
  DmReleaseRecord(hotlistDB, recordNum, false);
  
  FntSetFont (currFont);

  CALLBACK_EPILOGUE
}



static Int HotListLoadTable(FormPtr frm, Int top)  {
  Word row;
  Word lastRecordNum;
  Word numRows;
  VoidHand recordH;
  TablePtr tableP;
  ULong numRecs;
  LocalID lid;
  UInt cardno;
  Int recordNum;
  

  tableP = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, HotListTable));

  numRows = TblGetNumberOfRows (tableP);

  TblUnhighlightSelection(tableP);

  DmOpenDatabaseInfo(hotlistDB, &lid, NULL, NULL, &cardno, NULL);
  DmDatabaseSize(cardno, lid, &numRecs, NULL, NULL);

  if ((top+numRows) > numRecs) {
    top = numRecs - numRows;
  }
  if (top < 0) {
    top = 0;
  }
  /*
  FrmUpdateScrollers(frm, HotListUp, HotListDown, top, top+numRows 
                     < numRecs);
  */

  recordNum = top;

  for (row = 0; row < numRows; row++, recordNum++) {
    recordH = DmQueryRecord (hotlistDB, recordNum);
    
    if (recordH) {
      TblSetItemStyle (tableP, row, 0, customTableItem);      
      TblSetItemInt (tableP, row, 0, (Word) recordNum);
      TblSetRowUsable (tableP, row, true);
      lastRecordNum = recordNum;
    } else {
      TblSetRowUsable (tableP, row, false);
    }
    TblMarkRowInvalid (tableP, row); 
  }
  return top;
}

static void HotListTableLoad(FormPtr frm) {
  TablePtr tableP;

  tableP = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, HotListTable));
  curTop = HotListLoadTable (frm, 0);
  TblSetCustomDrawProcedure (tableP, 0, HotListDrawRecord);
  TblSetColumnUsable (tableP, 0, true);	
}

static Boolean HotListHandleEvent (EventPtr e) {

  FormPtr frm;
  Boolean handled=false;

  CALLBACK_PROLOGUE

  switch (e->eType) {
  case frmOpenEvent:   
    frm = FrmGetActiveForm();  
    HotListTableLoad(frm);
    FrmDrawForm(frm);
    handled = true;
    break;

  case keyDownEvent:
    if (e->data.keyDown.chr == pageUpChr) {	
      if (curTop) {
	curTop = HotListLoadTable (frm, curTop-2);      
	TblDrawTable( FrmGetObjectPtr 
		      (frm, FrmGetObjectIndex (frm, HotListTable)));
      }
      handled = true;
    }
    else if (e->data.keyDown.chr == pageDownChr) {	
      curTop = HotListLoadTable (frm, curTop+2);      
      TblDrawTable( FrmGetObjectPtr 
		    (frm, FrmGetObjectIndex (frm, HotListTable)));
      handled = true;
    }
    break;
  case ctlSelectEvent:
    frm = FrmGetActiveForm();  
    switch(e->data.ctlEnter.controlID) {
      Word row, col;
      TablePtr tblP; 
      VoidHand loc;
      void * src,* dst;

    case HotListGoto:  
      tblP =  FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, HotListTable));
      if (TblGetSelection(tblP, &row, &col)) {
	loc = DmQueryRecord(hotlistDB, TblGetItemInt(tblP, row, col));
	curURLLength = MemHandleSize(loc);	
	if (curURL) {
	  MemHandleFree(curURL);
	}
	curURL = MemHandleNew((ULong) curURLLength);
	dst = MemHandleLock(curURL);
	src = MemHandleLock(loc);
	MemMove(dst, src, curURLLength);
	MemHandleUnlock(loc);
	MemHandleUnlock(curURL);
	PutInHistory(curURL, curURLLength);
	hPage = SendURL(curURL, conID);
	currYPosOffset = 0;
	DmReleaseRecord(hotlistDB, TblGetItemInt(tblP, row, col), false);
      }
    case HotListCancel:
      ignoreUp = true;
      FrmGotoForm(MainForm);
      handled = true;
      break;
    case HotListDelete:
      tblP =  FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, HotListTable));
      if (TblGetSelection(tblP, &row, &col)) {	
	DmRemoveRecord(hotlistDB, TblGetItemInt(tblP, row, col));
	HotListLoadTable(frm, curTop);
	TblUnhighlightSelection(tblP);
	TblDrawTable(tblP);
      }
      handled = true;
      break;
    }
  case ctlEnterEvent:
  case ctlRepeatEvent:
    frm = FrmGetActiveForm();  
    switch(e->data.ctlEnter.controlID) {
    case HotListUp:
      if (curTop) {
	curTop = HotListLoadTable (frm, curTop-2);      
	TblDrawTable( FrmGetObjectPtr 
		      (frm, FrmGetObjectIndex (frm, HotListTable)));
      }
      handled = true;
      break;
    case HotListDown:     
      curTop = HotListLoadTable (frm, curTop+2);      
      TblDrawTable( FrmGetObjectPtr 
		    (frm, FrmGetObjectIndex (frm, HotListTable)));
      handled = true;
      break;
    }
    break;

  default:
    break;
  }

  CALLBACK_EPILOGUE

  return handled;
} 

static Boolean MainFormHandleEvent (EventPtr e)
{
  Boolean handled = false;
  FormPtr frm;

  CALLBACK_PROLOGUE

  switch (e->eType) {
  case keyDownEvent:
    if (e->data.keyDown.chr == pageUpChr) {	
      if (hPage && currYPosOffset) {
	if (currYPosOffset < scrollSize) {
	  currYPosOffset = 0;
	} else {
	  currYPosOffset -= scrollSize;
	}
	WinEraseWindow();
	WinDrawProxyString(hPage, currYPosOffset);
      }
      handled = true;
      break;
    }
    else if (e->data.keyDown.chr == pageDownChr) {
      if (hPage && moreOffscreen) {
	currYPosOffset += scrollSize;
	WinEraseWindow();
	WinDrawProxyString(hPage, currYPosOffset);
      }
      handled = true;
      break;
    }

  case frmOpenEvent:
    frm = FrmGetActiveForm();
    FrmDrawForm(frm);
    if (hPage) {
      WinEraseWindow();
      WinDrawProxyString(hPage, currYPosOffset);
    }
    handled = true;
    break;

  case menuEvent:
    MenuEraseStatus(NULL);
    ignoreUp = true;

    switch(e->data.menu.itemID) {
      char * url;
      void * data;
      Chunk c;
    case GetMenu: 
      FrmGotoForm(URLForm);
      break;
    case BackMenu:
      if (MoveInHistory(1)) { 
	WinEraseWindow();
	currYPosOffset = 0;
	if (hPage) {
	  WinDrawProxyString(hPage, currYPosOffset);
	}
      }
      break;
    case ForwardMenu:
      if (MoveInHistory(-1)) {
	WinEraseWindow();		  
	currYPosOffset = 0;
	if (hPage) {
	  WinDrawProxyString(hPage, currYPosOffset);
	}
      }
      break;
    case PrefsMenu:
      FrmGotoForm(PrefsForm);
      break;
    case HotListMenu:
      FrmGotoForm(HotListForm);
      break;    
    case AddHotListMenu:
      AddUrlToHotList();
      break;
    case RefreshCacheMenu:
      c.dataSize = curURLLength;
      c.dataHand = curURL;
      c.metaSize = 0;
      c.metaHand = NULL;
      c.conID = conID;
      SendChunk(&c);
      break;
    case AddCacheMenu:
      if (hPage && curURL) {
	url = (char *) MemHandleLock(curURL); 
	data = MemHandleLock(hPage); 
	AddToCache(url, MemHandleSize(curURL), data, MemHandleSize(hPage));
	MemHandleUnlock(hPage);
	MemHandleUnlock(curURL);
      }
      break;
    case EditCacheMenu:
      /*
      FrmPopupForm(CacheForm);
      */
      break;
    }
    handled = true;
    break;

  case penUpEvent:
    {
      SWord attributes, *eventPiece;
      char *outURL;
      VoidHand tempHand;

      if (ignoreUp) {
	ignoreUp = false;
	break;
      }
      
      if (hPage) {	
	tempHand = hPage;
	MemHandleLock(tempHand);
	eventPiece = PieceClicked(hPage, e->screenX, e->screenY, 
				  currYPosOffset);
	if (eventPiece) {
	  attributes = eventPiece[6];
	  if (attributes & LINK) {
	    /* Clear the page so they know something happened */
	      if (hPage)
		{
		  currYPosOffset = 0;
		  hPage = NULL;
		  WinEraseWindow();
		}
	    /* create buffer for sending info */
	    curURLLength = eventPiece[7];
	    if (curURL) {
	      MemHandleFree(curURL);
	    }
	    curURL = MemHandleNew((ULong) curURLLength);
	    if (curURL) {
	      outURL = MemHandleLock(curURL);
	      /* data out setup */
	      StrCopy (outURL, (char*) &eventPiece[8]);
	      MemHandleUnlock(curURL);
	    } else {
	      ErrFatalDisplayIf (curURLLength, "Not enough memory!");
	    }
	    /* set out link request */
	    PutInHistory(curURL, curURLLength);
	    hPage = SendURL(curURL, conID);
	    currYPosOffset = 0;
	    /* cleanup */	    
	    handled = true;
	  }
	}
	MemHandleUnlock(tempHand);
      }
    }
  break;  

  default:
    break;
  }

  CALLBACK_EPILOGUE

  return handled;
}

static void SetFld(FieldPtr fld, void * val, ULong len) {

  VoidHand txthand = MemHandleNew(len+1);
  if (txthand) {
    CharPtr txtptr = MemHandleLock(txthand);
    if (txtptr) {
      txtptr[0] = '\0';
      if (val) MemMove(txtptr, val, len);
      txtptr[len] = '\0';
    }
    MemHandleUnlock(txthand);
    FldFreeMemory(fld);
    FldSetTextHandle(fld, (Handle)txthand);    
  }
}

static Boolean PrefsFormHandleEvent (EventPtr e) {
  Boolean handled = false;
  FormPtr frm;
  FieldPtr fld;
  Char buf[10];
  ControlPtr ctl;

  switch (e->eType) {
  case frmOpenEvent:    
    frm = FrmGetActiveForm();
    fld = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsHistFld));    
    StrIToA(buf, histSize);
    SetFld(fld, buf, 4);
    fld = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsCacheFld));
    StrIToA(buf, (cacheSize/1024));
    SetFld(fld, buf, 4);
    fld = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsScrollFld));    
    StrIToA(buf, scrollSize);
    SetFld(fld, buf, 4);
    ctl = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsRemapBox));    
    CtlSetValue(ctl, remap);
    FrmDrawForm(frm);
    handled = true;
    break;
  
  case ctlSelectEvent:
    switch(e->data.ctlEnter.controlID) {
    case PrefsSave:
      frm = FrmGetActiveForm();
      ctl = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsRemapBox));    
      remap = false;
       if (CtlGetValue(ctl)) remap = true;
       fld = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsScrollFld));
      scrollSize = StrAToI(FldGetTextPtr(fld));
      if (scrollSize > 160) {
	scrollSize = 160;
      }
      if (scrollSize < 1) {
	scrollSize = 1;
      }
      fld = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsHistFld));
      histSize = StrAToI(FldGetTextPtr(fld));
      if (histSize > 100) {
	histSize = 100;
      }
      if (histSize < 1) {
	histSize = 1;
      }
      fld = FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, PrefsCacheFld));
      cacheSize = 1024 *  StrAToI(FldGetTextPtr(fld));
      SetPrefs();
    case PrefsCancel:
      ignoreUp = true;
      FrmGotoForm(MainForm); 
      handled = true;
    break;
    }

  default:
    break;
  }
  return handled;
}


static Boolean ProxyFormHandleEvent (EventPtr e)
{
  Boolean handled = false;
  FormPtr frm;
  FieldPtr addrFld, portFld;
  Char portNum[5];
  CharPtr ascPort = (CharPtr) &portNum;

  switch (e->eType) {
  case frmOpenEvent:
    addrFld = FrmGetObjectPtr(FrmGetFormPtr(ProxyForm),
			      FrmGetObjectIndex(FrmGetFormPtr(ProxyForm),
						ProxyFormAddrFld));
    portFld = FrmGetObjectPtr(FrmGetFormPtr(ProxyForm),
			      FrmGetObjectIndex(FrmGetFormPtr(ProxyForm),
						ProxyFormPortFld));
    FldSetTextPtr(addrFld, proxyServer);
    FldSetTextPtr(portFld, StrIToA(ascPort, proxyPort));
    frm = FrmGetActiveForm();
    FrmDrawForm(frm);
    handled = true;
    break;

  case ctlSelectEvent:
    switch(e->data.ctlEnter.controlID) {
    case ProxyFormOK:
      break;
    case ProxyFormCan:
      break;
    }
    ignoreUp = true;
    FrmGotoForm(MainForm); 
    handled = true;
    break;

  default:
    break;
  }
  return handled;
}

static Boolean URLFormHandleEvent (EventPtr e)
{
  Boolean handled = false;
  FormPtr frm;
  char * urlOutSet;
  char * url = NULL;
  FieldPtr URLField;

  CALLBACK_PROLOGUE

  switch (e->eType) {
  case frmOpenEvent:
    frm = FrmGetActiveForm();
    FrmDrawForm(frm);
    FrmSetFocus(frm, FrmGetObjectIndex(frm, URLFormFld));
    handled = true;
    break;

  case ctlSelectEvent:
    switch(e->data.ctlEnter.controlID) {
    case URLFormOK:

      frm = FrmGetActiveForm();
      URLField = FrmGetObjectPtr(frm, FrmGetObjectIndex(frm, URLFormFld));
      /* get the text and the length */
      if(FldGetTextPtr(URLField)) {
	url = FldGetTextPtr(URLField);
	curURLLength = FldGetTextLength(URLField) + 1;
	/* create the handle and the copy point */
	if (curURL) {
	  MemHandleFree(curURL);
	}
	curURL = MemHandleNew((ULong) curURLLength);
	if (curURL) {
	  urlOutSet = MemHandleLock(curURL);
	  /* copy it */
	  StrCopy (urlOutSet, url);
	} else {
	  /* if we needed space and didn't get it we have a problem */
	  ErrFatalDisplayIf(curURLLength, "Out of memory!");
	}
	MemHandleUnlock(curURL);
	PutInHistory(curURL, curURLLength);
	hPage = SendURL(curURL, conID);
	  
	currYPosOffset = 0;
      }
    case URLFormCan:
    }
    ignoreUp = true;
    FrmGotoForm(MainForm); 
    handled = true;
    break;
  default:
    break;
  }

  CALLBACK_EPILOGUE

  return handled;
}

static Boolean ApplicationHandleEvent(EventPtr e)
{
  FormPtr frm;
  Word    formId;
  Boolean handled = false;
  
  switch (e->eType) {

  case frmLoadEvent:
    formId = e->data.frmLoad.formID;
    frm = FrmInitForm(formId);
    FrmSetActiveForm(frm);    

    switch(formId) {
    case MainForm:
      FrmSetEventHandler(frm, MainFormHandleEvent);
      break;
    case PrefsForm:
      FrmSetEventHandler(frm, PrefsFormHandleEvent);
      break;
    case URLForm:
      FrmSetEventHandler(frm, URLFormHandleEvent);
      break;
    case ProxyForm:
      FrmSetEventHandler(frm, ProxyFormHandleEvent);
      break;
    case HotListForm:
      FrmSetEventHandler(frm, HotListHandleEvent);
      break;
    }
    handled = true;
    break;
  
  case transNewChunk: 
    {      
      ChunkPtr c;      
      transEventPtr te = (transEventPtr) e;
      
      frm = FrmGetActiveForm();
      if (hPage) {
	currYPosOffset = 0;
	hPage = NULL;
      }
      if (curChunk) {
	Err err;
	err = DestroyChunk(curChunk);
      }
      
      curChunk = te->data.newChunk.chunkHand;
      
      c = (ChunkPtr) MemHandleLock(curChunk);
      hPage = c->dataHand;
      MemHandleUnlock(curChunk);
      if (hPage && curURL) {
	AddToCache((char *) MemHandleLock(curURL), curURLLength, 
		   (char *) MemHandleLock(hPage), c->dataSize);
	MemHandleUnlock(curURL);
	MemHandleUnlock(hPage);
      }
      if (hPage && (frm->formId == MainForm)) {
	WinEraseWindow();
	WinDrawProxyString(hPage, currYPosOffset); 
      }
      handled = true;
      break;
    }
  default:
    break;
  }
  return handled;
}

/* Get preferences, open (or create) app database */
static Word StartApplication(void)
{
  Word err;
  UInt welcomeURLLength = StrLen(WELCOME_URL) + 1;
  VoidHand hWelcomeURL = MemHandleNew((ULong) welcomeURLLength);
  char *outWelcomeURL = MemHandleLock(hWelcomeURL);
  Chunk urlOut;
  
  SetGlobals();

  historyDB = DmOpenDatabaseByTypeCreator('Hist', APPTYPE, dmModeReadWrite);  
  if (historyDB == NULL) {
    err = DmCreateDatabase(0, "WingmanHistory", APPTYPE, 'Hist', 0);
    ErrFatalDisplayIf(err, "Error creating history database");
    historyDB = DmOpenDatabaseByTypeCreator('Hist', APPTYPE, dmModeReadWrite);
    ErrFatalDisplayIf(!historyDB, "Error opening history database");
  }

  cacheDB = DmOpenDatabaseByTypeCreator('Cash', APPTYPE, dmModeReadWrite);  
  if (cacheDB == NULL) {
    err = DmCreateDatabase(0, "WingmanCache", APPTYPE, 'Cash', 0);
    ErrFatalDisplayIf(err, "Error creating cache database");
    cacheDB = DmOpenDatabaseByTypeCreator('Cash', APPTYPE, dmModeReadWrite);
    ErrFatalDisplayIf(!cacheDB, "Error opening cache database");
  }

  cacheInfoDB = DmOpenDatabaseByTypeCreator('cInf', APPTYPE, dmModeReadWrite);
  if (cacheInfoDB == NULL) {
    err = DmCreateDatabase(0, "WingmanCacheInfo", APPTYPE, 'cInf', 0);
    ErrFatalDisplayIf(err, "Error creating cache info database");
    cacheInfoDB = DmOpenDatabaseByTypeCreator('cInf', 
					      APPTYPE, dmModeReadWrite);
    ErrFatalDisplayIf(!cacheInfoDB, "Error opening cache info database");
  }

  hotlistDB = DmOpenDatabaseByTypeCreator('Hotl', APPTYPE, dmModeReadWrite);  
  if (hotlistDB == NULL) {
    err = DmCreateDatabase(0, "WingmanHotList", APPTYPE, 'Hotl', 0);
    ErrFatalDisplayIf(err, "Error creating hot list database");
    hotlistDB = DmOpenDatabaseByTypeCreator('Hotl', APPTYPE, dmModeReadWrite);
    ErrFatalDisplayIf(!hotlistDB, "Error opening hot list database");
  }
  
  storageDB = DmOpenDatabaseByTypeCreator('STOR', APPTYPE, dmModeReadWrite);  
  if (storageDB == NULL) {
    err = DmCreateDatabase(0, "WingmanTransStorage", APPTYPE, 'STOR', 0);
    ErrFatalDisplayIf(err, "Error creating storage database");
    storageDB = DmOpenDatabaseByTypeCreator('STOR', APPTYPE, dmModeReadWrite);
    ErrFatalDisplayIf(!storageDB, "Error opening storage database");
  } else {
    /* storage database exists!  clean it out */
    ULong numRecs;
    LocalID lid;
    UInt cardno;
    ULong i;

    DmOpenDatabaseInfo(storageDB, &lid, NULL, NULL, &cardno, NULL);
    DmDatabaseSize(cardno, lid, &numRecs, NULL, NULL);
    
    for (i = 0; i < numRecs; i++) {
      DmRemoveRecord(storageDB, 0);
    }
  }

  ReadPrefs();

  /* start display */
  displayInit();

  /* start network */
  err = StartTrans();
  if (err) {
    ErrFatalDisplayIf(err, "Error opening transport layer");
  }
  
  conID = OpenConnection(proxyServer, proxyPort, storageDB);

  /* set the chunk data structures */
  StrCopy (outWelcomeURL, WELCOME_URL);
  urlOut.conID = conID;
  urlOut.metaSize = 0;
  urlOut.dataSize = (DataSize) welcomeURLLength;
  urlOut.dataHand = hWelcomeURL;
  /* open welcome page */
  SendChunk(&urlOut);
  /* cleanup */
  MemHandleUnlock(hWelcomeURL);
  MemHandleFree(hWelcomeURL);	
  FrmGotoForm(MainForm);

  return 0;
}

/* Save preferences, close forms, close app database */
static void StopApplication(void)
{
  Err err;

  DmCloseDatabase(historyDB);
  DmCloseDatabase(cacheDB);
  DmCloseDatabase(cacheInfoDB);
  DmCloseDatabase(hotlistDB);
  DmCloseDatabase(storageDB);
  
  CloseConnection(conID);
  if (curChunk) {
    DestroyChunk(curChunk);
  }
  err = StopTrans();
  ErrNonFatalDisplayIf(err, "Error closing transport layer");
  displayClose();
  FrmSaveAllForms();
  FrmCloseAllForms();
}

static Boolean TopLevelHandleEvent(EventPtr e) {
  FormPtr frm;
  frm = FrmGetActiveForm();
  if (frm->formId == MainForm) {
    Boolean handled = false;
    if (e->eType == keyDownEvent) {
      switch (e->data.keyDown.chr) {
      case hard2Chr: 
	handled = true;
	if (MoveInHistory(1)) { 
	  WinEraseWindow();
	  currYPosOffset = 0;
	  if (hPage) {
	    WinDrawProxyString(hPage, currYPosOffset);
	  }
	}
	break;
      case hard3Chr:
	if (MoveInHistory(-1)) {
	  WinEraseWindow();		  
	  currYPosOffset = 0;
	  if (hPage) {
	    WinDrawProxyString(hPage, currYPosOffset);
	  }
	}
	handled = true;
	break;	
      }      
    }
    return handled;
  }
  return false;
}

/* The main event loop */
static void EventLoop(void)
{
  Word err;
  EventType e;
  do {
    CheckNetwork(conID);
    EvtGetEvent(&e, 100);
    if (!remap || (!TopLevelHandleEvent(&e)))
      if (! SysHandleEvent (&e))
	if (! MenuHandleEvent (NULL, &e, &err))
	  if (! ApplicationHandleEvent (&e))
	    FrmDispatchEvent (&e);
  } while (e.eType != appStopEvent);
}

/* Main entry point; it is unlikely you will need to change this except to
   handle other launch command codes */
DWord PilotMain(Word cmd, Ptr cmdPBP, Word launchFlags)
{
  Word err;
  if (cmd == sysAppLaunchCmdNormalLaunch) {
#ifdef DEBUG
    StartDebug();
#endif

    err = StartApplication();
    if (err) return err;

    EventLoop();
    StopApplication();

  } else {
    return sysErrParamErr;
  }

  return 0;
}

/* Set up the display */
void displayInit()
{
    RectangleType dispBounds;

    /* Set up the 1-bit window */
    dispBounds.topLeft.x = 0; 
    dispBounds.topLeft.y = 0;
    dispBounds.extent.x = 160;
    dispBounds.extent.y = 160;
    disp = WinCreateWindow(&dispBounds, noFrame, 0, 1, &dispError);
    WinInitializeWindow(disp);
    WinSetDrawWindow(disp);
    WinGetWindowExtent(&winXextent, &winYextent);

    /* Go 2-bit */
#ifdef TWOBIT
    enable_2bit();
#endif
}  

void displayClose()
{
  if (hPage)
    {
      currYPosOffset = 0;
      hPage = NULL;
    }
#ifdef TWOBIT
  disable_2bit();
#endif
  if (disp) {
    WinDeleteWindow(disp, true);
    disp = NULL;
  }
}

/****************************************************************************
 *
 * Text Drawing / Erasing Functions
 *
 ****************************************************************************/

SWord WinDrawProxyString(VoidHand hText, int scrollOffset)
{
  return INTWinProxyString(hText, scrollOffset, 0);
}

SWord WinEraseProxyString(VoidHand hText, int scrollOffset)
{
  /* this function is probably unnecessary since WinEraseWindow does a
   * more complete job, but it here in case you wanted to do anything cool
   */
  return INTWinProxyString(hText, scrollOffset, 1);
}

/****************************************************************************
 *
 * Internal functions for Win???ProxyString
 *
 * as a rule, you shouldn't call them
 * 
 ****************************************************************************/

SWord INTWinProxyString(VoidHand hText, int scrollOffset, int mode)
{
  SWord *proxyString = MemHandleLock(hText);
  /* int byteSize = MemPtrSize(proxyString); fault tolerance test */
  int nextParseOffset = 0, retVal;

  while (1) {
    retVal = INTWinProxyStringPiece(&proxyString[nextParseOffset],
				    scrollOffset, mode);
    nextParseOffset += retVal;
    /* do not change the evaluation order of the following if else stmt */
    if (retVal == -1) { 
      moreOffscreen = 1;
      break; 
    }
    else if (proxyString[nextParseOffset] == 0xFFFF) {
      if (lastLayoutYExtent > winYextent) {
	moreOffscreen = 1; /* removed for now */
      } else {
	moreOffscreen = 0;
      }
      break; 
    }

  }
  MemHandleUnlock(hText);
  return 0;
}

SWord INTWinProxyStringPiece(SWord *startPoint, int scrollOffset,
			     int mode)
{
  /* function also deals with frags internally */
  int currParseLoc = 0;
  int currFragLen = 0; /* used to determine num of chars left in current frag */
  int internalOffset = 0;
  int retVal;
  SWord forwardOffset = 0, backOffset = 0;
  SWord startXPos = 0, startYPos = 0;
  SWord Xextent = 0, Yextent = 0;
  SWord attributes = 0;
  /* internal preprocessing of window attributes */

  /* read metadata and then move it to the next read pos */
  backOffset = startPoint[0];
  forwardOffset = startPoint[1];
  startXPos = startPoint[2];
  startYPos = startPoint[3];
  Xextent = startPoint[4];
  Yextent = startPoint[5];
  attributes = startPoint[6];
  currParseLoc = 7;
  
  if (attributes == LINE) {
    WinDrawLine(startXPos, startYPos - scrollOffset + internalOffset, 
		startXPos + Xextent, 
		startYPos - scrollOffset + internalOffset + Yextent);
  }
  if (attributes & LINK) {
    currFragLen = startPoint[currParseLoc++];
    /* use like this to get a link:
       char aLink = (char*) &startPoint[currParseLoc]; */    
    /* increment past the link */
    if ((currFragLen % 2) == 0) {
      currParseLoc += (currFragLen >> 1) /* to the next read pos */;
    } else {
      currParseLoc += ((currFragLen + 1) >> 1) /* to the next read pos */;
    }
    WinSetUnderlineMode(grayUnderline);
  }
  
  if (attributes & IMAGE) {
    BitmapPtr image;
    image = (BitmapPtr) &startPoint[currParseLoc];
    if (attributes & BOLD) {
#ifdef TWOBIT
      WinDraw2Bitmap(image, startXPos, startYPos + -scrollOffset);
#else
      WinDrawBitmap(image, startXPos, startYPos + -scrollOffset);
#endif
    } else {
      WinDrawBitmap(image, startXPos, startYPos + -scrollOffset);
    }
  } else {
    /* processing of display attributes except underline*/
    if (attributes & BOLD) {
      FntSetFont(boldFont);
    }
    if (attributes & ITALIC) {
      /* Currently unsupported */
    }
    if (attributes & FONT_MASK) {
      if ((attributes & FONT_MASK) == FONT_STD) {
	FntSetFont(stdFont);
      } else if ((attributes & FONT_MASK) == FONT_BIG1) {
	FntSetFont(largeFont);
      } else if ((attributes & FONT_MASK) == FONT_BIG2) {
	/* Currently unsupported */
      } else if ((attributes & FONT_MASK) == FONT_BIG3) {
	/* currently unsupported */
      }
    }
    /* this attribute is independent of the others on the pilot */
    if ((attributes & UNDERLINE) && !(attributes & LINK)) {
      WinSetUnderlineMode(solidUnderline);
    }
    
    while(1) {
      /* this part would by INTWinProxyStringFrag, but it's rolled in */
      currFragLen = startPoint[currParseLoc++];
      
      /* is there any more to draw and is there still room on screen? */
      if (currFragLen == 0 ||
	  (startYPos + -scrollOffset) > winYextent) {
	break;
      }
      else {
	/* yes, so its a proxy string frag */      
	/* if attempts to draw optimized +100 is so that alignment works off 100 */
	if (startYPos + -scrollOffset + internalOffset + 100> 0) {
	  if (mode) {
	    /* erase mode */
	    WinEraseChars((char*) &startPoint[currParseLoc], (Word) currFragLen, 
			  startXPos, startYPos + -scrollOffset + internalOffset);
	  } else {
	    /* draw mode */
	    WinDrawChars((char*) &startPoint[currParseLoc], (Word) currFragLen, 
			 startXPos, startYPos + -scrollOffset + internalOffset);
	  }
	}
	/* how much do we increment the pointer */
	if ((currFragLen % 2) == 0) {
	  currParseLoc += (currFragLen >> 1) /* to the next read pos */;
	} else {
	  currParseLoc += ((currFragLen + 1) >> 1) /* to the next read pos */;
	}
	
	/* start next line */
	internalOffset += FntLineHeight();
      }
    }
    /* clean up */
    FntSetFont(stdFont);
    WinSetUnderlineMode(noUnderline);
  }
  lastLayoutYExtent = startYPos - scrollOffset + Yextent;
  /* are we at the bottom of the screen? */
  if (startYPos + -scrollOffset > winYextent ) {
    retVal = -1; /* yes, so stop drawing */    
  } else {
    retVal = (forwardOffset / 2); /* no, so give me the next piece */
  }
  return retVal;
}

/* PieceClicked returns a pointer to the piece than recieved a click event 
 * search in linear from top, thus region conflicts are resolved by what's first
 * returns NULL if there is no region */

SWord* PieceClicked(VoidHand hText, SWord xClick, SWord yClick, int scrollOffset)
{
  SWord *proxyString = MemHandleLock(hText);
  int nextParseOffset = 0, iterResult;
  SWord* retVal;

  while (1) {
    /* scan the piece */
    iterResult = INTPieceClicked(&proxyString[nextParseOffset],
				 xClick, yClick, scrollOffset);
    if (iterResult == -1) {
      /* if we've found the piece */
      retVal = &proxyString[nextParseOffset];
      break;
    }
    else {
      /* look at the next piece */
      nextParseOffset += iterResult;
    }

    if (iterResult == -2 ||
	proxyString[nextParseOffset] == 0xFFFF) {
      /* but first make sure there is another piece */
      retVal = NULL;
      break; 
    }

  }
  MemHandleUnlock(hText);
  return retVal;
}

int INTPieceClicked(SWord *startPoint, SWord xClick, SWord yClick, int scrollOffset)
{
  /* note to self, since forward pointers between 0 and -6 should be meaningless,
     they are using in the return value as result codes; these ARE NOT offsets */

  /* read metadata and then move it to the next read pos */
  /* SWord backOffset = startPoint[0]; */
  SWord forwardOffset = startPoint[1];
  SWord startXPos = startPoint[2];
  SWord startYPos = startPoint[3];
  SWord Xextent = startPoint[4];
  SWord Yextent = startPoint[5];
  int retVal;

  if (xClick > startXPos &&
      xClick < (startXPos + Xextent) &&
      yClick > (startYPos - scrollOffset) &&
      yClick < (startYPos - scrollOffset + Yextent)) {
    /* it's in this region */
    retVal = -1;
  } else if ((startYPos - scrollOffset > winYextent) ||
	     (startYPos - scrollOffset > yClick)) {
    /* about if we're off screen or already past the click */
    retVal = -2;
  } else {
    /* it's not, look in the next one */
    retVal = (forwardOffset / 2);
  }
  return retVal;
}


@


1.29
log
@*** empty log message ***
@
text
@@


1.28
log
@prefs added
@
text
@d166 17
a182 17
static ConID conID = 0;           /* connection id for network subsystem */
static VoidHand hPage = NULL;     /* handle to the current page */
static WinHandle disp = 0;        /* handle to the display window */
static Word dispError = 0;        /* error for window, needed to create window */
static int moreOffscreen = 0;     /* have we displayed to the end of doc yet? */
static int currYPosOffset = 0;    /* scrolling position for the page */
static int lastLayoutYExtent = 0; /* a trick to maybe get scroll limit working */
SWord winXextent = 0, winYextent = 0; /* x,y of big window */
char *proxyServer = "128.32.131.63";
int proxyPort =  4444;

ChunkHand curChunk = NULL;
VoidHand curURL = NULL;
Word curURLLength = 0;
int curHistory = -1;
Int curTop = 0;
Boolean ignoreUp = false;
d185 2
a186 1
Boolean remap = false;
d188 2
a189 1
Int scrollSize = 50;
d191 3
a193 1
Int histSize = 15;
d195 1
a195 1
ULong cacheSize = 102400;
d199 24
a222 26
#ifdef DEBUG
extern long data_start, bss_start;
static void StartDebug(void)
{
  extern void start ();
  DWord romVersion;
  FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
  if (romVersion >= 0x02000000) {
    (*(char*)257) = 1; /* Turn on debugging */
  }
  
  asm("
       lea data_start(%%a4),%%a1
       move.l %%a1,%%d2
       lea bss_start(%%a4),%%a1
       move.l %%a1,%%d1
       lea start(%%pc),%%a0
       move.l %%a0,%%d0
       sub.l #start, %%d0
       move.l #0x12BEEF34, %%d3
       trap #8
       move.l #0, %%d3
       move.l #0, %%d0
       move.l #0, %%d1
       move.l #0, %%d2
       " : : : "d0", "d1", "d2", "d3", "a1", "a0");
a223 1
#endif
d1162 2
@


1.27
log
@*** empty log message ***
@
text
@a142 2
#define SCROLL_GRAN  80

a146 3
#define CACHE_SIZE 102400
#define MAX_HISTORY_SIZE 15

d184 9
d224 39
d275 1
a275 1
  if (ch >= MAX_HISTORY_SIZE) ch = MAX_HISTORY_SIZE-1;
d337 1
a337 1
  while (numRecs > MAX_HISTORY_SIZE) {
d487 2
a488 2
  if (dataSize < CACHE_SIZE) {
    TrimCache(CACHE_SIZE-dataSize);
d739 1
a739 1
	if (currYPosOffset < SCROLL_GRAN) {
d742 1
a742 1
	  currYPosOffset -= SCROLL_GRAN;
d752 1
a752 1
	currYPosOffset += SCROLL_GRAN;
d800 1
a800 1
      FrmGotoForm(ProxyForm);
d896 81
d1097 3
d1215 1
d1308 1
a1308 1
    if (! TopLevelHandleEvent(&e))
@


1.26
log
@Back and forwards works
@
text
@d639 1
d1034 1
a1034 1
  historyDB = DmOpenDatabaseByTypeCreator('hIst', APPTYPE, dmModeReadWrite);  
d1036 1
a1036 1
    err = DmCreateDatabase(0, "WingmanHistory", APPTYPE, 'hIst', 0);
d1038 1
a1038 1
    historyDB = DmOpenDatabaseByTypeCreator('hIst', APPTYPE, dmModeReadWrite);
d1042 1
a1042 1
  cacheDB = DmOpenDatabaseByTypeCreator('cash', APPTYPE, dmModeReadWrite);  
d1044 1
a1044 1
    err = DmCreateDatabase(0, "WingmanCache", APPTYPE, 'cash', 0);
d1046 1
a1046 1
    cacheDB = DmOpenDatabaseByTypeCreator('cash', APPTYPE, dmModeReadWrite);
d1059 1
a1059 1
  hotlistDB = DmOpenDatabaseByTypeCreator('hotl', APPTYPE, dmModeReadWrite);  
d1061 1
a1061 1
    err = DmCreateDatabase(0, "WingmanHotList", APPTYPE, 'hotl', 0);
d1063 1
a1063 1
    hotlistDB = DmOpenDatabaseByTypeCreator('hotl', APPTYPE, dmModeReadWrite);
d1067 1
a1067 1
  storageDB = DmOpenDatabaseByTypeCreator('stor', APPTYPE, dmModeReadWrite);  
d1069 1
a1069 1
    err = DmCreateDatabase(0, "WingmanTransStorage", APPTYPE, 'stor', 0);
d1071 1
a1071 1
    storageDB = DmOpenDatabaseByTypeCreator('stor', APPTYPE, dmModeReadWrite);
@


1.25
log
@Caching works
@
text
@d109 1
a109 1
s * ID Number Allocation
d143 1
a143 1
#define SCROLL_GRAN  50
d150 1
d156 1
a156 1

d161 2
d185 1
d220 80
d310 1
a310 1
  URLLength = MemHandleSize(URL);  
d403 1
a403 1
static void TrimCache(Word size) {  
d414 1
a605 1
    case HotListDown:     
d634 1
d738 7
d747 7
d831 1
d934 2
a935 1

a938 1
	MemHandleUnlock(curURL);
d1033 8
d1043 1
a1043 1
    err = DmCreateDatabase(0, "Cache", APPTYPE, 'cash', 0);
d1051 1
a1051 1
    err = DmCreateDatabase(0, "CacheInfo", APPTYPE, 'cInf', 0);
d1060 1
a1060 1
    err = DmCreateDatabase(0, "Hot List", APPTYPE, 'hotl', 0);
d1068 1
a1068 1
    err = DmCreateDatabase(0, "Trans Storage", APPTYPE, 'stor', 0);
d1120 1
d1122 1
d1137 34
d1179 5
a1183 4
    if (! SysHandleEvent (&e))
      if (! MenuHandleEvent (NULL, &e, &err))
	if (! ApplicationHandleEvent (&e))
	  FrmDispatchEvent (&e);
@


1.24
log
@*** empty log message ***
@
text
@d38 1
d61 1
d80 1
d109 1
a109 1
 * ID Number Allocation
d141 1
d149 2
d152 1
d156 1
d183 3
d216 168
d388 1
a388 1
  UInt index = 0;
a533 1
      Chunk c;
d550 2
a551 5
	c.dataSize = curURLLength;
	c.dataHand = curURL;
	c.metaSize = 0;	
	c.conID = conID;
	SendChunk(&c);
d554 2
a555 1
      FrmReturnToForm(MainForm);
a630 1

d643 1
d646 3
d650 5
a654 1
      FrmPopupForm(URLForm);
d657 1
a657 1
      FrmPopupForm(ProxyForm);
d660 1
a660 1
      FrmPopupForm(HotListForm);
d665 8
d674 7
d683 3
a694 1
      Chunk urlOut;
d697 6
a702 1
      if (hPage) {
a730 5
	    urlOut.conID = conID;
	    urlOut.metaSize = 0;
	    urlOut.dataSize = (DataSize) curURLLength;
	    urlOut.dataHand = curURL;
	    urlOut.metaHand = NULL;
d732 2
a733 1
	    SendChunk(&urlOut);
a742 28
  case transNewChunk:
    {
      ChunkPtr c;

      transEventPtr te = (transEventPtr) e;
      if (hPage)
	{
	  currYPosOffset = 0;
	  hPage = NULL;
	}
      if (curChunk) {
	Err err;
	err = DestroyChunk(curChunk);
      }

      curChunk = te->data.newChunk.chunkHand;
      
      c = (ChunkPtr) MemHandleLock(curChunk);
      hPage = c->dataHand;
      MemHandleUnlock(curChunk);
      if (hPage) {
	WinEraseWindow();
	WinDrawProxyString(hPage, currYPosOffset); 
      }
    }
  handled = true;
  break;

d778 1
d780 1
d782 2
a783 1
    FrmReturnToForm(MainForm); 
a797 1
  Chunk urlOut;
d814 1
d834 4
a837 8
	/* set the chunk data structures */
	urlOut.conID = conID;
	urlOut.metaSize = 0;
	urlOut.dataSize = (DataSize) curURLLength;	
	urlOut.dataHand = curURL;
	/* send the chunk */
	SendChunk(&urlOut);
	/* cleanup */
a838 5
	if (hPage)
	  {
	    currYPosOffset = 0;
	    hPage = NULL;
	  }
d842 2
a843 1
    FrmReturnToForm(0); 
d860 2
d863 1
a863 1
  if (e->eType == frmLoadEvent) {
d883 37
a920 1

d941 9
a1001 1

d1181 15
a1195 13

    if (attributes & LINK) {
      currFragLen = startPoint[currParseLoc++];
      /* use like this to get a link:
	 char aLink = (char*) &startPoint[currParseLoc]; */

      /* increment past the link */
      if ((currFragLen % 2) == 0) {
	currParseLoc += (currFragLen >> 1) /* to the next read pos */;
      } else {
	currParseLoc += ((currFragLen + 1) >> 1) /* to the next read pos */;
      }
      WinSetUnderlineMode(grayUnderline);
d1197 3
a1199 1
      
d1205 1
a1205 1
	WinDraw2Bitmap(image, startXPos, startYPos + -scrollOffset);
d1207 1
a1207 1
	WinDrawBitmap(image, startXPos, startYPos + -scrollOffset);
d1210 1
a1210 1
	WinDrawBitmap(image, startXPos, startYPos + -scrollOffset);
@


1.23
log
@hotlist works, fixed bugs
@
text
@d147 1
d332 17
d399 1
a399 1
	curTop = HotListLoadTable (frm, curTop-5);      
a401 1
	handled = true;
d403 1
d406 1
a406 1
      curTop = HotListLoadTable (frm, curTop+5);      
d731 2
a732 2
    cacheDB = DmOpenDatabaseByTypeCreator('cash', APPTYPE, dmModeReadWrite);  
    ErrFatalDisplayIf(!cacheDB, "Error opening cache database");    
d743 21
d774 1
a774 1
  conID = OpenConnection(proxyServer, proxyPort, cacheDB);
d800 1
@


1.22
log
@fixed some stupid bugs
@
text
@d47 2
a48 2
 * +--------+         
 * | bitmap | 
d53 4
a56 4
 * +--------+--------+--------+--------+         
 * | length | link   | frag(s | 0x0000 | 
 * | 2 byte | x byte | x byte | 2 byte |  
 * +--------+--------+--------+--------+         
d171 3
d207 1
a208 1
  void* tmp = (void *)"TEST";
d210 10
a219 5
  dataHand = DmNewRecord(hotlistDB, &index, 5);
  dataPtr = MemHandleLock(dataHand);
  DmWrite(dataPtr, 0, tmp, 5);
  MemHandleUnlock(dataHand);
  DmAttachRecord(hotlistDB, &index, (Handle) dataHand, NULL);
d233 3
d237 1
a237 2

  recordNum = TblGetItemInt (tableP, row, column);
d243 1
a243 1

d246 2
a247 2
  MemHandleUnlock(recHandle);
	
d249 1
a249 1

d257 1
a257 1
static void HotListLoadTable(FormPtr frm, TablePtr tableP) {
d262 8
a269 1
  UInt recordNum = 0;
d273 19
a291 1
  for (row = 0; row < numRows; row++, recordNum++) {		
d295 2
a296 2
      TblSetItemStyle (tableP, row, 0, customTableItem);
      TblSetItemInt (tableP, row, 0, recordNum);
a299 1
      TblSetItemStyle (tableP, row, 0, textTableItem);
d302 1
a302 1
    TblMarkRowInvalid (tableP, row);    
d304 1
a308 2
  Word recordNum = 0;
  Word rowsInTable;
d311 1
a311 1
  HotListLoadTable (frm, tableP);
d332 46
d379 12
a390 2
    case HotListDone:
      FrmReturnToForm(MainForm); 
d394 2
a474 2
      SWord urlLength;
      VoidHand hURL;
d482 2
a483 1
	eventPiece = PieceClicked(hPage, e->screenX, e->screenY, currYPosOffset);
d495 7
a501 4
	    urlLength = eventPiece[7];
	    hURL = MemHandleNew((ULong) urlLength);
	    if (hURL) {
	      outURL = MemHandleLock(hURL);
d504 1
a504 1
	      MemHandleUnlock(hURL);
d506 1
a506 1
	      ErrFatalDisplayIf (urlLength, "Not enough memory!");
d510 2
a511 2
	    urlOut.dataSize = (DataSize) urlLength;
	    urlOut.dataHand = hURL;
a515 1
	    MemHandleFree(hURL);
d527 1
a604 1
  VoidHand urlHandle;
a605 1
  Word urlLength = 0;
d626 1
a626 1
	urlLength = FldGetTextLength(URLField) + 1;
d628 6
a633 3
	urlHandle = MemHandleNew((ULong) urlLength);
	if (urlHandle) {
	  urlOutSet = MemHandleLock(urlHandle);
d638 1
a638 1
	  ErrFatalDisplayIf(urlLength, "Out of memory!");
d643 2
a644 2
	urlOut.dataSize = (DataSize) urlLength;	
	urlOut.dataHand = urlHandle;
d648 1
a648 2
	MemHandleUnlock(urlHandle);
	MemHandleFree(urlHandle);
d657 1
a657 1
    FrmReturnToForm(MainForm); 
d678 1
a678 1
    FrmSetActiveForm(frm);
@


1.21
log
@o linked images work
o better handling of unknown MIME types
@
text
@a0 1

d388 2
d391 2
d407 8
a414 3
	    outURL = MemHandleLock(hURL);
	    /* data out setup */
	    StrCopy (outURL, (char*) &eventPiece[8]);
d419 1
d422 2
a423 3
	  /* cleanup */	    
	    MemHandleUnlock(hURL);
	    MemHandleFree(hURL);	
d427 1
a443 1
	ErrFatalDisplayIf(err, "I CRY CRY CRY");
d451 4
a454 2
      WinEraseWindow();
      WinDrawProxyString(hPage, currYPosOffset); 
d538 8
a545 3
	urlOutSet = MemHandleLock(urlHandle);
	/* copy it */
	StrCopy (urlOutSet, url);
d549 1
a549 1
	urlOut.dataSize = (DataSize) urlLength;
@


1.20
log
@super-speedy 2-bit mode
@
text
@d820 14
d866 1
a866 1
    if (attributes & UNDERLINE) {
a868 14
    if (attributes & LINK) {
      currFragLen = startPoint[currParseLoc++];
      /* use like this to get a link:
	 char aLink = (char*) &startPoint[currParseLoc]; */

      /* increment past the link */
      if ((currFragLen % 2) == 0) {
	currParseLoc += (currFragLen >> 1) /* to the next read pos */;
      } else {
	currParseLoc += ((currFragLen + 1) >> 1) /* to the next read pos */;
      }
      WinSetUnderlineMode(grayUnderline);
    }
      
@


1.19
log
@well, I think I've finally tracked down the last of those
obnoxious invalid handle bugs (knock on wood)
@
text
@a330 3
#ifdef TWOBIT
	WinEraseWindow_2bit();
#else
a331 1
#endif
a339 3
#ifdef TWOBIT
	WinEraseWindow_2bit();
#else
a340 1
#endif
a351 3
#ifdef TWOBIT
      WinEraseWindow_2bit();
#else
a352 1
#endif
a398 3
#ifdef TWOBIT
		  WinEraseWindow_2bit();
#else
a399 1
#endif
a442 3
#ifdef TWOBIT
      WinEraseWindow_2bit();
#else
a443 1
#endif
d825 1
a825 1
	WinDrawBitmap_2bit(image, startXPos, startYPos + -scrollOffset);
@


1.18
log
@FIXED OBNIXOUS HANDLE BUGS THAT WERE KILLING THE PILOT.
@
text
@a451 1
	curChunk = te->data.newChunk.chunkHand;
d453 2
d456 1
a456 1
      c = (ChunkPtr) MemHandleLock(te->data.newChunk.chunkHand);
d458 1
a458 1
      MemHandleUnlock(te->data.newChunk.chunkHand);
d675 3
@


1.17
log
@use database memory to stroe pages
@
text
@d1 1
d142 1
a142 1
#define VERSION "0.5a"
d144 1
d146 2
a147 1
DmOpenRef dataB;
d171 2
d202 113
d331 1
d333 3
d344 1
d346 3
d360 1
d362 3
d377 1
a377 1
    case ProxyMenu:
d380 10
a409 1
		  MemHandleFree(hPage);
d411 1
d413 3
d429 1
a429 1
	  /* cleanup */
a445 1
	  MemHandleFree(hPage);
d448 7
d458 1
a458 1
      MemHandleFree(te->data.newChunk.chunkHand);
d460 4
a463 1
      WinDrawProxyString(hPage, currYPosOffset);
d559 1
a559 1
	MemHandleFree(urlHandle);	
a562 1
	    MemHandleFree(hPage);
d601 3
d619 8
d628 7
a634 1
  dataB = DmOpenDatabaseByTypeCreator('appl', 'Wtxt', dmModeReadWrite);
d645 2
a646 2

  conID = OpenConnection(proxyServer, proxyPort, dataB);
d670 2
a671 1
  DmCloseDatabase(dataB);
d735 1
d737 1
d744 1
a744 1
      MemHandleFree(hPage);
d747 1
d749 1
d840 1
d842 3
@


1.16
log
@browser works with new transport layer
@
text
@d144 2
d466 3
d477 2
a478 1
  conID = OpenConnection(proxyServer, proxyPort, NULL);
d501 3
@


1.15
log
@2bit almost ready
@
text
@d279 2
a280 1
	    urlOut.size = (DataSize) urlLength;
d398 2
a399 1
	urlOut.size = (DataSize) urlLength;
d472 1
a472 1
  conID = OpenConnection(proxyServer, proxyPort);
d477 2
a478 1
  urlOut.size = (DataSize) welcomeURLLength;
@


1.14
log
@updated proxy info dialog box.
@
text
@d76 1
a76 1
 *   IMAGE      0x20
d123 1
d141 2
a142 1
#define WELCOME_URL  "foo"
d211 1
a211 1
	WinEraseWindow();
d220 1
a220 1
	WinEraseWindow();
d232 1
a232 1
      WinEraseWindow();
d264 8
a285 8
	    /* Clear the page so they know something happened */
	      if (hPage)
		{
		  currYPosOffset = 0;
		  MemHandleFree(hPage);
		  hPage = NULL;
		  WinEraseWindow();
		}
d307 1
a307 1
      WinEraseWindow();
d377 1
d384 2
a385 3
      URLField = FrmGetObjectPtr(FrmGetFormPtr(URLForm),
				 FrmGetObjectIndex(FrmGetFormPtr(URLForm),
						   URLFormFld));
d482 3
a527 1
    FrmGotoForm(MainForm);
d538 1
d541 14
a554 9
  RectangleType dispBounds;
  dispBounds.topLeft.x = 0; 
  dispBounds.topLeft.y = 0;
  dispBounds.extent.x = 160;
  dispBounds.extent.y = 160;
  disp = WinCreateWindow(&dispBounds, noFrame, 0, 1, &dispError);
  WinInitializeWindow(disp);
  WinSetDrawWindow(disp);
  WinGetWindowExtent(&winXextent, &winYextent);
d564 5
a568 1
  WinDeleteWindow(disp, 1);
d654 5
a658 1
    WinDrawBitmap(image, startXPos, startYPos + -scrollOffset);
@


1.13
log
@assorted fixes
@
text
@d140 1
a140 1
#define WELCOME_URL  "foo1"
d242 4
a246 1

d253 1
a253 1
      UInt urlLength;
a319 1
#if 0
d325 2
d337 1
a337 1
    FldSetTextPtr(addrFld, (char*) &proxyPort);
d348 1
a348 1
    FrmGotoForm(MainForm); 
a356 1
#endif
a440 1
#if 0
a443 1
#endif
@


1.12
log
@fix try 2
@
text
@d273 8
d465 1
a465 1
    ErrFatalDisplayIf(err, "Can't open transport layer!");
d485 1
d487 2
a488 1
  ErrNonFatalDisplayIf(StopTrans(), "Error closing transport layer!");
d501 1
a501 1
    EvtGetEvent(&e, evtWaitForever);
@


1.11
log
@*** empty log message ***
@
text
@d254 16
a269 16
      
      eventPiece = PieceClicked(hPage, e->screenX, e->screenY, currYPosOffset);
      if (eventPiece) {
	attributes = eventPiece[6];
	if (attributes & LINK) {
	  /* create buffer for sending info */
	  urlLength = eventPiece[7];
	  hURL = MemHandleNew((ULong) urlLength);
	  outURL = MemHandleLock(hURL);
	  /* data out setup */
	  StrCopy (outURL, (char*) &eventPiece[8]);
	  urlOut.conID = conID;
	  urlOut.size = (DataSize) urlLength;
	  urlOut.dataHand = hURL;
	  /* set out link request */
	  SendChunk(&urlOut);
d271 4
a274 3
	  MemHandleUnlock(hURL);
	  MemHandleFree(hURL);	
	  handled = true;
@


1.10
log
@should fix memory problem
@
text
@d140 1
a140 1
#define WELCOME_URL  "foo"
@


1.9
log
@link should work
@
text
@d399 1
a399 1
    FrmGotoForm(MainForm); 
d747 1
@


1.8
log
@Close to working
@
text
@d53 5
a57 4
 * +--------+--------+--------+
 * | length | link   | frag(s |
 * | 2 byte | x byte | x byte |
 * +--------+--------+--------+
a65 1
 *
d67 1
a67 1
 *
d79 1
d138 3
a140 1
#define SCROLL_GRAN  20
d149 2
d153 10
a162 6
static ConID conID = 0;        /* connection id for network subsystem */
static VoidHand hPage = NULL;  /* handle to the current page */
static WinHandle disp = 0;     /* handle to the display window */
static Word dispError = 0;     /* error for window, needed to create window */
static int moreOffscreen = 0;  /* have we displayed to the end of doc yet? */
static int currYPosOffset = 0; /* scrolling position for the page */
d229 4
d240 1
a240 1
    case MenuOpen: 
d247 32
a294 1
      handled = true;
d296 1
d308 38
a349 1
  char * url;
d352 3
a354 1
  Word urlLength;
a355 1
  VoidHand urlHandle;
d358 1
a358 1
    
a368 1
      /* get the text and the length */
d372 25
a396 24
      url = FldGetTextPtr(URLField);
      urlLength = FldGetTextLength(URLField);
      /* create the handle and the copy point */
      urlHandle = MemHandleNew((ULong) urlLength);
      urlOutSet = MemHandleLock(urlHandle);
      /* copy it */
      StrCopy (urlOutSet, url);
      /* set the chunk data structures */
      urlOut.conID = conID;
      urlOut.size = (DataSize) urlLength;
      urlOut.dataHand = urlHandle;
      /* send the chunk */
      SendChunk(&urlOut);
      /* cleanup */
      MemHandleUnlock(urlHandle);
      MemHandleFree(urlHandle);	
      if (hPage)
	{
	  currYPosOffset = 0;
	  MemHandleFree(hPage);
	  hPage = NULL;
	}
      /* ErrNonFatalDisplayIf
         'PRpg', 1), "dmCreateFailed"); */
d399 1
a399 1
    FrmGotoForm(MainForm);      
d429 5
d445 6
d452 2
d458 12
a469 1
  conID = OpenConnection("128.32.131.63", 4444);
d504 3
d532 1
d575 1
a575 1
  int byteSize = MemPtrSize(proxyString);
a577 2
  /* printf("%d", byteSize); */

d588 5
a592 1
      moreOffscreen = 1; /* removed for now */
a612 1
  SWord winXextent = 0, winYextent = 0;
a613 1
  WinGetWindowExtent(&winXextent, &winYextent);
d705 1
a705 1

d707 1
a707 1
  if (startYPos + -scrollOffset - Yextent > winYextent ) {
d715 3
d719 61
@


1.7
log
@.
@
text
@d1 1
a1 1
/* UI andDdata code for Top Gun Wing Man(?)
d28 4
a31 4
 *  +---------+---------+
 *  | piece(s)| 0xFFFF  |
 *  | x bytes | 2 bytes |
 *  +---------+---------+
d34 24
a57 4
 *  +---------+---------+---------+---------+---------+---------+---------+
 *  | BackPtr | ForPtr  | Xpos    | Ypos    | Attrib  | frag(s) | 0x0000  |
 *  | 2 bytes | 2 bytes | 2 bytes | 2 bytes | 2 bytes | x bytes | 2 bytes |
 *  +---------+---------+---------+---------+---------+---------+---------+
d60 8
a67 16
 *  +---------+---------+         
 *  | length  | char(s) | 
 *  | 2 bytes | x bytes |  
 *  +---------+---------+
 *
 *  (or when you length happens to be zero)
 *  +---------+         
 *  | 0x0000  | 
 *  | 2 bytes |
 *  +---------+ (this is bug in the implementation, will be fixed later)
 *
 *  (or when the 5th bit is on, meaning an image)
 *  +---------+         
 *  | bitmap  | 
 *  | x bytes |
 *  +---------+ (only one allowed in this case)
d77 1
d99 1
a99 1
 * Proxy HTML "Page" Resource Layout
d126 13
a138 10
#define BOLD       0x1
#define ITALIC     0x2
#define UNDERLINE  0x4
#define FONT_MASK  0x18
#define FONT_STD   0x0
#define FONT_BIG1  0x8
#define FONT_BIG2  0xf
#define FONT_BIG3  0x18
#define IMAGE 0x20
 
a139 1

d147 7
a153 8
/* globals */
VoidHand hPage = NULL;
static WinHandle disp;
static Word dispError;
static int dispScrollPos;
static int currYPosOffset = 0;
ConID conID;

d194 2
a195 2
      if (hPage) {
	  WinEraseWindow();
d197 5
a201 2
	  dispScrollPos -= 20;
	  WinDrawProxyString(hPage, dispScrollPos);
d207 2
a208 1
      if (hPage) {
d210 1
a210 3
	currYPosOffset = 0;
	dispScrollPos += 20;
	WinDrawProxyString(hPage, dispScrollPos);
d240 1
d249 1
a249 1
      WinDrawProxyString(hPage, dispScrollPos);
d306 6
d314 1
a318 1
    
a368 1
  Word err;
d370 1
a370 6
  err = StopTrans();
  if (err) {
    ErrFatalDisplayIf(err, "Error closing transport layer!");
    return;
  }

d464 1
d467 2
d473 7
a479 2
    if (retVal == -1 || proxyString[nextParseOffset] == 0xFFFF) {
      /* its the end of string token */
a493 1
  /* int iters = 0; nonconformance? yes, Armando and I don't interpret the same */
d495 1
d497 2
a498 1
  SWord startXPos = 0, startYPos = 0; /* starting position for the drawing */
a500 1
  BitmapPtr image;
d504 1
a504 1
  currYPosOffset = -scrollOffset;
d509 4
a512 2
  attributes = startPoint[4];
  currParseLoc = 5; /* move it to the next read pos */
d515 1
d517 1
a517 2
    WinDrawBitmap(image, startXPos, startYPos);
    return ((backOffset / 2) - 1); /* move it to the next read pos */
d538 14
a551 1
    if ((attributes & UNDERLINE) == UNDERLINE) {
d554 2
a555 1

d559 2
a560 2

    /* is there any more to draw and is there still room on screen? */
d562 1
a562 1
	  (startYPos + currYPosOffset) > winYextent) {
d567 11
a577 8
	if (mode) {
	  /* erase mode */
	  WinEraseChars((char*) &startPoint[currParseLoc], (Word) currFragLen, 
			startXPos, startYPos + currYPosOffset + internalOffset);
	} else {
	  /* draw mode */
	  WinDrawChars((char*) &startPoint[currParseLoc], (Word) currFragLen, 
		       startXPos, startYPos + currYPosOffset + internalOffset);
a578 1

d581 1
a581 1
	  currParseLoc += (currFragLen >> 1) /* move it to the next read pos */;
d583 1
a583 1
	  currParseLoc += ((currFragLen + 1) >> 1) /* move it to the next read pos */;
d585 1
a585 1

a592 6
    if (startYPos + currYPosOffset > winYextent) {
      return -1;
    } else {
      return ((forwardOffset / 2) + 1); /* move it to the next read pos */
      /* previous return value needs -1, await fix from armando */
    }
d594 8
d603 4
@


1.6
log
@It slices, it dices. But most importantly, it displays and scrolls correctly!
@
text
@d1 1
a1 1
/* UI and data code for Top Gun Wing Man(?)
d40 3
a42 3
 *  +---------+---------+
 *  | length  | char(s) |
 *  | 2 bytes | x bytes |
d45 20
a64 1
 * where x is always a multiple of 2 bytes to maintain 16-bit alignment
d107 2
a108 1

d121 2
a122 1

d125 2
a126 2
void ProxyTestClose();
void ProxyTestInit();
d131 1
a131 1

d133 1
a135 2
static DmOpenRef proxyPage;
static VoidHand proxyString;
d138 2
a139 1
int first = 0;
d151 1
a151 1

d166 1
a166 1
      " : : : "d0", "d1", "d2", "d3", "a1", "a0");
d174 3
a176 1
    
d180 6
a185 4
      WinEraseWindow();
      currYPosOffset = 0;
      dispScrollPos -= 20;
      WinDrawProxyString(proxyString, dispScrollPos);
d190 6
a195 4
      WinEraseWindow();
      currYPosOffset = 0;
      dispScrollPos += 20;
      WinDrawProxyString(proxyString, dispScrollPos);
a203 9
    if (first == 0)
      {
	ProxyTestInit();
      }
    else
      {
	WinEraseWindow();
	WinDrawProxyString(proxyString, dispScrollPos);
      }
d211 2
d218 16
a233 6
#if 0
    case penUpEvent:
    if (e->data.screenX < 80){
      FrmPopupFrm(URLForm);

      handled= true;
d235 1
a235 2
    break;
#endif
d240 3
d251 3
d255 3
d266 1
a266 2
#if 0
    case ctlSelectEvent:
d269 4
a272 1
      URLField = FrmGetObjectPtr(URLFrom, FrmGetObjectIndex(URLForm, URLFormFld));
d274 17
a290 12
      if (url != NULL) {
	FrmGotoForm(MainForm);
	/* open up next work and display */
	ErrNonFatalDisplay(dmCreateDatabase(0, "TGwm dB", 'TGwm', 'PRpg', 1),
			   "dmCreateFailed") {
	  
	WinEraseWindow();
	WinDrawProxyString(hText, scrollOffset);
      }
      else {
	/* shaving cream */
      }
d292 2
d295 1
a295 2
#endif

d299 3
d333 7
d346 9
a354 1
  ProxyTestClose();
d365 1
a378 1

d395 1
a395 1
void ProxyTestInit()
d398 7
a404 22
  /* unsigned char *test2; */

  proxyPage = DmOpenDatabaseByTypeCreator('PRpg', 'TGwm',
					  dmModeReadOnly);
  proxyString = DmGetResource(strRsc, 1999);
  /*  test2 = MemHandleLock(proxyString); */
  /*  WinDrawChars(test2, 20, 0, 100); */
  /*  MemHandleUnlock(proxyString); */

  if (proxyString) { /* should be proxyPage, disabled for testing */
    dispBounds.topLeft.x = 0; 
    dispBounds.topLeft.y = 0;
    dispBounds.extent.x = 160;
    dispBounds.extent.y = 160;
    disp = WinCreateWindow(&dispBounds, noFrame, 0, 1, &dispError);
    WinInitializeWindow(disp);
    WinSetDrawWindow(disp);
    WinDrawProxyString(proxyString, dispScrollPos);
  }
  else {
    /* narf */
  }
d407 1
a407 1
void ProxyTestClose()
d409 5
a413 1

a414 1
  DmReleaseResource(proxyString);
d469 1
a469 1
  int iters = 0; /* nonconformance? yes, Armando and I don't interpret the same */
d475 3
d487 10
a496 22
#ifdef DEBUG
  StartDebug();
#endif


  /* internal preprocessing of window attributes */
  WinGetWindowExtent(&winXextent, &winYextent);
  /* WinDisplayToWindowPt(&startXPos, &startYPos); */

  /* processing of display attributes except underline*/
  if (attributes & BOLD) {
    FntSetFont(boldFont);
  }
  if (attributes & ITALIC) {
    /* Currently unsupported */
  }
  if (attributes & FONT_MASK) {
    if ((attributes & FONT_MASK) == FONT_STD) {
      FntSetFont(stdFont);
    } else if ((attributes & FONT_MASK) == FONT_BIG1) {
      FntSetFont(largeFont);
    } else if ((attributes & FONT_MASK) == FONT_BIG2) {
a497 2
    } else if ((attributes & FONT_MASK) == FONT_BIG3) {
      /* currently unsupported */
d499 15
a513 5
  }
  /* this attribute is independent of the others on the pilot */
  if ((attributes & UNDERLINE) == UNDERLINE) {
    WinSetUnderlineMode(grayUnderline);
  }
d515 3
a517 3
  while(1) {
    /* this part would by INTWinProxyStringFrag, but it's rolled in */
    currFragLen = startPoint[currParseLoc++];
d520 3
a522 18
    if (currFragLen == 0 ||
	(startYPos + currYPosOffset) > winYextent) {
      /* latter may cause barf */
      if (iters == 0) {
	currParseLoc+=1;
      }
      break;
    }
    else {
      /* yes, so its a proxy string frag */      
      if (mode) {
	/* erase mode */
	WinEraseChars((char*) &startPoint[currParseLoc], (Word) currFragLen, 
		      startXPos, startYPos + currYPosOffset + internalOffset);
      } else {
	/* draw mode */
	WinDrawChars((char*) &startPoint[currParseLoc], (Word) currFragLen, 
		     startXPos, startYPos + currYPosOffset + internalOffset);
d524 18
d543 2
a544 5
      /* how much do we increment the pointer */
      if ((currFragLen % 2) == 0) {
	currParseLoc += (currFragLen >> 1) /* move it to the next read pos */;
      } else {
	currParseLoc += ((currFragLen + 1) >> 1) /* move it to the next read pos */;
a545 3

      /* start next line */
      internalOffset += FntLineHeight();
d547 9
a555 10
    iters += 1;
  }
  /* clean up */
  FntSetFont(stdFont);
  WinSetUnderlineMode(noUnderline);

  if (startYPos + currYPosOffset > winYextent) {
    return -1;
  } else {
    return currParseLoc; /* move it to the next read pos */
a557 2


@


1.5
log
@Updated version. Seems mostly harmless.
@
text
@d117 2
d158 1
d161 2
d166 1
d169 2
d177 9
d198 6
a203 2
  case ctlSelectEvent:
    switch(e->data.ctlEnter.controlID) {
d206 1
d218 2
d228 2
a229 1
  case ctlSelectEvent:
d231 15
d248 1
a283 1
  ProxyTestInit();
a335 4
#ifdef DEBUG
  StartDebug();
#endif
  
d344 4
a347 4
    dispBounds.topLeft.x = 1; 
    dispBounds.topLeft.y = 1;
    dispBounds.extent.x = 158;
    dispBounds.extent.y = 158;
d394 2
a395 12
  int nextParseOffset = 0;
  SWord *proxyString;

  if (!hText) {
    return 1;
  }

  proxyString = MemHandleLock(hText);

#ifdef DEBUG
  StartDebug();
#endif
d398 4
a401 4
    nextParseOffset = INTWinProxyStringPiece(&proxyString[nextParseOffset],
					     scrollOffset, mode);

    if (proxyString[nextParseOffset] == 0xFFFF) {
d405 1
d415 8
a422 11
  int currParseLoc;
  int currFragLen; /* used to determine num of chars left in current frag */
  int currYPosOffset = -scrollOffset;
  SWord forwardOffset, backOffset;
  SWord startXPos, startYPos; /* starting position for the drawing */
  SWord attributes;
  SWord winXextent, winYextent;

#ifdef DEBUG
  StartDebug();
#endif
d424 1
d432 5
a437 1
  WinDisplayToWindowPt(&startXPos, &startYPos);
d439 1
d451 1
a451 2
    }
    else if ((attributes & FONT_MASK) == FONT_BIG1) {
d453 1
a453 2
    }
    else if ((attributes & FONT_MASK) == FONT_BIG2) {
d455 1
a455 2
    }
    else if ((attributes & FONT_MASK) == FONT_BIG3) {
d466 1
a466 1
    currFragLen = startPoint[currParseLoc];
d469 6
a474 2
    if (currFragLen == 0 || currYPosOffset > winYextent) { /* latter may cause barf */
      /* no */
a478 2
      currParseLoc += 1;

d482 2
a483 3
		      startXPos, startYPos + currYPosOffset);
      }
      else {
d486 1
a486 1
		     startXPos, startYPos + currYPosOffset);
d492 1
a492 2
      }
      else {
d497 1
a497 1
      currYPosOffset += FntLineHeight();
d499 1
d504 6
a509 1
  return (currParseLoc + 1); /* move it to the next read pos */
@


1.4
log
@Blank test palette. Fixes resource error.
@
text
@d14 1
a14 1
 *   piece  - a subset of the string resource, contains zero or more frags,
d17 1
a17 1
 *   frag   - a subset of a piece, composed of a 16-bit length followed by
d50 1
a50 1
 *  2     ForPtr  (SWord), an offset to the next BackPtr
d109 1
a109 1
SWord INTWinProxyStringPiece(unsigned char *startPoint, int scrollOffset, int mode);
d122 4
a125 4
 extern void start ();
 DWord romVersion;
 FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
 if (romVersion >= 0x02000000) {
d127 1
a127 17
 }

 asm("
        lea data_start(%%a4),%%a1
        move.l %%a1,%%d2
        lea bss_start(%%a4),%%a1
        move.l %%a1,%%d1
        lea start(%%pc),%%a0
        move.l %%a0,%%d0
        sub.l #start, %%d0
        move.l #0x12BEEF34, %%d3
        trap #8
        move.l #0, %%d3
        move.l #0, %%d0
        move.l #0, %%d1
        move.l #0, %%d2
 " : : : "d0", "d1", "d2", "d3", "a1", "a0");
d129 15
d149 25
a173 2
    Boolean handled = false;
    FormPtr frm;
d175 10
a184 13
    
    switch (e->eType) {
    case keyDownEvent:
      if (e->data.keyDown.chr == pageUpChr) {	
	WinEraseWindow();
	dispScrollPos -= 20;
	WinDrawProxyString(proxyString, dispScrollPos);
      }
      else if (e->data.keyDown.chr == pageDownChr) {
	WinEraseWindow();
	dispScrollPos += 20;
	WinDrawProxyString(proxyString, dispScrollPos);
      }
d186 5
d192 11
a202 19
    case frmOpenEvent:
	frm = FrmGetActiveForm();
	FrmDrawForm(frm);
	handled = true;
	break;

    case menuEvent:
	MenuEraseStatus(NULL);

	switch(e->data.menu.itemID) {
	}

    	handled = true;
	break;

    case ctlSelectEvent:
	switch(e->data.ctlEnter.controlID) {
	}
	break;
d204 2
a205 2
    default:
        break;
d207 6
a212 1
    return handled;
d217 16
a232 15
    FormPtr frm;
    Word    formId;
    Boolean handled = false;

    if (e->eType == frmLoadEvent) {
	formId = e->data.frmLoad.formID;
	frm = FrmInitForm(formId);
	FrmSetActiveForm(frm);

	switch(formId) {
	case MainForm:
	    FrmSetEventHandler(frm, MainFormHandleEvent);
	    break;
	}
	handled = true;
d234 2
d237 1
a237 1
    return handled;
d258 9
a266 9
    Word err;
    EventType e;
    do {
	EvtGetEvent(&e, evtWaitForever);
	if (! SysHandleEvent (&e))
	    if (! MenuHandleEvent (NULL, &e, &err))
		if (! ApplicationHandleEvent (&e))
		    FrmDispatchEvent (&e);
    } while (e.eType != appStopEvent);
d273 1
a273 1
    Word err;
d275 1
a275 1
    if (cmd == sysAppLaunchCmdNormalLaunch) {
d277 2
a278 2
	err = StartApplication();
	if (err) return err;
d280 3
a282 3
	FrmGotoForm(MainForm);
	EventLoop();
	StopApplication();
d284 3
a286 3
    } else {
	return sysErrParamErr;
    }
d288 1
a288 1
    return 0;
d302 1
a302 1
  proxyString = DmGet1Resource(strRsc, 1999);
d307 1
a307 1
  if (1) { /* should be proxyPage, disabled for testing */
d359 7
a365 1
  unsigned char *proxyString = MemHandleLock(hText);
d368 1
a368 1
    StartDebug();
d375 1
a375 2
    if ((proxyString[nextParseOffset] == 255) &&
	(proxyString[nextParseOffset + 1] == 255)) {
d384 1
a384 1
SWord INTWinProxyStringPiece(unsigned char *startPoint, int scrollOffset,
d397 1
a397 1
    StartDebug();
d400 6
a405 6
  backOffset = (SWord) startPoint[0];
  forwardOffset = (SWord) startPoint [2];
  startXPos = (SWord) startPoint[4];
  startYPos = (SWord) startPoint[6];
  attributes = (SWord) startPoint[8];
  currParseLoc = 10; /* move it to the next read pos */
d412 1
a412 1
  if (attributes &= BOLD) {
d415 1
a415 1
  if (attributes &= ITALIC) {
d418 2
a419 2
  if (attributes &= FONT_MASK) {
    if ((attributes &= FONT_MASK) == FONT_STD) {
d422 1
a422 1
    else if ((attributes &= FONT_MASK) == FONT_BIG1) {
d425 1
a425 1
    else if ((attributes &= FONT_MASK) == FONT_BIG2) {
d428 1
a428 1
    else if ((attributes &= FONT_MASK) == FONT_BIG3) {
d433 1
a433 1
  if (attributes &= UNDERLINE) {
d442 1
a442 1
    if (currFragLen == 0 || currYPosOffset > winYextent) {
d448 1
a448 1
      currParseLoc += 2;
d452 1
a452 1
	WinEraseChars(&startPoint[currParseLoc], (Word) currFragLen, 
d457 1
a457 1
	WinDrawChars(&startPoint[currParseLoc], (Word) currFragLen, 
d463 1
a463 1
	currParseLoc += (currFragLen + 2) /* move it to the next read pos */;
d466 1
a466 1
	currParseLoc += (currFragLen + 3) /* move it to the next read pos */;
d476 1
a476 1
  return currParseLoc + 2; /* move it to the next read pos */
@


1.3
log
@fixed for use in demo
@
text
@d278 1
a278 1
  proxyString = DmGetResource(strRsc, 1999);
@


1.2
log
@Updated text display routine. Should work. Hehe.

-Dave
@
text
@d270 1
a270 1
  unsigned char *test2;
d276 2
a277 2
  /* proxyPage = DmOpenDatabaseByTypeCreator('PRpg', 'TGwm',
					  dmModeReadOnly); */
d279 3
a281 3
  test2 = MemHandleLock(proxyString);
  WinDrawChars(test2, 20, 0, 100);
  MemHandleUnlock(proxyString);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* Main code for template
d5 80
d89 28
a116 1
#include "templateRsc.h"
d152 1
d155 13
d219 2
a220 1
    return 0;
d226 3
a228 2
    FrmSaveAllForms();
    FrmCloseAllForms();
a235 1

a252 3
#ifdef DEBUG
	StartDebug();
#endif
d266 185
@


1.1.1.1
log
@This is the first entry in to the text experiment. -lcd
@
text
@@


1.1.1.2
log
@Update stuff. No interface in.
@
text
@d8 1
a8 2
#include "wintextRsc.h"

a145 120

/****************************************************************************
 *
 * SWord WinDrawProxyText(voidHand hText)
 *
 * Takes a handle (hopefully of "proxytext" type) and draws it on screen.
 *
 * Proxy Text Format (SWord is 16bits, DWord is 32bits, ne?)
 *
 * nth byte - field
 *  0 - BackPtr (SWord), an offset to the previous BackPtr
 *  2 - ForwardPtr (SWord), an offset to the next BackPtr
 *  4 - Xpos (SWord), starting X coord on drawing surface (may not be scr)
 *  6 - Ypos (SWord), starting Y coord on drawing surface (may not be scr)
 *  8 - Attributes (DWord), to be defined later
 * 12 - Length (SWord), length of line string
 * 14 thru XX - Text, must be word (16-bit) aligned
 *    odd text length is padded with an blank char (will be ignored)
 *    (this part can repeat starting with length, repeats indicated newlines)
 * XX+1 - End Token (16-bit of Zero)
 *
 * currently returns zero, but will change in the future
 *
 ***************************************************************************/ 


SWord WinDrawProxyText(VoidHand hText, int startLine, int numLines)
{
  /* number of lines is currently unimplemented */

  int currParseLoc = 12;
  int currFragLen; /* used to determine num of chars left in current frag */
  SWord startXPos, startYPos; /* starting position for the drawing */
  DWord attributes;

  char *text = MemHandleLock(hText);
  startXPos = (SWord) text[4];
  startYPos = (SWord) text[6];
  attributes = (DWord) text[8];
  while(1) {
    currFragLen = text[currParseLoc];

    /* can we still draw a line */
    if (currFragLen == 0 || startYPos > 148) { /* no */
      break;
    }
    else { /* yes */      
      currParseLoc += 2;
      
      /* do we draw */
      if (startLine == 0) {
	WinDrawChars(&text[currParseLoc], (Word) currFragLen, 
		     startXPos, startYPos);
      }
      else {
	startLine -= 1;
      }

      /* how much do we increment the pointer */
      if ((currFragLen % 2) == 0) {
	currParseLoc += currFragLen;
      }
      else {
	currParseLoc += (currFragLen + 1);
      }

      /* start next line */
      startYPos += 12; /* assuming yheight of 12, need font metrics */
    }
  }
  return 0;
}

SWord WinEraseProxyText(VoidHand hText, int startLine, int numLines)
{
  /* number of lines is currently unimplemented */

  int currParseLoc = 12;
  int currFragLen; /* used to determine num of chars left in current frag */
  SWord startXPos, startYPos; /* starting position for the drawing */
  DWord attributes;

  char *text = MemHandleLock(hText);
  startXPos = (SWord) text[4];
  startYPos = (SWord) text[6];
  attributes = (DWord) text[8];
  while(1) {
    currFragLen = text[currParseLoc];

    /* can we still draw a line */
    if (currFragLen == 0 || startYPos > 148) { /* no */
      break;
    }
    else { /* yes */      
      currParseLoc += 2;
      
      /* do we draw */
      if (startLine == 0) {
	WinEraseChars(&text[currParseLoc], (Word) currFragLen, 
		     startXPos, startYPos);
      }
      else {
	startLine -= 1;
      }

      /* how much do we increment the pointer */
      if ((currFragLen % 2) == 0) {
	currParseLoc += currFragLen;
      }
      else {
	currParseLoc += (currFragLen + 1);
      }

      /* start next line */
      startYPos += 12; /* assuming yheight of 12, need font metrics */
    }
  }
  return 0;
}

@


1.1.1.3
log
@This is the bulk of my code. Should handle text display. Hopefully.
@
text
@d1 1
a1 2
/* UI and data code for Top Gun Wing Man(?)
   (a proxy based WWW browser for the USRobotics Pilots)
a3 80
/****************************************************************************
 *
 * * Proxy String Format
 *
 * A proxy string is a string resource which has text information encoded
 * in the proxy string format which is defined as follows:
 *
 *   string - an entire string resource, contains zero or more pieces,
 *            followed by an end token of 0xFFFF (16 bits)
 *   piece  - a subset of the string resource, contains zero or more frags,
 *            followed by an end token of 0x0000 (16 bits)
 *            each piece is associated with attribute and position data
 *   frag   - a subset of a piece, composed of a 16-bit length followed by
 *            8-bit chars
 *            (the number of which should be equal to the length, except when
 *             the length is odd in which one blank char is added to maintain
 *             16-bit word-alignment for purposes of addressing)
 *
 * (admittedly, this nomenclature sucks)
 *
 * graphically speaking:
 *
 * string:
 *  +---------+---------+
 *  | piece(s)| 0xFFFF  |
 *  | x bytes | 2 bytes |
 *  +---------+---------+
 *
 * piece:
 *  +---------+---------+---------+---------+---------+---------+---------+
 *  | BackPtr | ForPtr  | Xpos    | Ypos    | Attrib  | frag(s) | 0x0000  |
 *  | 2 bytes | 2 bytes | 2 bytes | 2 bytes | 2 bytes | x bytes | 2 bytes |
 *  +---------+---------+---------+---------+---------+---------+---------+
 *
 * frag:
 *  +---------+---------+
 *  | length  | char(s) |
 *  | 2 bytes | x bytes |
 *  +---------+---------+
 *
 * where x is always a multiple of 2 bytes to maintain 16-bit alignment
 *
 * minimal example:
 * byte#  field
 *  0     BackPtr (SWord), an offset to the previous BackPtr
 *  2     ForPtr  (SWord), an offset to the next BackPtr
 *  4     Xpos    (SWord), starting X coord on drawing surface (see note)
 *  6     Ypos    (SWord), starting Y coord on drawing surface (see note)
 *  8     Attrib  (SWord), text attributes, see below
 * 10     Length  (SWord), length of line string
 * 12-XX  Text, must be word (16-bit) aligned
 *          text of odd length is padded with an blank char
 * XX+1   Piece End Token (0x0000)
 * XX+3   String End Token (0xFFFF)
 *
 * Note: Xpos and Ypos are relative to an page absolute coordinate, which is
 *       independent of the screen on the pilot
 *
 ***************************************************************************/ 

/***************************************************************************
 *
 * Proxy HTML "Page" Resource Layout
 * 
 * Resources are in a database of type 'PRpg' (Proxy Page)
 *                             creator 'TGwm' (Top Gun Wing Man)
 *
 * 
 * ID Number Allocation
 *
 * String Segment is ID 1999 only
 * Bitmap segment 2000 thru 2999 (currently unimplemented)
 * (more segments to be defined as needed)
 *
 * The browser will do layout by scanning thru each of the segments
 * consecutively. On first lookup miss, it will assume it has finished
 * reading all the segments
 *
 ***************************************************************************/

a9 19
/* defines for fonts */

#define BOLD       0x1
#define ITALIC     0x2
#define UNDERLINE  0x4
#define FONT_MASK  0x18
#define FONT_STD   0x0
#define FONT_BIG1  0x8
#define FONT_BIG2  0xf
#define FONT_BIG3  0x18

/* function prototypes */
void ProxyTestInit();
void ProxyTestCleanup();

SWord WinDrawProxyString(VoidHand hText, int scrollOffset);
SWord WinEraseProxyString(VoidHand hText, int scrollOffset);
SWord INTWinProxyString(VoidHand hText, int scrollOffset, int mode);
SWord INTWinProxyStringPiece(char *startPoint, int scrollOffset, int mode);
a46 9
    case keyDownEvent:
      if (e->data.keyDown.chr == pageUpChr) {
	/* erase window, redraw window */
      }
      else if (e->data.keyDown.chr == pageDownChr) {
	/* erase window, redraw window */
      }


a147 26
void ProxyTestInit()
{
  /* the following should be global, to allow for proper close */
  WinHandle disp;
  RectangleType dispBounds;
  Word dispError;
  DmOpenRef proxyPage = DmOpenDatabaseByTypeCreator('PRpg', 'TGwm',
						    dmModeReadOnly);  
  VoidHand proxyString = DmGet1Resource(strRsc, 1999);
  int scroll;

  if (proxyPage) {
    dispBounds.topLeft.x = 1; 
    dispBounds.topLeft.y = 1;
    dispBounds.extent.x = 158;
    dispBounds.extent.y = 158;
    disp = WinCreateWindow(&dispBounds, noFrame, 0, 1, &dispError);
    WinInitializeWindow(disp);
    WinSetDrawWindow(disp);
    WinDrawProxyString(proxyString, 0);
  }
  else {
    /* bad day, include some obscene error message later */
  }
}  

d150 17
a166 1
 * Text Drawing / Erasing Functions
d168 3
a170 1
 ****************************************************************************/
d172 2
a173 1
SWord WinDrawProxyString(VoidHand hText, int scrollOffset)
d175 1
a175 2
  return INTWinProxyString(hText, scrollOffset, 0);
}
d177 4
a180 7
SWord WinEraseProxyString(VoidHand hText, int scrollOffset)
{
  /* this function is probably unnecessary since WinEraseWindow does a
   * more complete job, but it here in case you wanted to do anything cool
   */
  return INTWinProxyString(hText, scrollOffset, 1);
}
d182 6
a187 7
/****************************************************************************
 *
 * Internal functions for Win???ProxyString
 *
 * as a rule, you shouldn't call them
 * 
 ****************************************************************************/
d189 3
a191 9
SWord INTWinProxyString(VoidHand hText, int scrollOffset, int mode)
{
  int nextParseOffset = 0;
  char *proxyString = MemHandleLock(hText);
  while (1) {
    if ((proxyString[nextParseOffset] &= 0xFF) &&
	(proxyString[nextParseOffset + 1] &= 0xFF)) {
      /* its the end of string token */
      break; 
d193 22
a214 4
    else {
      /* its a proxy text piece (see above for definitions */
      nextParseOffset = INTWinProxyStringPiece(&proxyString[nextParseOffset],
						 scrollOffset, mode);
a216 1
  MemHandleUnlock(hText);
d220 1
a220 1
SWord INTWinProxyStringPiece(char *startPoint, int scrollOffset, int mode)
d222 3
a224 2
  /* function also deals with frags internally */
  int currParseLoc;
a225 2
  int currYPosOffset = -scrollOffset;
  SWord forwardOffset, backOffset;
d227 1
a227 40
  SWord attributes;

  SWord winXextent, winYextent;

  backOffset = (SWord) startPoint[0];
  forwardOffset = (SWord) startPoint [2];
  startXPos = (SWord) startPoint[4];
  startYPos = (SWord) startPoint[6];
  attributes = (SWord) startPoint[8];
  currParseLoc = 10; /* move it to the next read pos */

  /* internal preprocessing of window attributes */
  WinDisplayToWindowPt(&startXPos, &startYPos);
  WinGetWindowExtent(&winXextent, &winYextent);

  /* processing of display attributes except underline*/
  if (attributes &= BOLD) {
    FntSetFont(boldFont);
  }
  else if (attributes &= ITALIC) {
    /* Currently unsupported */
  }
  else if (attributes &= FONT_MASK) {
    if ((attributes &= FONT_MASK) == FONT_STD) {
      FntSetFont(stdFont);
    }
    else if ((attributes &= FONT_MASK) == FONT_BIG1) {
      FntSetFont(largeFont);
    }
    else if ((attributes &= FONT_MASK) == FONT_BIG2) {
      /* Currently unsupported */
    }
    else if ((attributes &= FONT_MASK) == FONT_BIG3) {
      /* currently unsupported */
    }
  }
  /* this attribute is independent on the pilot */
  if (attributes &= UNDERLINE) {
    WinSetUnderlineMode(grayUnderline);
  }
d229 4
d234 1
a234 2
    /* this part would by INTWinProxyStringFrag, but it's rolled in */
    currFragLen = startPoint[currParseLoc];
d236 2
a237 3
    /* is there any more to draw and is there still room on screen? */
    if (currFragLen == 0 || currYPosOffset > winYextent) {
      /* no */
d240 1
a240 2
    else {
      /* yes, so its a proxy string frag */      
d242 5
a246 5

      if (mode) {
	/* erase mode */
	WinEraseChars(&startPoint[currParseLoc], (Word) currFragLen, 
		      startXPos, startYPos + currYPosOffset);
d249 1
a249 3
	/* draw mode */
	WinDrawChars(&startPoint[currParseLoc], (Word) currFragLen, 
		     startXPos, startYPos + currYPosOffset);
d254 1
a254 1
	currParseLoc += (currFragLen + 2) /* move it to the next read pos */;
d257 1
a257 1
	currParseLoc += (currFragLen + 3) /* move it to the next read pos */;
d261 1
a261 1
      currYPosOffset += FntLineHeight();
d264 1
a264 4
  /* clean up */
  FntSetFont(stdFont);
  WinSetUnderlineMode(noUnderline);
  return currParseLoc + 2; /* move it to the next read pos */
a265 1

@
