head	1.43;
access;
symbols
	Yatin-final:1.41.2.2
	Yatin:1.41.0.2
	pre-yatin-merge:1.41
	transend-beta2:1.33
	fox-dev:1.33.2.1
	ptm-ng:1.31
	transend-beta-latest:1.31
	Aggregators:1.31
	NoAggregators:1.31
	iang:1.31.0.2
	transend-beta:1.30.0.2
	SOSP:1.27
	stable_ptm:1.19
	merged_preintegrate:1.11
	heisenbug:1.10
	PRE_INTEGRATION:1.10
	initial:1.1.1.1
	initial:1.1.1;
locks; strict;
comment	@// @;


1.43
date	98.02.12.01.32.29;	author fox;	state Exp;
branches;
next	1.42;

1.42
date	98.01.16.22.16.20;	author yatin;	state Exp;
branches;
next	1.41;

1.41
date	97.09.24.00.30.48;	author yatin;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	97.09.18.22.45.23;	author yatin;	state Exp;
branches;
next	1.39;

1.39
date	97.09.15.03.09.36;	author yatin;	state Exp;
branches;
next	1.38;

1.38
date	97.09.10.23.26.44;	author yatin;	state Exp;
branches;
next	1.37;

1.37
date	97.09.10.06.08.45;	author gribble;	state Exp;
branches;
next	1.36;

1.36
date	97.09.09.23.43.44;	author gribble;	state Exp;
branches;
next	1.35;

1.35
date	97.09.05.01.26.27;	author gribble;	state Exp;
branches;
next	1.34;

1.34
date	97.08.30.21.34.45;	author fox;	state Exp;
branches;
next	1.33;

1.33
date	97.06.23.04.06.02;	author fox;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	97.06.14.05.05.46;	author yatin;	state Exp;
branches;
next	1.31;

1.31
date	97.04.28.18.46.41;	author yatin;	state Exp;
branches;
next	1.30;

1.30
date	97.04.18.19.36.28;	author yatin;	state Exp;
branches;
next	1.29;

1.29
date	97.04.18.19.26.44;	author yatin;	state Exp;
branches;
next	1.28;

1.28
date	97.03.18.01.00.03;	author yatin;	state Exp;
branches;
next	1.27;

1.27
date	97.03.09.05.51.05;	author yatin;	state Exp;
branches;
next	1.26;

1.26
date	97.03.06.05.42.43;	author yatin;	state Exp;
branches;
next	1.25;

1.25
date	97.03.06.03.22.24;	author yatin;	state Exp;
branches;
next	1.24;

1.24
date	97.03.06.02.49.17;	author yatin;	state Exp;
branches;
next	1.23;

1.23
date	97.03.04.17.59.25;	author yatin;	state Exp;
branches;
next	1.22;

1.22
date	97.02.27.01.13.58;	author yatin;	state Exp;
branches;
next	1.21;

1.21
date	97.02.26.04.15.02;	author yatin;	state Exp;
branches;
next	1.20;

1.20
date	97.02.17.03.01.16;	author yatin;	state Exp;
branches;
next	1.19;

1.19
date	97.02.08.02.14.01;	author yatin;	state Exp;
branches;
next	1.18;

1.18
date	97.02.07.21.54.51;	author yatin;	state Exp;
branches;
next	1.17;

1.17
date	97.02.05.20.20.52;	author yatin;	state Exp;
branches;
next	1.16;

1.16
date	97.02.05.05.34.45;	author gribble;	state Exp;
branches;
next	1.15;

1.15
date	97.01.29.23.26.12;	author yatin;	state Exp;
branches;
next	1.14;

1.14
date	97.01.29.06.00.52;	author yatin;	state Exp;
branches;
next	1.13;

1.13
date	97.01.29.00.22.01;	author yatin;	state Exp;
branches;
next	1.12;

1.12
date	97.01.04.09.55.42;	author yatin;	state Exp;
branches;
next	1.11;

1.11
date	96.12.15.13.46.37;	author yatin;	state Exp;
branches;
next	1.10;

1.10
date	96.12.05.01.27.19;	author yatin;	state Exp;
branches;
next	1.9;

1.9
date	96.11.24.08.12.19;	author yatin;	state Exp;
branches;
next	1.8;

1.8
date	96.11.23.06.03.23;	author yatin;	state Exp;
branches;
next	1.7;

1.7
date	96.11.22.09.42.47;	author yatin;	state Exp;
branches;
next	1.6;

1.6
date	96.11.22.08.21.37;	author yatin;	state Exp;
branches;
next	1.5;

1.5
date	96.11.22.00.42.28;	author yatin;	state Exp;
branches;
next	1.4;

1.4
date	96.11.15.00.37.32;	author yatin;	state Exp;
branches;
next	1.3;

1.3
date	96.11.08.21.27.52;	author yatin;	state Exp;
branches;
next	1.2;

1.2
date	96.11.06.23.42.47;	author yatin;	state Exp;
branches;
next	1.1;

1.1
date	96.10.25.00.39.41;	author yatin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.25.00.39.41;	author yatin;	state Exp;
branches;
next	;

1.33.2.1
date	97.08.15.07.02.59;	author fox;	state Exp;
branches;
next	;

1.41.2.1
date	97.11.17.22.07.04;	author yatin;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	97.12.01.22.19.33;	author iang;	state Exp;
branches;
next	;


desc
@@


1.43
log
@modified distiller error messages to begin with HTTP-like 3-digit numeric status; made distBadInput be an informational rather than error message
@
text
@#include "log.h"
#include "distdb.h"
#include "cacheman.h"
#include "cachenet.h"
#include "cache.h"
#include "reqrep.h"
#include "threads.h"
#include "proxyinterface.h"
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


CacheManager* CacheManager::instance=NULL;

CacheManager::CacheManager(OptionDatabase *options_, const char *monitorUnitID)
  : evs(NULL), 
    ptmConnection_(NULL), 
    bus(NULL),
    managerThread(NULL),
    cache(NULL),
    monitorClient(NULL),
    noBeaconTimer(NULL),
    options(options_),
    mgrMutex("*-mgr"),
    ptmFoundMutex("*-ptm-found")
{
  // expand options in the options database
  // install default options if required
  if (ExpandOptions(options_)==gm_False) return;

  const char *monitorAddr;
  Port monitorPort;
  int  monitorTTL;

  // initialize the random number generator
  timeval now;
  gettimeofday(&now, NULL);
  srand48(now.tv_usec + getpid());

  // create objects
  instance = this;
  NEW(cache, DistillerCache);
  NEW(evs,   RequestReplyEventSystem);
  NEW(managerThread, Thread);

  // initialize the remote executor
  if (rexec.Initialize(options->Find(Opt_Rsh), options->Find(Opt_RshArgs),
		       options->Find(Opt_Hosts))
      ==gm_False) return;

  // initialize the multicast socket
  NEW(bus, SharedBus(evs, options->Find(Opt_PTMMulticast_IP),
		     (Port) options->FindUINT32(Opt_PTMMulticast_port),
		     (int)  options->FindUINT32(Opt_PTMMulticast_TTL)));

  // initialize timers
  UINT32 beaconingPeriod_ms = options->FindUINT32(Opt_PTMBeacon_ms);
  if (beaconingPeriod_ms==0) beaconingPeriod_ms = DefaultBeaconingPeriod_ms;
  UINT32 lostBeacons = options->FindUINT32(Opt_LostBeacons);
  if (lostBeacons==0) lostBeacons = DefaultLostBeacons;
  UINT32 noBeaconTimeout = lostBeacons*beaconingPeriod_ms;
  NEW(noBeaconTimer, NoBeaconTimer(evs, noBeaconTimeout));
  startPTMTimer.Initialize(noBeaconTimeout);

  // initialize the monitor
  monitorAddr = options->Find(Opt_MonitorMulticast_IP);
  monitorPort = (Port) options->FindUINT32(Opt_MonitorMulticast_port);
  monitorTTL  = (int)  options->FindUINT32(Opt_MonitorMulticast_TTL);
  if (monitorAddr!=NULL && *monitorAddr!='\0') {
    char unitID[256];
    char myName[256], *ptr;

    if (monitorUnitID==NULL) {
      if (CommunicationObject::GetHostName(myName)==gm_False) return;
      if ((ptr = strchr(myName, '.'))!=NULL) *ptr = '\0';
      sprintf(unitID, "Front End (%s - %ld)", myName, (long)getpid());
      monitorUnitID = unitID;
    }
    monitorClient = new MonitorClient(monitorUnitID, monitorAddr, monitorPort, 
				      monitorTTL);
    if (monitorClient==NULL) VoidReturn(errOutOfMemory);
    if (Error::getStatus()!=success) return;

    SetRemoteLogging(monitorClient);
  }
  else {
    SetStderrLogging("Front end: ");
  }


  gm_Log("Initialized Distiller cache with following parameters:\n"
	 << "    Options file: " << options->Find(Opt_OptionsFile) << '\n'
	 << "    PTM executable: " << options->Find(Opt_PTMExecutable) << '\n'
	 << "    PTM beaconing interval: " 
	 << options->FindUINT32(Opt_PTMBeacon_ms) << '\n'
	 << "    Lost beacon count: " << options->FindUINT32(Opt_LostBeacons)
	 <<'\n');

  
  RemoteID unicast;
  gm_Bool connectSucceeded = gm_False;
  const char *unicastIP;

  unicastIP = options->Find(Opt_PTMUnicast_IP);
  if (unicastIP!=NULL) strcpy(unicast.ipAddress, unicastIP);
  else strcpy(unicast.ipAddress, "");
  unicast.port = options->FindUINT32(Opt_PTMUnicast_port);
  
  if (*unicast.ipAddress!='\0' && unicast.port!=0) {
    // we have an IP address to connect to
    if (EvPTMLocationReceived__(unicast)==gm_True) {
      // we were successful in connecting to the PTM
      connectSucceeded = gm_True;
    }
  }

  if (connectSucceeded==gm_False) {
    // we were never connected to the PTM; we must try to start it up if 
    // necessary
    if (EvPTMConnectionLost__()==gm_False) {
      // could not initialize timers for restarting the PTM
      return;
    }
    gm_Log("Trying to listen for new PTM address\n");
  }
  else {
    gm_Log("Successfully connected to the PTM at " << unicast.ipAddress
	   << "/" << unicast.port << "\n");
  }

  managerThread->Fork(ForkHelper, (void*)this);
}


CacheManager::~CacheManager()
{
  DELETE(cache);
  if (bus!=NULL) {
    //evs->RemoveCommunicationObject(bus->getListener());
    delete bus;
    bus = NULL;
  }
  if (ptmConnection_!=NULL) {
    //evs->RemoveCommunicationObject(ptmConnection_);
    ptmConnection_->MarkForDeletion();
    ptmConnection_ = NULL;
  }
  DELETE(managerThread);	// I don't think this actually kills the thread
				// I might want to explicitly kill it first
  DELETE(evs);
  DELETE(monitorClient);
}



gm_Bool
CacheManager::ExpandOptions(OptionDatabase *optDB)
{
  const char *value;
  char *slash1, *slash2;

  if (optDB->Find(Opt_PTMExecutable)==NULL) {
    if (optDB->Add(Opt_PTMExecutable, DefaultPTMExecutable)==gm_False) 
      return gm_False;
  }

  value = optDB->Find(Opt_PTMMulticast);
  if (value==NULL) {
    optDB->Add(Opt_PTMMulticast_IP,   DefaultMulticastAddress);
    optDB->Add(Opt_PTMMulticast_port, DefaultMulticastPort);
    optDB->Add(Opt_PTMMulticast_TTL,  DefaultTTL);
  }
  else {
    RemoteID multicast;
    int ttl;

    slash1 = strchr(value, '/');
    if (slash1==NULL || slash1==value) Return(gm_False, errFormattingError);

    if (slash1 >= value + MAXIP) Return(gm_False, errBufferOverflow);
    strncpy(multicast.ipAddress, value, slash1-value);
    multicast.ipAddress[slash1-value] = '\0';
    
    slash2 = strchr(slash1+1, '/');
    if (slash2==NULL) {
      multicast.port = atoi(slash1+1);
      if (multicast.port==0) Return(gm_False, errFormattingError);
      ttl = DefaultTTL;
    }
    else {
      if (sscanf(slash1+1, "%d/%d", &multicast.port, &ttl)!=2) 
	Return(gm_False, errFormattingError);
      if (multicast.port==0 || ttl==0) Return(gm_False, errFormattingError);
    }
    optDB->Add(Opt_PTMMulticast_IP,   multicast.ipAddress);
    optDB->Add(Opt_PTMMulticast_port, (UINT32) multicast.port);
    optDB->Add(Opt_PTMMulticast_TTL,  (UINT32) ttl);
  }

  value = optDB->Find(Opt_MonitorMulticast);
  if (value==NULL) {
    optDB->Add(Opt_MonitorMulticast_IP,   DefaultMonitorAddress);
    optDB->Add(Opt_MonitorMulticast_port, DefaultMonitorPort);
    optDB->Add(Opt_MonitorMulticast_TTL,  DefaultTTL);
  }
  else if (*value=='\0') {
    // we have explicitly mentioned that we don't want to use a monitor
    // All log messages will be output to stderr
    optDB->Add(Opt_MonitorMulticast_IP,   "");
    optDB->Add(Opt_MonitorMulticast_port, (UINT32)-1);
    optDB->Add(Opt_MonitorMulticast_TTL,  (UINT32)-1);
  }
  else {
    RemoteID multicast;
    int ttl;

    slash1 = strchr(value, '/');
    if (slash1==NULL || slash1==value) Return(gm_False, errFormattingError);

    if (slash1 >= value + MAXIP) Return(gm_False, errBufferOverflow);
    strncpy(multicast.ipAddress, value, slash1-value);
    multicast.ipAddress[slash1-value] = '\0';
    
    slash2 = strchr(slash1+1, '/');
    if (slash2==NULL) {
      multicast.port = atoi(slash1+1);
      if (multicast.port==0) Return(gm_False, errFormattingError);
      ttl = DefaultTTL;
    }
    else {
      if (sscanf(slash1+1, "%d/%d", &multicast.port, &ttl)!=2) 
	Return(gm_False, errFormattingError);
      if (multicast.port==0 || ttl==0) Return(gm_False, errFormattingError);
    }
    optDB->Add(Opt_MonitorMulticast_IP,   multicast.ipAddress);
    optDB->Add(Opt_MonitorMulticast_port, (UINT32) multicast.port);
    optDB->Add(Opt_MonitorMulticast_TTL,  (UINT32) ttl);
  }

  if (optDB->Find(Opt_DistillerDB)==NULL) {
    if (optDB->Add(Opt_DistillerDB, DefaultDistillerDB)==gm_False) 
      return gm_False;
  }
  if (optDB->Find(Opt_Rsh)==NULL) {
    if (optDB->Add(Opt_Rsh, DefaultRsh)==gm_False)
      return gm_False;
  }
  if (optDB->Find(Opt_RshArgs)==NULL) {
    if (optDB->Add(Opt_RshArgs, DefaultRshArgs)==gm_False)
      return gm_False;
  }
  if (optDB->Find(Opt_Hosts)==NULL) {
    // default hosts is myself
    char myself[256];
    if (CommunicationObject::GetHostName(myself)==gm_False) return gm_False;
    if (optDB->Add(Opt_Hosts, myself)==gm_False)
      return gm_False;
  }
  if (optDB->Find(Opt_PTMBeacon_ms)==NULL) {
    if (optDB->Add(Opt_PTMBeacon_ms, DefaultBeaconingPeriod_ms)==gm_False)
      return gm_False;
  }
  if (optDB->Find(Opt_LostBeacons)==NULL) {
    if (optDB->Add(Opt_LostBeacons, DefaultLostBeacons)==gm_False)
      return gm_False;
  }
  return gm_True;
}


gm_Bool
CacheManager::ConnectToPTM_(RemoteID &ptmAddress_)
{
  ptmConnection_ = new FE_PTMConnection(evs);
  if (ptmConnection_==NULL) Return(gm_False, errOutOfMemory);
  if (ptmConnection_->Connect(ptmAddress_.ipAddress, 
			      ptmAddress_.port)==gm_False){
    ptmConnection_->MarkForDeletion();
    ptmConnection_ = NULL;
    return gm_False;
  }

  /*if (evs->AddCommunicationObject(ptmConnection_)==gm_False) {
    ptmConnection_->MarkForDeletion();
    ptmConnection_ = NULL;
    return gm_False;
  }*/

  return gm_True;
}


gm_Bool
CacheManager::ClosePTMConnection__()
{
  gm_Log("PTM connection lost; trying to listen for new PTM address\n");
  mgrMutex.Lock();

  if (ptmConnection_!=NULL) {
    //evs->RemoveCommunicationObject(ptmConnection_);
    ptmConnection_->MarkForDeletion();
    ptmConnection_ = NULL;
    if (EvPTMConnectionLost_()==gm_False) {
      mgrMutex.Unlock();
      return gm_False;
    }
  }

  mgrMutex.Unlock();
  return gm_True;
}


gm_Bool
CacheManager::NoBeaconTimer::EvTimer(EventSystem */*evs*/)
{
  if (beaconRecvd==gm_False 
      && CacheManager::getInstance()->IsConnectedToPTM__()==gm_True) {

    if (askedForUnicastBeacon==gm_True) {
      // i have already asked for a unicast beacon
      // looks like I didn't get any! so PTM must be dead

      askedForUnicastBeacon = gm_False;
      return CacheManager::getInstance()->ClosePTMConnection__();
    }
    else {
      // before saying that I have lost the PTM connection, I should try to
      // ask for a private beacon via TCP
      gm_Log("Asking for unicast beacon packet from the PTM\n");
      if (CacheManager::getInstance()->AskPTMForUnicastBeacon()==gm_False) {
	// I couldn't send the packet to the PTM; it must be dead
	return CacheManager::getInstance()->ClosePTMConnection__();
      }
      else
	askedForUnicastBeacon = gm_True;
    }
  }
  else {
    // I have received a beacon some time in the last interval
    // so I'm still connected
    // reset the beaconRecvd flag

    beaconRecvd = gm_True;
    askedForUnicastBeacon = gm_False;
  }

  return gm_True;
}


gm_Bool
CacheManager::EvPTMLocationReceived__(RemoteID &newPtmAddress)
{
  noBeaconTimer->EvBeaconReceived(evs);

  mgrMutex.Lock();
  if (IsConnectedToPTM_()==gm_True) {
    // PTM connection already exists; ignore this beacon
    mgrMutex.Unlock();
    return gm_True;
  }

  gm_Log("Found PTM at " << newPtmAddress.ipAddress << '/' 
	<< newPtmAddress.port << '\n');
  
  if (ConnectToPTM_(newPtmAddress)==gm_False) {
    // only errOutOfMemory is a real error
    if (Error::getStatus()==errOutOfMemory) {
      mgrMutex.Unlock();
      return gm_False;
    }
    gm_Log("Could not connect. Ignoring new location\n");
    Error::Print();
    Error::SetStatus(success);
  }

  // flush the negative cache!
  FlushNCache();

  // disable the startPTMTimer
  startPTMTimer.Disable();

  // signal the waiting guy that a PTM has been found
  ptmFoundMutex.Lock();
  ptmFoundCond.Broadcast();
  ptmFoundMutex.Unlock();

  mgrMutex.Unlock();
  return gm_True;
}


void
CacheManager::WaitForPTM__()
{
  ptmFoundMutex.Lock();
  if (ptmConnection_!=NULL) {
    ptmFoundMutex.Unlock();
    return;
  }

  if (ptmFoundCond.Wait(&ptmFoundMutex)==gm_False) {
    Error::Print();
  }

  ptmFoundMutex.Unlock();
}


gm_Bool 
CacheManager::EvPTMConnectionLost_()
{
  ptmConnection_ = NULL;
  gm_Bool retval = startPTMTimer.NewTimer(evs);
  return retval;
}


UINT32
StartPTMTimer::RandomDelay()
{
  return timeout_ms + (lrand48()%NoPTMRandom_ms);
}


gm_Bool
StartPTMTimer::EvTimer(EventSystem *evs)
{
  // don't need a lock here because NetTimer() grabs the lock
  if (NewTimer(evs)==gm_False) return gm_False;
  return CacheManager::getInstance()->StartPTM__();
}


gm_Bool
CacheManager::RestartPTMTimer__()
{
  mgrMutex.Lock();
  gm_Bool returnValue = startPTMTimer.NewTimer(evs);
  mgrMutex.Unlock();
  return returnValue;
}


gm_Bool
CacheManager::StartPTM__()
{
  const char *ptmExecutableName;

  mgrMutex.Lock();

  /*
   * first notify everyone that I'm about to start the PTM
   */
  gm_Packet packet(pktWillStartPTM, 0, 0);
  if (bus->getSender()->Write(&packet)==gm_False) {
    mgrMutex.Unlock();
    return gm_False;
  }


  ptmExecutableName = options->Find(Opt_PTMExecutable);
  if (ptmExecutableName==NULL || *ptmExecutableName=='\0') {
    mgrMutex.Unlock();
    Return(gm_False, errCouldNotLaunch);
  }

  gm_Log("Timed out while waiting for PTM; trying to start " 
	 << ptmExecutableName << '\n');
  
  char *argv[] = {
    (char*) ptmExecutableName,
    "-o",
    (char*) options->Find(Opt_OptionsFile),
    NULL
  };
  
  if (rexec.Exec(*argv, argv)==gm_False) {
    mgrMutex.Unlock();
    return gm_False;
  }

  mgrMutex.Unlock();
  return gm_True;
}


gm_Bool
CacheManager::AskPTMForDistiller__(DistillerType *type, 
				   AskForDistillerStatus &status)
{
  FE_PTMConnection *conn;
  mgrMutex.Lock();
  if (IsConnectedToPTM_()==gm_False) {
    status = ptmNoPTM;
    mgrMutex.Unlock();
    return gm_False;
  }
  
  conn = ptmConnection_;
  conn->IncrReference();
  mgrMutex.Unlock();
  AskForDistiller askRequest(evs);
  if (askRequest.SendAndWait(conn, type)==gm_False) {
    conn->DecrReference();
    return gm_False;
  }
  conn->DecrReference();
  status = askRequest.Status();
  char buf[100];
  sprintf(buf, "got reply from PTM: %d", status);
  Mutex::Log_(buf, "", NULL);
  return (status==ptmOk) ? gm_True : gm_False;
}


gm_Bool
CacheManager::AskForDistiller::SendAndWait(FE_PTMConnection *connection,
					   DistillerType *type)
{
  mutex.Lock();


  OStream stream;
  stream << (*type);
  if (stream.IsGood()==gm_False) {
    mutex.Unlock();
    return gm_False;
  }
  
  gm_Packet packet(pktAskForDistiller, stream.getLength(), getID(),
		stream.getData());
  
  if (connection->Write(&packet)==gm_False) {
    if (Error::getStatus()==errOutOfMemory) {
      mutex.Unlock();
      return gm_False;
    }

    // any other error means the connection is down
    Error::SetStatus(success);
    gm_Bool returnValue = connection->
      EvConnectionBroken(CacheManager::getInstance()->getEventSystem());
    mutex.Unlock();
    return returnValue;
  }

  condition.Wait(&mutex);
  mutex.Unlock();
  return gm_True;
}


gm_Bool
CacheManager::AskForDistiller::EvReplyReceived(RequestReplyEventSystem *,
					       void *args)
{
  mutex.Lock();
  status = (AskForDistillerStatus) args;
  condition.Signal();
  mutex.Unlock();
  return gm_True;
}


gm_Bool
CacheManager::AskForDistiller::EvTimer(RequestReplyEventSystem */*evs*/)
{
  mutex.Lock();
  status = ptmAskForDistillerTimeout;
  condition.Signal();
  mutex.Unlock();
  return gm_True;
}


void
CacheManager::Main()
{
  if (evs->Run()==gm_False) {
    Abort("Fatal cache-manager error");
  }
  gm_Log("Cache Manager has quit. This shouldn't have happened\n");

  monitorClient->Gasp(0);
  DELETE(instance);
}


void*
CacheManager::ForkHelper(void *args)
{
  ((CacheManager*)args)->Main();
  return 0;
}


gm_Bool
CacheManager::CreateInstance(OptionDatabase *options, 
			     const char *monitorUnitID)
{
  instance = new CacheManager(options, monitorUnitID);
  if (instance==NULL) Return(gm_False, errOutOfMemory);
  if (Error::getStatus()!=success) return gm_False;

  //signal(SIGINT, CtlCPressed);
  return gm_True;
}


void
CacheManager::CtlCPressed(int /*sig*/)
{
  Abort("Ctl-C pressed");
}


void
CacheManager::Abort(const char *string)
{
  gm_Log("Aborting program: " << string << "\n\n");
  Error::Print();

  //if (instance!=NULL) delete instance;
  getInstance()->getMonitorClient()->Gasp(0);
  exit(-1);
}


gm_Bool
InitializeDistillerCache(Options options, const char *monitorUnitID)
{
  gm_Bool returnValue;
  Debug_::getInstance()->Initialize("et", "PTM stub: ");
  //Mutex::log_file = "/disks/barad-dur/roboline/yatin/mutex.log";
  returnValue = CacheManager::CreateInstance((OptionDatabase*)options, 
					     monitorUnitID);
  if (returnValue==gm_False) {
    gm_Log("Could not initialize the Distiller Cache\n");
    Error::Print();
  }
  return returnValue;
}


DistillerStatus
Distill(C_DistillerType *type,  Argument *args, int numberOfArgs,
	DistillerInput  *input, DistillerOutput *output)
{
  DistillerType distType(*type);

  Mutex::Log_("entering Distill()", "", NULL);
  output->data.data = NULL;
  output->data.length = 0;
  strcpy(output->mimeType, input->mimeType);

  if (CacheManager::getInstance()==NULL) return distNoCacheManager;
  DistillerStatus returnValue = 
    CacheManager::getInstance()->Distill(&distType, args, numberOfArgs, 
					 input, output);

  if (returnValue!=distOk && returnValue!=distDistillerNotFound) {
    gm_Log("Error " << returnValue << " (" << type->string << "): " 
	   << FE_getDistillerStatusString(returnValue) << "\n");
  }

  Mutex::Log_("leaving Distill()", "", NULL);
  return returnValue;
}

DistillerStatus
DistillAsync(C_DistillerType *type,  Argument *args, int numberOfArgs,
	DistillerInput  *input, DistillerRequestType *request)
{
  DistillerType distType(*type);
  DistillerRequest *newrequest = (DistillerRequest *)*request;

  Mutex::Log_("entering DistillAsync()", "", NULL);

  if (CacheManager::getInstance()==NULL) return distNoCacheManager;
  DistillerStatus returnValue = 
    CacheManager::getInstance()->DistillAsync(&distType, args, numberOfArgs, 
					 input, newrequest);

  if (returnValue!=distOk && returnValue!=distDistillerNotFound) {
    gm_Log("Error " << returnValue << " (" << type->string << "): " 
	   << FE_getDistillerStatusString(returnValue) << "\n");
  }

  Mutex::Log_("leaving Distill()", "", NULL);
  *request = newrequest;
  return returnValue;
}

DistillerStatus
DistillRendezvous(DistillerRequestType *request, DistillerOutput *output,
    struct timeval *tv)
{
    output->data.data = NULL;
    output->data.length = 0;
    output->mimeType[0] = '\0';

    DistillerStatus status = distFatalError;
    if (!request) return status;
    CacheManager *inst = CacheManager::getInstance();
    DistillerRequest *newrequest = (DistillerRequest *)*request;
    if (!newrequest) return status;
    if (inst) {
	status = inst->DistillRendezvous(newrequest, output, tv);
    } else {
	return distNoCacheManager;
    }
    *request = newrequest;
    return status;
}

void DistillDestroy(DistillerRequestType *request)
{
    if (!request) return;
    CacheManager *inst = CacheManager::getInstance();
    DistillerRequest *newrequest = (DistillerRequest *)*request;
    if (inst) {
	inst->DistillDestroy(newrequest);
    }
    *request = newrequest;
}

const char *
FE_getDistillerStatusString(DistillerStatus status)
{
  static const char * const array [] = {
    "200 Distiller ok",		// distOk
    "401 InitializeDistillerCache() not invoked at proxy frontend or "
    "DistillerCache thread has exited",      /* distNoCacheManager */
    "101 Could not locate distiller",            /* distDistillerNotFound */
    "402 Error sending data to distiller",       /* distSendError */
    "403 Timed out while waiting for distiller", /* distReplyTimeout */
    "501 Out of memory at the frontend",         /* distOutOfLocalMemory */
    "404 Connection to distiller was broken",    /* distConnectionBroken */
    "405 Timed out while waiting for PTM to launch a new distiller", 
                                             /* distLaunchTimeout */
    "102 Unrecoverable error occurred in distiller",/* distFatalError */
    "103 Bad input to distiller",                   /* distBadInput */
    "104 Redispatch needed (chained distill)",      /* distRedispatch */
#ifdef whaaaa
    "Asynchronously queue fetches"              /* distAsyncBegin */
#endif
    "406 Rendezvous timeout"                     /* distRendezvousTimeout */
  };

  if (status >= sizeof(array)/sizeof(const char *))
    return "Unknown error";
  return array[status];
}


const char*
FE_GetMonitorClientUnitID()
{
  return CacheManager::getInstance()->getMonitorClient()->getUnitID();
}



/*void
FreeOutputBuffer(DistillerOutput *output)
{
  if (output->data!=NULL) delete [] ((char*)output->data);
}*/


void
WaitForPTM()
{
  CacheManager::getInstance()->WaitForPTM__();
}








DistillerStatus
CacheManager::Distill(DistillerType *type, Argument *args, int numberOfArgs,
		      DistillerInput *input, DistillerOutput *output)
  // if connection fails between send and reply, then this function returns
  // an error; perform the retry option at a higher level function
{
  DistillerStatus status;
  CachedDistiller *distiller;

  while (gm_True) {
    //set_thread_state(THR_DISTCACHE);
    distiller = cache->getDistiller(type, status);
    if (distiller==NULL) return status;

    // got a real distiller; its ref count has already been incremented
    // remember to decrement it when you're done
    status = distiller->Distill(args, numberOfArgs, input, output);
    distiller->DecrPendingCount();
    if (status!=distSendError) {
      distiller->DecrReference();
      return status;
    }

    gm_Log("Problems connecting to distiller\n");
    cache->Remove__(distiller);
    distiller->MarkForDeletion();
    distiller->DecrReference();
  }
  // never reached! 
  // added the return statement to prevent the compiler from generating a 
  // warning
  return distOk;
}

DistillerStatus
CacheManager::DistillAsync(DistillerType *type, Argument *args,
			    int numberOfArgs, DistillerInput *input,
			    DistillerRequest *& newrequest)
{
  DistillerStatus status;
  CachedDistiller *distiller;
  int i;

  for (i=0;i<5;++i) {
    //set_thread_state(THR_DISTCACHE);
    distiller = cache->getDistiller(type, status);
    if (distiller==NULL) return status;

    // got a real distiller; its ref count has already been incremented
    // remember to decrement it when you're done
    status = distiller->DistillAsync(args, numberOfArgs, input, newrequest);
    if (status == distSendError) {
	distiller->DecrPendingCount();
	gm_Log("Problems connecting to distiller\n");
	cache->Remove__(distiller);
	distiller->MarkForDeletion();
	distiller->DecrReference();
    } else {
	break;
    }
  }
  return status;
}

DistillerStatus
CacheManager::DistillRendezvous(DistillerRequest *& newrequest,
    DistillerOutput *output, struct timeval *tv)
{
    gm_Bool waitres;
    waitres = newrequest->Wait(tv);
    if (!waitres) {
	return distRendezvousTimeout;
    }
    *output = * (newrequest->getOutput());
    newrequest->getOutput()->DontFreeMe();
    DistillerStatus retval = newrequest->getStatus();
    DistillDestroy(newrequest);
    return retval;
}

void
CacheManager::DistillDestroy(DistillerRequest *& newrequest)
{
    newrequest->Destroy();
    delete newrequest;
    newrequest = NULL;
}
@


1.42
log
@- new wingman frontend
- new wingman aggregators mechanism
- DistillAsync

(merged from branch Yatin-final)
@
text
@d737 2
a738 2
    "Distiller ok",		// distOk
    "InitializeDistillerCache() not invoked at proxy frontend or "
d740 6
a745 6
    "Could not locate distiller",            /* distDistillerNotFound */
    "Error sending data to distiller",       /* distSendError */
    "Timed out while waiting for distiller", /* distReplyTimeout */
    "Out of memory at the frontend",         /* distOutOfLocalMemory */
    "Connection to distiller was broken",    /* distConnectionBroken */
    "Timed out while waiting for PTM to launch a new distiller", 
d747 3
a749 3
    "Unrecoverable error occurred in distiller",/* distFatalError */
    "Bad input to distiller",                   /* distBadInput */
    "Redispatch needed (chained distill)",      /* distRedispatch */
d753 1
a753 1
    "Rendezvous timeout"                     /* distRendezvousTimeout */
@


1.41
log
@the distiller InitializeDistillerCache() function call should know
about the PTM's unicast location. Fixed that
@
text
@d302 1
d419 2
a420 1
  return startPTMTimer.NewTimer(evs);
d676 56
d750 1
d752 2
d824 53
@


1.41.2.1
log
@- Modularized the wingman frontend by splitting wing_go_proc into
  multiple smaller functions

- New aggregator mechanism for wingman proxies. The WingDispatch worker
  receives a request with a special content-type application/x-wingman-agg.
  The body of the request contains the full aggregator url

  The worker should return a valid HTTP response, which might be a
  pilot-ready document (i.e. an x-wingman/* document) or an HTTP
  redirect to a new URL, or whatever it chooses!)

- The WingDispatcher is now expected to weed out unintelligible content-types
  and return a content-type of x-wingman/<integer> to the frontend, where
  <integer> represents the integral content type returned to the pilot client.

- Agglist: this appears at the dispatcher as a special aggregator request
  with a url of agg://agglist/ (this URL is actually defined in the
  gm_options file, so the worker should check against the gm_options
  entry, rather than a hard-coded entry). The worker that handles this
  request *MUST* return a document with content type
  x-wingman/2 and the actual agglist as part of the data.

  For old browsers, the data part of this response is stuffed into an
  appropriate metadata field by the frontend before sending the reply to
  the client (i.e. it is backward compatible). For browsers with the new
  version number, the browser will no longer set any special flags in the
  metadata field of the client request. Instead it will explicitly request
  for the agg://agglist/ url. It'll check the ContentType field in the
  response for content type 2 to match up the correct response.

- Created a new version number for the agglist changes:
  #define CLIENT_VERSION_NEWAGG 0x01050200

- gm_options changes:
  Here are the three new gm_options entries for wingman: (the
  wingman.text.prefetch_href replaces the old prefetch.href entry)

  wingman.about_url: http://www.isaac.cs.berkeley.edu/pilot/wingman/about-
  wingman.agglist_url: agg://agglist/
  wingman.text.prefetch_href: 10

- PTM changes:
  - Background distillers work. Specify the -e flag before the -- in the
    gm_options line for the distiller. The PTM will IMMEDIATELY respawn the
    distiller if it crashes. This mechanism is still very simple and naive
  - Distillers can rename themselves: API function DistillerReregister.
@
text
@a301 1

d418 1
a418 2
  gm_Bool retval = startPTMTimer.NewTimer(evs);
  return retval;
@


1.41.2.2
log
@Added DistillAsync and friends
@
text
@a675 56
DistillerStatus
DistillAsync(C_DistillerType *type,  Argument *args, int numberOfArgs,
	DistillerInput  *input, DistillerRequestType *request)
{
  DistillerType distType(*type);
  DistillerRequest *newrequest = (DistillerRequest *)*request;

  Mutex::Log_("entering DistillAsync()", "", NULL);

  if (CacheManager::getInstance()==NULL) return distNoCacheManager;
  DistillerStatus returnValue = 
    CacheManager::getInstance()->DistillAsync(&distType, args, numberOfArgs, 
					 input, newrequest);

  if (returnValue!=distOk && returnValue!=distDistillerNotFound) {
    gm_Log("Error " << returnValue << " (" << type->string << "): " 
	   << FE_getDistillerStatusString(returnValue) << "\n");
  }

  Mutex::Log_("leaving Distill()", "", NULL);
  *request = newrequest;
  return returnValue;
}

DistillerStatus
DistillRendezvous(DistillerRequestType *request, DistillerOutput *output,
    struct timeval *tv)
{
    output->data.data = NULL;
    output->data.length = 0;
    output->mimeType[0] = '\0';

    DistillerStatus status = distFatalError;
    if (!request) return status;
    CacheManager *inst = CacheManager::getInstance();
    DistillerRequest *newrequest = (DistillerRequest *)*request;
    if (!newrequest) return status;
    if (inst) {
	status = inst->DistillRendezvous(newrequest, output, tv);
    } else {
	return distNoCacheManager;
    }
    *request = newrequest;
    return status;
}

void DistillDestroy(DistillerRequestType *request)
{
    if (!request) return;
    CacheManager *inst = CacheManager::getInstance();
    DistillerRequest *newrequest = (DistillerRequest *)*request;
    if (inst) {
	inst->DistillDestroy(newrequest);
    }
    *request = newrequest;
}
a693 1
#ifdef whaaaa
a694 2
#endif
    "Rendezvous timeout"                     /* distRendezvousTimeout */
a764 53
DistillerStatus
CacheManager::DistillAsync(DistillerType *type, Argument *args,
			    int numberOfArgs, DistillerInput *input,
			    DistillerRequest *& newrequest)
{
  DistillerStatus status;
  CachedDistiller *distiller;
  int i;

  for (i=0;i<5;++i) {
    //set_thread_state(THR_DISTCACHE);
    distiller = cache->getDistiller(type, status);
    if (distiller==NULL) return status;

    // got a real distiller; its ref count has already been incremented
    // remember to decrement it when you're done
    status = distiller->DistillAsync(args, numberOfArgs, input, newrequest);
    if (status == distSendError) {
	distiller->DecrPendingCount();
	gm_Log("Problems connecting to distiller\n");
	cache->Remove__(distiller);
	distiller->MarkForDeletion();
	distiller->DecrReference();
    } else {
	break;
    }
  }
  return status;
}

DistillerStatus
CacheManager::DistillRendezvous(DistillerRequest *& newrequest,
    DistillerOutput *output, struct timeval *tv)
{
    gm_Bool waitres;
    waitres = newrequest->Wait(tv);
    if (!waitres) {
	return distRendezvousTimeout;
    }
    *output = * (newrequest->getOutput());
    newrequest->getOutput()->DontFreeMe();
    DistillerStatus retval = newrequest->getStatus();
    DistillDestroy(newrequest);
    return retval;
}

void
CacheManager::DistillDestroy(DistillerRequest *& newrequest)
{
    newrequest->Destroy();
    delete newrequest;
    newrequest = NULL;
}
@


1.40
log
@added mash_stub
mash_stub is compiled only if --with-mashdir flag is set
added a --enable/disable-mkdep flag to configure
configure can read default arguments from a special file .configure in
the toplevel tcsproxy directory
@
text
@d103 4
d108 11
a118 5
  // we were never connected to the PTM; we must try to start it up if 
  // necessary
  if (EvPTMConnectionLost__()==gm_False) {
    // could not initialize timers for restarting the PTM
    return;
d120 15
a134 1
  gm_Log("Trying to listen for new PTM address\n");
@


1.39
log
@PTM Changes:

* libdist.a now includes libptmstub.a. If you wish to invoke other
distillers from a distiller, you must call InitializeDistillerCache in
your DistillerInit method.

Please note that the arguments to InitializeDistillerCache have changed
slightly. Check out ptm/src/dist/distengine.c for an example of invoking
distillers from other distillers. I have updated the frontend to
reflect the change in arguments.

* DistillerMain times out after a certain time interval. The default
timeout is 60 seconds. You can override that on a per-distiller basis
through the gm_options file (See ahead).

* The "dist.blah:" line format has changed slightly. Here's the new
format:

dist.transend/foo/bar: sbin/foobar_munger <auto-launch-limit-ms> \
			<averaging-interval-ms> <distiller args ...> \
			-- <additional args>

Currently the auto-launch-limit-ms param is the max tolerable queue
length. Set it to zero if you want to disable auto-launching.

For both <auto-launch-limit-ms> and <averaging-interval-ms>, you can
specify - or 0 to use the built-in default value.

<distiller-args> can be any of the command line arguments that the
distiller can understand. Specifically you can use the -n argument to se
the notification timeout and -m to set the DistillerMain timeout.

Please update your gm_options file to the new format. Look at
gm_options.yatin for examples.


* The PTM Makefile does dependencies correctly (finally!!!). The
dependency file has been generated currently for Linux. If you are
compiling on a Solaris box, it might complain about not finding some of
the linux .h files. Simply run "make depend" in the ptm subdirectory on
your solaris box. Hopefully it'll work. If it doesn't work, comment out
the "source Makefile.depend" line from your Makefile.
@
text
@d434 1
a434 1
  Packet packet(pktWillStartPTM, 0, 0);
d510 1
a510 1
  Packet packet(pktAskForDistiller, stream.getLength(), getID(),
@


1.38
log
@bug fixes for the * character
@
text
@d19 1
a19 1
CacheManager::CacheManager(OptionDatabase *options_)
d76 8
a83 4
    if (CommunicationObject::GetHostName(myName)==gm_False) return;
    if ((ptr = strchr(myName, '.'))!=NULL) *ptr = '\0';
    sprintf(unitID, "Front End (%s - %ld)", myName, (long)getpid());
    monitorClient = new MonitorClient(unitID, monitorAddr, monitorPort, 
d254 1
a254 1
  ptmConnection_ = new PTMConnection(evs);
d471 1
a471 1
  PTMConnection *conn;
d497 1
a497 1
CacheManager::AskForDistiller::SendAndWait(PTMConnection *connection,
d578 2
a579 1
CacheManager::CreateInstance(OptionDatabase *options)
d581 1
a581 1
  instance = new CacheManager(options);
d610 1
a610 1
InitializeDistillerCache(Options options)
d613 1
a613 1
  Debug_::getInstance()->Initialize("et", "Front end: ");
d615 2
a616 1
  returnValue = CacheManager::CreateInstance((OptionDatabase*)options);
a737 12

extern "C" Argument *
getArgumentFromId(Argument *args, int numberOfArgs, UINT32 id)
{
  Argument *ptr;
  if (args==NULL) return NULL;
  for(ptr=args; ptr < args+numberOfArgs; ptr++) {
    if (ARG_ID(*ptr)==id) return ptr;
  }
  return NULL;
}

@


1.37
log
@fixed much badness reported by purify
@
text
@d612 1
a612 1
    gm_Log("Could not initialize the PTM\n");
@


1.36
log
@Much minor hackery....fixed a number of little things.
@
text
@d660 3
a662 1
    "Bad input to distiller"                    /* distBadInput */
@


1.35
log
@Small changes...took out port number from proxy monitor title.
@
text
@d78 1
a78 1
    sprintf(unitID, "Front End (%s)", myName);
@


1.34
log
@reintegrated from branch fox-dev; bug remaining in dispatch.c which should always return a DistillerStatus and not an HTTP_Status
@
text
@d36 1
a36 1
  Port monitorPort, proxyPort = options_->FindUINT32("frontend.listen_port");
d78 1
a78 2
    sprintf(unitID, "Front End (%s/%d - %ld)", myName, proxyPort,
            (long)getpid());
@


1.33
log
@*** empty log message ***
@
text
@d732 11
@


1.33.2.1
log
@*** empty log message ***
@
text
@a731 11
extern "C" Argument *
getArgumentFromId(Argument *args, int numberOfArgs, UINT32 id)
{
  Argument *ptr;
  if (args==NULL) return NULL;
  for(ptr=args; ptr < args+numberOfArgs; ptr++) {
    if (ARG_ID(*ptr)==id) return ptr;
  }
  return NULL;
}

@


1.32
log
@combined distillers.db into gm_options
added re-reading of the options file to the PTM, thru a SIGUSR1
added arbitrary arguments capability to distillers. Extra args are passed
on to DistillerInit()
added functionality to flush the negative cache when the PTM re-reads the
options file or when it restarts
@
text
@d78 2
a79 1
    sprintf(unitID, "Front End (%s/%d - %ld)", myName, proxyPort, getpid());
@


1.31
log
@Added the DistillerBuffer data structure to provide a more elegant way of
freeing buffers between the library and the main program
@
text
@d19 1
a19 2
CacheManager::CacheManager(OptionDatabase *options_,
			   RemoteID &ptmAddress_, Port proxyPort)
d31 4
d36 1
a36 1
  Port monitorPort;
d39 1
d44 1
a49 11
  /*if (options.Create(optionsFile)==gm_False) {
    if (Error::getStatus()!=errFileOpenError) {
      // this was a more serious error; punt back to the user
      return;
    }
  }*/

  // if options weren't found in the options file then install the default
  // options
  if (InstallAllOptions()==gm_False) return;

d55 1
a58 1
  //if (evs->AddCommunicationObject(bus->getListener())==gm_False) return;
d60 1
d69 1
a90 9

  if (strcmp(ptmAddress_.ipAddress, "")!=0) {
    // try to connect to the PTM
    if (ConnectToPTM_(ptmAddress_)==gm_True) goto ForkLabel;
    // Connect() failed; but we'll ignore it
    Error::SetStatus(gm_False);
  }


d102 5
a106 4
  if (EvPTMConnectionLost__()==gm_False) return;
  gm_Log("Could not register with the PTM; "
	 "trying to listen for new PTM address\n");
ForkLabel:
d133 1
a133 1
CacheManager::InstallAllOptions()
d138 2
a139 2
  if (options->Find(Opt_PTMExecutable)==NULL) {
    if (options->Add(Opt_PTMExecutable, DefaultPTMExecutable)==gm_False) 
d143 1
a143 1
  value = options->Find(Opt_PTMMulticast);
d145 3
a147 3
    options->Add(Opt_PTMMulticast_IP,   DefaultMulticastAddress);
    options->Add(Opt_PTMMulticast_port, DefaultMulticastPort);
    options->Add(Opt_PTMMulticast_TTL,  DefaultTTL);
d171 3
a173 3
    options->Add(Opt_PTMMulticast_IP,   multicast.ipAddress);
    options->Add(Opt_PTMMulticast_port, (UINT32) multicast.port);
    options->Add(Opt_PTMMulticast_TTL,  (UINT32) ttl);
d176 1
a176 1
  value = options->Find(Opt_MonitorMulticast);
d178 3
a180 3
    options->Add(Opt_MonitorMulticast_IP,   DefaultMonitorAddress);
    options->Add(Opt_MonitorMulticast_port, DefaultMonitorPort);
    options->Add(Opt_MonitorMulticast_TTL,  DefaultTTL);
d185 3
a187 3
    options->Add(Opt_MonitorMulticast_IP,   "");
    options->Add(Opt_MonitorMulticast_port, (UINT32)-1);
    options->Add(Opt_MonitorMulticast_TTL,  (UINT32)-1);
d211 3
a213 3
    options->Add(Opt_MonitorMulticast_IP,   multicast.ipAddress);
    options->Add(Opt_MonitorMulticast_port, (UINT32) multicast.port);
    options->Add(Opt_MonitorMulticast_TTL,  (UINT32) ttl);
d216 2
a217 2
  if (options->Find(Opt_DistillerDB)==NULL) {
    if (options->Add(Opt_DistillerDB, DefaultDistillerDB)==gm_False) 
d220 2
a221 2
  if (options->Find(Opt_Rsh)==NULL) {
    if (options->Add(Opt_Rsh, DefaultRsh)==gm_False)
d224 2
a225 2
  if (options->Find(Opt_RshArgs)==NULL) {
    if (options->Add(Opt_RshArgs, DefaultRshArgs)==gm_False)
d228 1
a228 1
  if (options->Find(Opt_Hosts)==NULL) {
d232 1
a232 1
    if (options->Add(Opt_Hosts, myself)==gm_False)
d235 2
a236 2
  if (options->Find(Opt_PTMBeacon_ms)==NULL) {
    if (options->Add(Opt_PTMBeacon_ms, DefaultBeaconingPeriod_ms)==gm_False)
d239 2
a240 2
  if (options->Find(Opt_LostBeacons)==NULL) {
    if (options->Add(Opt_LostBeacons, DefaultLostBeacons)==gm_False)
a242 3

  //if (options->Add(Opt_OptionsFile, optionsFile)==gm_False) return gm_False;

d353 3
d574 1
a574 2
CacheManager::CreateInstance(OptionDatabase *options, 
			     RemoteID &ptmAddress, Port proxyPort)
d576 1
a576 1
  instance = new CacheManager(options, ptmAddress, proxyPort);
d580 1
a580 1
  signal (SIGINT, CtlCPressed);
d605 1
a605 2
InitializeDistillerCache(Options options, const char *ptmIPAddress, 
			 Port ptmPort, Port proxyPort)
d610 1
a610 3
  RemoteID ptmAddress(ptmIPAddress, ptmPort);
  returnValue = CacheManager::CreateInstance((OptionDatabase*)options, 
					     ptmAddress, proxyPort);
@


1.30
log
@Changed the ptmstub init function to take in the options database as
an argument rather than the options filename
@
text
@d637 1
a637 2
	DistillerInput  *input, DistillerOutput *output,
	gm_Bool *freeOutputBuffer)
d642 2
a643 2
  output->data   = NULL;
  output->length = 0;
a644 1
  *freeOutputBuffer = gm_True;
d649 1
a649 1
					 input, output, freeOutputBuffer);
d693 1
a693 1
void
d697 1
a697 1
}
d715 1
a715 2
		      DistillerInput *input, DistillerOutput *output,
		      gm_Bool *freeOutputBuffer)
d729 1
a729 2
    status = distiller->Distill(args, numberOfArgs, input, output, 
				freeOutputBuffer);
@


1.29
log
@Added rexec.args, so now you can pass arguments to rsh
Cleaned up the ptm to always read options from the options file
@
text
@d19 1
a19 1
CacheManager::CacheManager(const char *optionsFile, 
d28 1
d45 1
a45 1
  if (options.Create(optionsFile)==gm_False) {
d50 1
a50 1
  }
d57 2
a58 2
  if (rexec.Initialize(options.Find(Opt_Rsh), options.Find(Opt_RshArgs),
		       options.Find(Opt_Hosts))
d61 3
a63 3
  NEW(bus, SharedBus(evs, options.Find(Opt_PTMMulticast_IP),
		     (Port) options.FindUINT32(Opt_PTMMulticast_port),
		     (int)  options.FindUINT32(Opt_PTMMulticast_TTL)));
d66 1
a66 1
  UINT32 beaconingPeriod_ms = options.FindUINT32(Opt_PTMBeacon_ms);
d68 1
a68 1
  UINT32 lostBeacons = options.FindUINT32(Opt_LostBeacons);
d74 3
a76 3
  monitorAddr = options.Find(Opt_MonitorMulticast_IP);
  monitorPort = (Port) options.FindUINT32(Opt_MonitorMulticast_port);
  monitorTTL  = (int)  options.FindUINT32(Opt_MonitorMulticast_TTL);
d105 2
a106 2
	 << "    Options file: " << optionsFile << '\n'
	 << "    PTM executable: " << options.Find(Opt_PTMExecutable) << '\n'
d108 2
a109 2
	 << options.FindUINT32(Opt_PTMBeacon_ms) << '\n'
	 << "    Lost beacon count: " << options.FindUINT32(Opt_LostBeacons)
d150 2
a151 2
  if (options.Find(Opt_PTMExecutable)==NULL) {
    if (options.Add(Opt_PTMExecutable, DefaultPTMExecutable)==gm_False) 
d155 1
a155 1
  value = options.Find(Opt_PTMMulticast);
d157 3
a159 3
    options.Add(Opt_PTMMulticast_IP,   DefaultMulticastAddress);
    options.Add(Opt_PTMMulticast_port, DefaultMulticastPort);
    options.Add(Opt_PTMMulticast_TTL,  DefaultTTL);
d183 3
a185 3
    options.Add(Opt_PTMMulticast_IP,   multicast.ipAddress);
    options.Add(Opt_PTMMulticast_port, (UINT32) multicast.port);
    options.Add(Opt_PTMMulticast_TTL,  (UINT32) ttl);
d188 1
a188 1
  value = options.Find(Opt_MonitorMulticast);
d190 3
a192 3
    options.Add(Opt_MonitorMulticast_IP,   DefaultMonitorAddress);
    options.Add(Opt_MonitorMulticast_port, DefaultMonitorPort);
    options.Add(Opt_MonitorMulticast_TTL,  DefaultTTL);
d197 3
a199 3
    options.Add(Opt_MonitorMulticast_IP,   "");
    options.Add(Opt_MonitorMulticast_port, (UINT32)-1);
    options.Add(Opt_MonitorMulticast_TTL,  (UINT32)-1);
d223 3
a225 3
    options.Add(Opt_MonitorMulticast_IP,   multicast.ipAddress);
    options.Add(Opt_MonitorMulticast_port, (UINT32) multicast.port);
    options.Add(Opt_MonitorMulticast_TTL,  (UINT32) ttl);
d228 2
a229 2
  if (options.Find(Opt_DistillerDB)==NULL) {
    if (options.Add(Opt_DistillerDB, DefaultDistillerDB)==gm_False) 
d232 2
a233 2
  if (options.Find(Opt_Rsh)==NULL) {
    if (options.Add(Opt_Rsh, DefaultRsh)==gm_False)
d236 2
a237 2
  if (options.Find(Opt_RshArgs)==NULL) {
    if (options.Add(Opt_RshArgs, DefaultRshArgs)==gm_False)
d240 1
a240 1
  if (options.Find(Opt_Hosts)==NULL) {
d244 1
a244 1
    if (options.Add(Opt_Hosts, myself)==gm_False)
d247 2
a248 2
  if (options.Find(Opt_PTMBeacon_ms)==NULL) {
    if (options.Add(Opt_PTMBeacon_ms, DefaultBeaconingPeriod_ms)==gm_False)
d251 2
a252 2
  if (options.Find(Opt_LostBeacons)==NULL) {
    if (options.Add(Opt_LostBeacons, DefaultLostBeacons)==gm_False)
d256 1
a256 1
  //if (options.Add(Opt_OptionsFile, optionsFile)==gm_False) return gm_False;
d449 1
a449 1
  ptmExecutableName = options.Find(Opt_PTMExecutable);
d461 1
a461 1
    (char*) options.Find(Opt_OptionsFile),
d586 1
a586 1
CacheManager::CreateInstance(const char *optionsFile, 
d589 1
a589 1
  instance = new CacheManager(optionsFile, ptmAddress, proxyPort);
d618 1
a618 1
InitializeDistillerCache(const char *optionsFile, const char *ptmIPAddress, 
d625 2
a626 2
  returnValue = CacheManager::CreateInstance(optionsFile, ptmAddress, 
					     proxyPort);
@


1.28
log
@Added a new error status distBadInput
@
text
@d53 1
a53 1
  if (InstallAllOptions(optionsFile)==gm_False) return;
d56 2
a57 1
  if (rexec.Initialize(options.Find(Opt_Rsh), options.Find(Opt_Hosts))
d144 1
a144 1
CacheManager::InstallAllOptions(const char *optionsFile)
d235 4
d255 1
a255 1
  if (options.Add(Opt_OptionsFile, optionsFile)==gm_False) return gm_False;
a430 77
#if 0
gm_Bool
CacheManager::StartPTM__()
{
  const char *ptmExecutableName;

  mgrMutex.Lock();

  /*
   * first notify everyone that I'm about to start the PTM
   */
  Packet packet(pktWillStartPTM, 0, 0);
  if (bus->getSender()->Write(&packet)==gm_False) {
    mgrMutex.Unlock();
    return gm_False;
  }


  ptmExecutableName = options.Find(Opt_PTMExecutable);
  if (ptmExecutableName==NULL || *ptmExecutableName=='\0') {
    mgrMutex.Unlock();
    Return(gm_False, errCouldNotLaunch);
  }

  gm_Log("Timed out while waiting for PTM; trying to start " 
	 << ptmExecutableName << '\n');
  
  OStream multicast, monitor;
  const char *distillerDB, *rsh, *rhosts;
  multicast << options.Find(Opt_PTMMulticast_IP) << '/' 
	    << options.Find(Opt_PTMMulticast_port) << '/'
	    << options.Find(Opt_PTMMulticast_TTL);
  monitor   << options.Find(Opt_MonitorMulticast_IP) << '/' 
	    << options.Find(Opt_MonitorMulticast_port) << '/'
	    << options.Find(Opt_MonitorMulticast_TTL);
  distillerDB = options.Find(Opt_DistillerDB);
  rsh         = options.Find(Opt_Rsh);
  rhosts      = options.Find(Opt_Hosts);
  
  char *argv[30];
  char **current = argv;
  
  *current++ = (char*) ptmExecutableName;
  if (*multicast.getData() != '/') {
    *current++ = "-m";
    *current++ = multicast.getData();
  }
  if (*monitor.getData() != '/') {
    *current++ = "-l";
    *current++ = monitor.getData();
  }
  if (distillerDB!=NULL && *distillerDB!='\0') {
    *current++ = "-d";
    *current++ = (char*) distillerDB;
  }
  if (rsh!=NULL && *rsh!='\0') {
    *current++ = "-r";
    *current++ = (char*) rsh;
  }
  if (rhosts!=NULL && *rhosts!='\0') {
    *current++ = "-h";
    *current++ = (char*) rhosts;
  }
  
  *current++ = NULL;
  
  if (rexec.Exec(*argv, argv)==gm_False) {
    mgrMutex.Unlock();
    return gm_False;
  }

  mgrMutex.Unlock();
  return gm_True;
}
#endif 


a456 38
  /*OStream multicast, monitor;
  const char *distillerDB, *rsh, *rhosts;
  multicast << options.Find(Opt_PTMMulticast_IP) << '/' 
	    << options.Find(Opt_PTMMulticast_port) << '/'
	    << options.Find(Opt_PTMMulticast_TTL);
  monitor   << options.Find(Opt_MonitorMulticast_IP) << '/' 
	    << options.Find(Opt_MonitorMulticast_port) << '/'
	    << options.Find(Opt_MonitorMulticast_TTL);
  distillerDB = options.Find(Opt_DistillerDB);
  rsh         = options.Find(Opt_Rsh);
  rhosts      = options.Find(Opt_Hosts);
  
  char *argv[30];
  char **current = argv;
  
  *current++ = (char*) ptmExecutableName;
  if (*multicast.getData() != '/') {
    *current++ = "-m";
    *current++ = multicast.getData();
  }
  if (*monitor.getData() != '/') {
    *current++ = "-l";
    *current++ = monitor.getData();
  }
  if (distillerDB!=NULL && *distillerDB!='\0') {
    *current++ = "-d";
    *current++ = (char*) distillerDB;
  }
  if (rsh!=NULL && *rsh!='\0') {
    *current++ = "-r";
    *current++ = (char*) rsh;
  }
  if (rhosts!=NULL && *rhosts!='\0') {
    *current++ = "-h";
    *current++ = (char*) rhosts;
  }
  
  *current++ = NULL;*/
@


1.27
log
@Modified distiller side code for instrumentation
Added stuff to the frontend side code to do predicting of the queue length
@
text
@d786 2
a787 1
    "Unrecoverable error occurred in distiller"/* distFatalError */
@


1.26
log
@stupid fixes
@
text
@d842 1
@


1.25
log
@Added getpid() to the Front-end monitor UNIT string
@
text
@d68 3
a70 1
  NEW(noBeaconTimer, NoBeaconTimer(evs, lostBeacons*beaconingPeriod_ms));
d403 1
a403 1
  return NoPTMWait_ms + (lrand48() % NoPTMRandom_ms);
a610 59


#if 0
struct EvAskForDistillerArgs {
  EvAskForDistillerArgs(DistillerType *t, UINT32 id)
    : type(*t), replyID(id) { };
  DistillerType type;
  UINT32        replyID;
};


gm_Bool
CacheManager::HandleEvent(EventSystem */*evs_*/, EventType eventType, 
			  void *args_)
{
  EvAskForDistillerArgs *args = (EvAskForDistillerArgs*)args_;

  switch(eventType) {
  case evAskForDistiller:
    {
      mgrMutex.Lock();
      if (IsConnectedToPTM_()==gm_False) {
	// there isn't any PTM
	mgrMutex.Unlock();
	return evs->SendReplyReceivedEvent(args->replyID, (void*) ptmNoPTM);
      }

      OStream stream;
      stream << args->type;
      if (stream.IsGood()==gm_False) {
	mgrMutex.Unlock();
	return gm_False;
      }

      Packet packet(pktAskForDistiller, stream.getLength(), args->replyID,
		    stream.getData());
      delete args;

      if (ptmConnection_->Write(&packet)==gm_False) {
	if (Error::getStatus()==errOutOfMemory) {
	  mgrMutex.Unlock();
	  return gm_False;
	}

	// any other error means the connection is down
	Error::SetStatus(success);
	gm_Bool returnValue = ptmConnection_->EvConnectionBroken(evs);
	mgrMutex.Unlock();
	return returnValue;
      }
      else {
	return gm_True;
      }
    }
  default:
    Return(gm_False, errEvSysInvalidEvent);
  }
}
#endif
@


1.24
log
@Modified the PTM code to make a whole bunch of #defines customizable thru
the gm_options/distillers.db file
@
text
@d78 1
a78 1
    sprintf(unitID, "Front End (%s/%d)", myName, proxyPort);
@


1.23
log
@Minor modifications to the PTM
@
text
@d19 2
a20 1
CacheManager::CacheManager(const char *optionsFile, RemoteID &ptmAddress_)
d64 5
a68 1
  NEW(noBeaconTimer, NoBeaconTimer(evs));
d74 5
a78 4
    char unitID[80];
    char myAddress[MAXIP];
    if (CommunicationObject::GetHostIPAddress(myAddress)==gm_False) return;
    sprintf(unitID, "Front End");
d90 2
d98 11
d239 9
d279 1
d299 1
a299 1
  if (noBeacon==gm_True 
d302 26
a327 2
    gm_Log("PTM connection lost; trying to listen for new PTM address\n");
    return CacheManager::getInstance()->ClosePTMConnection__();
a329 1
  noBeacon = gm_True;
d752 2
a753 1
CacheManager::CreateInstance(const char *optionsFile, RemoteID &ptmAddress)
d755 1
a755 1
  instance = new CacheManager(optionsFile, ptmAddress);
d785 1
a785 1
			 Port ptmPort)
d791 2
a792 1
  returnValue = CacheManager::CreateInstance(optionsFile, ptmAddress);
d843 1
a843 1
    "Fatal error occurred in distiller"      /* distFatalError */
d904 1
@


1.22
log
@Added priorities to remote execution
Added FE_getDistillerStatusString to cacheman.cc
Modified PTM invocation from the frontend to use the gm_options file rather
than pass all options via the command line
@
text
@d769 1
d789 1
a789 1
    "Fatal error while trying to contact distiller" /* distFatalError */
@


1.21
log
@Major changes to the PTM. The PTM can now auto-launch new distillers when
the load on the system gets too high. The frontend stub has a separate
thread per connection to the distillers and PTM to handle network events
@
text
@d52 1
a52 1
  if (InstallAllOptions()==gm_False) return;
d122 1
a122 1
CacheManager::InstallAllOptions()
d220 1
d372 1
d446 82
d761 8
a768 2
  DistillerStatus returnValue = CacheManager::getInstance()->Distill(&distType, args, numberOfArgs, 
					      input, output, freeOutputBuffer);
d771 23
@


1.20
log
@Major changes to the PTM stuff. The previous version has been tagged
stable_ptm.

The new version uses a new LinkedList library; the distiller-cache at
the frontend was rewritten to remove some concurrency bugs
@
text
@a18 1

d26 3
a28 2
    startPTMTimer(NULL),
    noBeaconTimer(NULL)
d58 1
a58 1
  NEW(bus, SharedBus(options.Find(Opt_PTMMulticast_IP),
d61 1
a61 1
  if (evs->AddCommunicationObject(bus->getListener())==gm_False) return;
d72 1
a72 1
    sprintf(unitID, "Front End"); //: %s, myAddress);
a77 1
    /*monitorClient->GaspOnStdSignals();*/
d92 1
a92 1
  if (EvPTMConnectionLost()==gm_False) return;
d104 1
a104 1
    evs->RemoveCommunicationObject(bus->getListener());
d109 2
a110 2
    evs->RemoveCommunicationObject(ptmConnection_);
    delete ptmConnection_;
d228 1
a228 1
  ptmConnection_ = new PTMConnection;
d232 1
a232 1
    delete ptmConnection_;
d237 2
a238 2
  if (evs->AddCommunicationObject(ptmConnection_)==gm_False) {
    delete ptmConnection_;
d241 1
a241 1
  }
d248 1
a248 1
CacheManager::ClosePTMConnection()
d250 1
d252 2
a253 2
    evs->RemoveCommunicationObject(ptmConnection_);
    delete ptmConnection_;
d255 4
a258 1
    if (EvPTMConnectionLost()==gm_False) return gm_False;
d261 1
d267 1
a267 1
CacheManager::NoBeaconTimer::EvTimer(EventSystem *evs)
d269 5
a273 4
  PTMConnection *ptmConnection;
  ptmConnection = CacheManager::getInstance()->getPTMConnection();
  if (noBeacon==gm_True && ptmConnection!=NULL) {
    return ptmConnection->EvConnectionBroken(evs);
d282 1
a282 1
CacheManager::EvPTMLocationReceived(RemoteID &newPtmAddress)
d286 2
a287 1
  if (ptmConnection_!=NULL) {
d289 1
a294 2
  /*strcpy(ptmAddress.ipAddress, newPtmAddress.ipAddress);
    ptmAddress.port = newPtmAddress.port;*/
d298 4
a301 1
    if (Error::getStatus()==errOutOfMemory) return gm_False;
d308 1
a308 1
  if (startPTMTimer!=NULL) startPTMTimer->Disable();
d315 1
d321 1
a321 1
CacheManager::WaitForPTM()
d338 1
a338 1
CacheManager::EvPTMConnectionLost()
a339 2
  /*strcpy(ptmAddress.ipAddress, ""); 
  ptmAddress.port = 0;*/
d341 1
a341 3
  startPTMTimer = new StartPTMTimer(evs, StartPTMTimer::RandomDelay());
  if (startPTMTimer==NULL) Return(gm_False, errOutOfMemory);
  return gm_True;
d355 4
a358 5
  if (IsDisabled()==gm_True) {
    delete this;
    CacheManager::getInstance()->SetStartPTMTimer(NULL);
    return gm_True;
  }
a359 6
  Packet packet(pktWillStartPTM, 0, 0);
  if (packet.Send(CacheManager::getInstance()->getSharedBus()->getSender())
      ==gm_False) {
    // ignore the error
    Error::SetStatus(success);
  }
d361 7
a367 6
  delete this;
  CacheManager::getInstance()->SetStartPTMTimer
    (new StartPTMTimer(evs, StartPTMTimer::RandomDelay()));
  CacheManager::getInstance()->StartPTM();

  return gm_True;
d371 2
a372 2
/*gm_Bool
CacheManager::StartPTM()
d374 1
a374 2
  int returnValue;
  const char *ptmExecutable;
d376 1
a376 3
  ptmExecutable = options.Find(Opt_PTMExecutable);
  if (ptmExecutable==NULL || *ptmExecutable=='\0') 
    Return(gm_False, errCouldNotLaunch);
d378 7
a384 50
  gm_Log("Timed out while waiting for PTM; trying to start " << ptmExecutable
	 << '\n');
  returnValue = fork();
  if (returnValue==0) {
    returnValue = fork();
    if (returnValue != 0) {
      exit(returnValue);
    }
  }
  else if (returnValue > 0) {
    returnValue = waitpid(returnValue, NULL, 0);
  }

  if (returnValue < 0) {
    gm_Log("Could not fork off child process\n");
    Return(gm_False, errCouldNotLaunch);
  }
  if (returnValue== 0) {
    OStream multicast, monitor;
    const char *distillerDB;
    multicast << options.Find(Opt_PTMMulticast_IP) << '/' 
	      << options.Find(Opt_PTMMulticast_port) << '/'
	      << options.Find(Opt_PTMMulticast_TTL);
    monitor   << options.Find(Opt_MonitorMulticast_IP) << '/' 
	      << options.Find(Opt_MonitorMulticast_port) << '/'
	      << options.Find(Opt_MonitorMulticast_TTL);
    distillerDB = options.Find(Opt_DistillerDB);

    char *argv[20];
    char **current = argv;

    *current++ = (char*) ptmExecutable;
    if (*multicast.getData() != '/') {
      *current++ = "-m";
      *current++ = multicast.getData();
    }
    if (*monitor.getData() != '/') {
      *current++ = "-l";
      *current++ = monitor.getData();
    }
    if (distillerDB!=NULL && *distillerDB!='\0') {
      *current++ = "-d";
      *current++ = (char*) distillerDB;
    }
    *current++ = NULL;

    if (execv(ptmExecutable, argv) < 0) {
      gm_Log("Error starting process: " << ptmExecutable << '\n');
      exit(-1);
    }
a386 9
  return gm_True;
}*/


gm_Bool
CacheManager::StartPTM()
{
  //char ptmExecutablePath[1024], distillerDBPath[1024];
  const char *ptmExecutableName;
d389 2
a390 1
  if (ptmExecutableName==NULL || *ptmExecutableName=='\0') 
d392 1
a396 15
  /*if (*ptmExecutableName!='/') {
    // this is a relative pathname; so prepend the current working dir
    if (getcwd(ptmExecutablePath, sizeof(ptmExecutablePath))==NULL) 
      Return(gm_False, errBufferOverflow);
    if (strlen(ptmExecutablePath)+strlen(ptmExecutableName)+2 > 
	sizeof(ptmExecutablePath))
      Return(gm_False, errBufferOverflow);
    sprintf(ptmExecutablePath, "%s/%s", ptmExecutablePath, ptmExecutableName);
    realExecutable = ptmExecutablePath;
  }
  else realExecutable = ptmExecutableName;*/
  /*if (RExec::getAbsolutePath(ptmExecutableName, ptmExecutablePath, 
			     sizeof(ptmExecutablePath))==gm_False)
    return gm_False;*/

d436 6
a441 1
  if (rexec.Exec(*argv, argv)==gm_False) return gm_False;
d447 2
a448 2
CacheManager::AskPTMForDistiller(DistillerType *type, 
				 AskForDistillerStatus &status)
d450 3
a452 1
  if (IsConnectedToPTM()==gm_False) {
d454 1
d457 4
a460 1

d462 5
a466 1
  if (askRequest.SendAndWait(type)==gm_False) return gm_False;
d468 3
d475 1
d493 2
a494 1
      if (IsConnectedToPTM()==gm_False) {
d496 1
d502 4
a505 1
      if (stream.IsGood()==gm_False) return gm_False;
d511 5
a515 2
      if (packet.Send(ptmConnection_)==gm_False) {
	if (Error::getStatus()==errOutOfMemory) return gm_False;
d519 3
a521 1
	return ptmConnection_->EvConnectionBroken(evs);
d531 1
d535 2
a536 1
CacheManager::AskForDistiller::SendAndWait(DistillerType *type)
d538 2
a539 2
  EvAskForDistillerArgs *args = new EvAskForDistillerArgs(type, getID());
  if (args==NULL) Return(gm_False, errOutOfMemory);
d541 3
a543 4
  mutex.Lock();
  if (CacheManager::getInstance()->getEventSystem()->
      PostEvent(evAskForDistiller, CacheManager::getInstance(), 
		args)==gm_False) {
d547 17
d602 1
a602 1
  getMonitorClient()->Gasp(0);
d652 1
d670 1
d677 1
a677 1
  return CacheManager::getInstance()->Distill(&distType, args, numberOfArgs, 
d679 2
d702 1
a702 1
  CacheManager::getInstance()->WaitForPTM();
d723 1
@


1.19
log
@Committing changes before going in to modify the linked list routines
@
text
@d7 1
d20 3
a22 4
CacheManager::CacheManager(const char *optionsFile, RemoteID &ptm)
  : ptmAddress(ptm), 
    evs(NULL), 
    ptmConnection(NULL), 
d38 1
a81 1
    //SetFileLogging("/tmp/log.cacheman");
d85 9
a93 5
  if (IsPTMFound()==gm_True) {
    if (ConnectToPTM()==gm_True) goto ForkLabel;
  }
  if (NoPTM()==gm_False) return;

a95 1

d109 4
a112 4
  if (ptmConnection!=NULL) {
    evs->RemoveCommunicationObject(ptmConnection);
    delete ptmConnection;
    ptmConnection = NULL;
a225 94


/*gm_Bool
CacheManager::InstallAllOptions()
{
  const char *value;
  char *slash1, *slash2;

  if (options.Find(Opt_PTMExecutable)==NULL) {
    if (options.Add(Opt_PTMExecutable, DefaultPTMExecutable)==gm_False) 
      return gm_False;
  }

  value = options.Find(Opt_PTMMulticast);
  if (value==NULL) {
    options.Add(Opt_PTMMulticast_IP,   DefaultMulticastAddress);
    options.Add(Opt_PTMMulticast_port, DefaultMulticastPort);
    options.Add(Opt_PTMMulticast_TTL,  DefaultTTL);
  }
  else {
    RemoteID multicast;
    int ttl;

    slash1 = strchr(value, '/');
    if (slash1==NULL || slash1==value) Return(gm_False, errFormattingError);

    if (slash1 >= value + MAXIP) Return(gm_False, errBufferOverflow);
    strncpy(multicast.ipAddress, value, slash1-value);
    multicast.ipAddress[slash1-value] = '\0';
    
    slash2 = strchr(slash1+1, '/');
    if (slash2==NULL) {
      multicast.port = atoi(slash1+1);
      if (multicast.port==0) Return(gm_False, errFormattingError);
      ttl = DefaultTTL;
    }
    else {
      if (sscanf(slash1+1, "%d/%d", &multicast.port, &ttl)!=2) 
	Return(gm_False, errFormattingError);
      if (multicast.port==0 || ttl==0) Return(gm_False, errFormattingError);
    }
    options.Add(Opt_PTMMulticast_IP,   multicast.ipAddress);
    options.Add(Opt_PTMMulticast_port, (UINT32) multicast.port);
    options.Add(Opt_PTMMulticast_TTL,  (UINT32) ttl);
  }

  value = options.Find(Opt_MonitorMulticast);
  if (value==NULL) {
    options.Add(Opt_MonitorMulticast_IP,   DefaultMonitorAddress);
    options.Add(Opt_MonitorMulticast_port, DefaultMonitorPort);
    options.Add(Opt_MonitorMulticast_TTL,  DefaultTTL);
  }
  else if (*value=='\0') {
    // we have explicitly mentioned that we don't want to use a monitor
    // All log messages will be output to stderr
    options.Add(Opt_MonitorMulticast_IP,   "");
    options.Add(Opt_MonitorMulticast_port, (UINT32)-1);
    options.Add(Opt_MonitorMulticast_TTL,  (UINT32)-1);
  }
  else {
    RemoteID multicast;
    int ttl;

    slash1 = strchr(value, '/');
    if (slash1==NULL || slash1==value) Return(gm_False, errFormattingError);

    if (slash1 >= value + MAXIP) Return(gm_False, errBufferOverflow);
    strncpy(multicast.ipAddress, value, slash1-value);
    multicast.ipAddress[slash1-value] = '\0';
    
    slash2 = strchr(slash1+1, '/');
    if (slash2==NULL) {
      multicast.port = atoi(slash1+1);
      if (multicast.port==0) Return(gm_False, errFormattingError);
      ttl = DefaultTTL;
    }
    else {
      if (sscanf(slash1+1, "%d/%d", &multicast.port, &ttl)!=2) 
	Return(gm_False, errFormattingError);
      if (multicast.port==0 || ttl==0) Return(gm_False, errFormattingError);
    }
    options.Add(Opt_MonitorMulticast_IP,   multicast.ipAddress);
    options.Add(Opt_MonitorMulticast_port, (UINT32) multicast.port);
    options.Add(Opt_MonitorMulticast_TTL,  (UINT32) ttl);
  }

  if (options.Find(Opt_DistillerDB)==NULL) {
    if (options.Add(Opt_DistillerDB, DefaultDistillerDB)==gm_False) return gm_False;
  }

  return gm_True;
}*/


d227 1
a227 1
CacheManager::ConnectToPTM()
d229 6
a234 5
  ptmConnection = new PTMConnection;
  if (ptmConnection==NULL) Return(gm_False, errOutOfMemory);
  if (ptmConnection->Connect(ptmAddress.ipAddress, ptmAddress.port)==gm_False) {
    delete ptmConnection;
    ptmConnection = NULL;
d238 3
a240 3
  if (evs->AddCommunicationObject(ptmConnection)==gm_False) {
    delete ptmConnection;
    ptmConnection = NULL;
d251 5
a255 5
  if (ptmConnection!=NULL) {
    evs->RemoveCommunicationObject(ptmConnection);
    delete ptmConnection;
    ptmConnection = NULL;
    if (NoPTM()==gm_False) return gm_False;
a267 1
    gm_Debug(dbgTmp, "No beacons heard, disconnecting the PTM\n");
d277 1
a277 1
CacheManager::PTMLocationReceived(RemoteID &newPtmAddress)
d281 1
a281 1
  if (ptmConnection!=NULL) {
d288 2
a289 2
  strcpy(ptmAddress.ipAddress, newPtmAddress.ipAddress);
  ptmAddress.port = newPtmAddress.port;
d291 1
a291 1
  if (ConnectToPTM()==gm_False) {
d296 1
d304 1
a304 1
  ptmFoundCond.Signal();
d315 1
a315 1
  if (ptmConnection!=NULL) {
d329 1
a329 1
CacheManager::NoPTM()
d331 3
a333 3
  strcpy(ptmAddress.ipAddress, ""); 
  ptmAddress.port = 0;

a509 80

DistillerStatus
CacheManager::Distill(DistillerType &type,   Argument *args, int numberOfArgs,
		      DistillerInput *input, DistillerOutput *output,
		      gm_Bool *freeOutputBuffer)
  // if connection fails between send and reply, then this function returns
  // an error; perform the retry option at a higher level function
{
  CachedDistiller *distiller;
  DistillerStatus returnValue;

  while (gm_True) {
    cache->Lock();
    distiller = cache->Find(&type);
    
    if (distiller==NULL) {
      // distiller not found; ask the PTM for one
      AskForDistillerStatus status;
      cache->Unlock();
      if (AskPTMForDistiller(&type, status)==gm_False) {
	// could not get a distiller from the PTM
	switch (status) {
	case ptmDistillerLaunchTimeout:
	case ptmAskForDistillerTimeout:
	  return distLaunchTimeout;
	default: 
	  return distDistillerNotFound;
	}
      }
      else {
	// got a distiller from the PTM; it must be cached now; find it!
	cache->Lock();
	distiller = cache->Find(&type);
	if (distiller==NULL) {
	  cache->Unlock();
	  return distDistillerNotFound;
	}
      }
    }

    if (distiller->IsConnected()==gm_True) {
      returnValue = distiller->Distill(args, numberOfArgs, input, output,
				       freeOutputBuffer);
      if (returnValue!=distSendError) {
	cache->Unlock();
	return returnValue;
      }
      // distSendError => can't communicate with the distiller
      // try a new distiller
    }
    else if (distiller->Connect()==gm_True) {
      // succeeded in connecting to the distiller
      
      returnValue = distiller->Distill(args, numberOfArgs, input, output,
				       freeOutputBuffer);
      if (returnValue!=distSendError) {
	cache->Unlock();
	return returnValue;
      }
      // distSendError => can't communicate with the distiller
      // try a new distiller
    }
    // connection to the distiller failed
    // might have failed due to lack of memory; in that case punt back to 
    // caller
    if (Error::getStatus()==errOutOfMemory) return distOutOfLocalMemory;

    // remove this distiller from the cache and try again
    
    cache->Remove(distiller); // XXX no error checking on the return value
    cache->Unlock();
  }

  // never reached! 
  // added the return statement to prevent the compiler from generating a 
  // warning
  return distOk;
}


d514 4
a517 2
  if (IsPTMFound()==gm_False) return gm_False;
  if (ptmConnection==NULL) return gm_False;
d543 1
a543 1
      if (ptmConnection==NULL) {
d556 1
a556 1
      if (packet.Send(ptmConnection)==gm_False) {
d561 1
a561 1
	return ptmConnection->EvConnectionBroken(evs);
d672 1
d675 6
a680 1
  return CacheManager::CreateInstance(optionsFile, ptmAddress);
d697 1
a697 1
  return CacheManager::getInstance()->Distill(distType, args, numberOfArgs, 
d721 40
@


1.18
log
@Modified the PTM stuff to enable remote execution of processes
Currently using rsh and round-robin to select machines
@
text
@d77 1
a77 1
    monitorClient->GaspOnStdSignals();
@


1.17
log
@PTM stub now does a random selection from multiple distillers
@
text
@d34 4
a37 1
  srand(time(NULL));
d53 4
d82 1
a82 1
    SetStderrLogging("Proxy: ");
d118 1
d204 106
d314 1
a314 1
}
d433 1
a433 4
  timeval now;
  gettimeofday(&now, NULL);
  srand(now.tv_usec + getpid());
  return NoPTMWait_ms + (rand() % NoPTMRandom_ms);
d462 1
a462 1
gm_Bool
d525 72
d600 1
d840 1
a840 1
  Debug_::getInstance()->Initialize("et", "Proxy: ");
@


1.16
log
@Fixed some random bugs, most notably a lack of htons()in getLocalPort.
@
text
@d34 1
@


1.15
log
@More changes for killing processes via the monitor
@
text
@d266 1
a266 1

d271 1
@


1.14
log
@Modified the ptm stub and distiller stub to use the new distiller API
@
text
@d63 1
a63 1
    sprintf(unitID, "Front End"); //: %s", myAddress);
d69 1
d606 1
d645 1
@


1.13
log
@*** empty log message ***
@
text
@d63 1
a63 1
    sprintf(unitID, "Proxy: %s", myAddress);
d415 3
a417 3
CacheManager::Distill(DistillerType &type, Argument *args, int numberOfArgs,
		      void *input,   UINT32 inputLength,
		      void **output, UINT32 *outputLength)
d454 2
a455 2
      returnValue = distiller->Distill(args, numberOfArgs, input, inputLength, 
				       output, outputLength);
d466 2
a467 2
      returnValue = distiller->Distill(args, numberOfArgs, input, inputLength, 
				       output, outputLength);
d658 3
a660 3
Distill(C_DistillerType *type, Argument *args, int numberOfArgs,
	void *input,   UINT32 inputLength,
	void **output, UINT32 *outputLength)
d664 4
a667 2
  *output = NULL;
  *outputLength = 0;
d671 1
a671 2
					      input, inputLength, 
					      output, outputLength);
d684 1
a684 1
FreeOutputBuffer(void *buffer)
d686 1
a686 1
  if (buffer!=NULL) Packet::UnfreezeData((char*)buffer);
@


1.12
log
@Modifications made to the PTM to remove bugs found while in India.
@
text
@d674 8
@


1.11
log
@Yatin's first commit from India
@
text
@d27 2
a28 1
    startPTMTimer(NULL)
d39 1
a39 1
    if (GlobalErrorCode!=errFileOpenError) {
d54 2
d66 2
a67 2
    if (monitorClient==NULL) VoidErrorReturn(errOutOfMemory);
    if (GlobalErrorCode!=success) return;
d72 2
a73 1
    SetFileLogging("/tmp/log.cacheman");
d77 1
a77 1
    if (ConnectToPTM()==gm_True) return;
d81 2
a82 2
  LOG ("Could not register with the PTM; "
       "trying to listen for new PTM address\n");
d84 1
d131 1
a131 1
    if (slash1==NULL || slash1==value) gm_BoolErrorReturn(errFormattingError);
d133 1
a133 1
    if (slash1 >= value + MAXIP) gm_BoolErrorReturn(errBufferOverflow);
d140 1
a140 1
      if (multicast.port==0) gm_BoolErrorReturn(errFormattingError);
d145 2
a146 2
	gm_BoolErrorReturn(errFormattingError);
      if (multicast.port==0 || ttl==0) gm_BoolErrorReturn(errFormattingError);
d171 1
a171 1
    if (slash1==NULL || slash1==value) gm_BoolErrorReturn(errFormattingError);
d173 1
a173 1
    if (slash1 >= value + MAXIP) gm_BoolErrorReturn(errBufferOverflow);
d180 1
a180 1
      if (multicast.port==0) gm_BoolErrorReturn(errFormattingError);
d185 2
a186 2
	gm_BoolErrorReturn(errFormattingError);
      if (multicast.port==0 || ttl==0) gm_BoolErrorReturn(errFormattingError);
d197 1
a197 1
  gm_BoolErrorReturn(success);
d205 1
a205 1
  if (ptmConnection==NULL) gm_BoolErrorReturn(errOutOfMemory);
d218 1
a218 1
  gm_BoolErrorReturn(success);
d232 16
a247 1
  gm_BoolErrorReturn(success);
d254 2
d258 1
a258 1
    gm_BoolErrorReturn(success);
d261 2
a262 2
  LOG("Found PTM at " << newPtmAddress.ipAddress << '/' 
      << newPtmAddress.port << '\n');
d268 2
a269 2
    if (GlobalErrorCode==errOutOfMemory) return gm_False;
    LOG("Could not connect. Ignoring new locationm\n");
d280 1
a280 1
  gm_BoolErrorReturn(success);
d293 4
a296 1
  ptmFoundCond.Wait(&ptmFoundMutex);
d308 2
a309 1
  gm_BoolErrorReturn(success);
d329 1
a329 1
    gm_BoolErrorReturn(success);
d334 4
a337 2
      ==gm_False)
    ; // ignore the error
d344 1
a344 1
  gm_BoolErrorReturn(success);
d356 1
a356 1
    gm_BoolErrorReturn(errCouldNotLaunch);
d358 2
a359 2
  LOG("Timed out while waiting for PTM; trying to start " << ptmExecutable
      << '\n');
d372 2
a373 2
    LOG("Could not fork off child process\n");
    gm_BoolErrorReturn(errCouldNotLaunch);
d405 1
a405 1
      LOG("Error starting process: " << ptmExecutable << '\n');
d410 1
a410 1
  gm_BoolErrorReturn(success);
d425 1
d431 1
d444 1
d446 4
a449 1
	if (distiller==NULL) return distDistillerNotFound;
d456 4
a459 1
      if (returnValue!=distSendError) return returnValue;
d468 4
a471 1
      if (returnValue!=distSendError) return returnValue;
d478 1
a478 1
    if (GlobalErrorCode==errOutOfMemory) return distOutOfLocalMemory;
d482 2
a483 1
    cache->Remove(distiller);
d516 1
a516 1
CacheManager::HandleEvent(EventSystem */*evs*/, EventType eventType, 
d524 5
d538 1
a538 1
	if (GlobalErrorCode==errOutOfMemory) return gm_False;
d540 3
a542 2
	// ignore other errors
	gm_BoolErrorReturn(success);
d545 1
a545 1
	gm_BoolErrorReturn(success);
d549 1
a549 1
    gm_BoolErrorReturn(errEvSysInvalidEvent);
d558 1
a558 1
  if (args==NULL) gm_BoolErrorReturn(errOutOfMemory);
d562 2
a563 1
      PostEvent(evAskForDistiller, CacheManager::getInstance(), args)==gm_False) {
d570 1
a570 1
  gm_BoolErrorReturn(success);
d579 1
a579 1
  status = (AskForDistillerStatus) *((UINT32*)args);
d582 1
a582 1
  gm_BoolErrorReturn(success);
d593 1
a593 1
  gm_BoolErrorReturn(success);
d603 1
a603 1
  LOG ("Cache Manager has quit. This shouldn't have happened\n");
d621 2
a622 2
  if (instance==NULL) gm_BoolErrorReturn(errOutOfMemory);
  if (GlobalErrorCode!=success) return gm_False;
d639 2
a640 13
  LOG("Aborting program: " << string << "\n\n"
      << "Abort status: Global error code = " << GlobalErrorCode << "\n"
      << "              Thread error code = " << ThreadErrorCode << "\n");

  if (GlobalErrorCode!=success) {
    LOG( "              Error file-name   = " << ErrorFilename << "\n"
      << "              Error line number = " << ErrorLineNo   << "\n");
  }

  LOG("              errno = " << errno << "\n");
  if (errno!=0) {
    LOG( "              Errno explanation: " << strerror(errno) << "\n");
  }
d642 1
a642 1
  if (instance!=NULL) delete instance;
d651 1
@


1.10
log
@Modified Bool, FALSE and TRUE to gm_Bool, gm_False and gm_True respectively
@
text
@d12 2
d68 3
d333 10
@


1.9
log
@Added load balancing stuff to the distiller and ptm. Still need to add
lottery scheduling to the cache manager
@
text
@d35 1
a35 1
  if (options.Create(optionsFile)==FALSE) {
d44 1
a44 1
  if (InstallAllOptions()==FALSE) return;
d49 1
a49 1
  if (evs->AddCommunicationObject(bus->getListener())==FALSE) return;
d57 1
a57 1
    if (CommunicationObject::GetHostIPAddress(myAddress)==FALSE) return;
d67 2
a68 2
  if (IsPTMFound()==TRUE) {
    if (ConnectToPTM()==TRUE) return;
d70 1
a70 1
  if (NoPTM()==FALSE) return;
d99 1
a99 1
Bool
d106 2
a107 2
    if (options.Add(Opt_PTMExecutable, DefaultPTMExecutable)==FALSE) 
      return FALSE;
d121 1
a121 1
    if (slash1==NULL || slash1==value) BoolErrorReturn(errFormattingError);
d123 1
a123 1
    if (slash1 >= value + MAXIP) BoolErrorReturn(errBufferOverflow);
d130 1
a130 1
      if (multicast.port==0) BoolErrorReturn(errFormattingError);
d135 2
a136 2
	BoolErrorReturn(errFormattingError);
      if (multicast.port==0 || ttl==0) BoolErrorReturn(errFormattingError);
d161 1
a161 1
    if (slash1==NULL || slash1==value) BoolErrorReturn(errFormattingError);
d163 1
a163 1
    if (slash1 >= value + MAXIP) BoolErrorReturn(errBufferOverflow);
d170 1
a170 1
      if (multicast.port==0) BoolErrorReturn(errFormattingError);
d175 2
a176 2
	BoolErrorReturn(errFormattingError);
      if (multicast.port==0 || ttl==0) BoolErrorReturn(errFormattingError);
d184 1
a184 1
    if (options.Add(Opt_DistillerDB, DefaultDistillerDB)==FALSE) return FALSE;
d187 1
a187 1
  BoolErrorReturn(success);
d191 1
a191 1
Bool
d195 2
a196 2
  if (ptmConnection==NULL) BoolErrorReturn(errOutOfMemory);
  if (ptmConnection->Connect(ptmAddress.ipAddress, ptmAddress.port)==FALSE) {
d199 1
a199 1
    return FALSE;
d202 1
a202 1
  if (evs->AddCommunicationObject(ptmConnection)==FALSE) {
d205 1
a205 1
    return FALSE;
d208 1
a208 1
  BoolErrorReturn(success);
d212 1
a212 1
Bool
d219 1
a219 1
    if (NoPTM()==FALSE) return FALSE;
d222 1
a222 1
  BoolErrorReturn(success);
d226 1
a226 1
Bool
d231 1
a231 1
    BoolErrorReturn(success);
d239 1
a239 1
  if (ConnectToPTM()==FALSE) {
d241 1
a241 1
    if (GlobalErrorCode==errOutOfMemory) return FALSE;
d253 1
a253 1
  BoolErrorReturn(success);
d271 1
a271 1
Bool 
d278 1
a278 1
  BoolErrorReturn(success);
d292 1
a292 1
Bool
d295 1
a295 1
  if (IsDisabled()==TRUE) {
d298 1
a298 1
    BoolErrorReturn(success);
d303 1
a303 1
      ==FALSE)
d311 1
a311 1
  BoolErrorReturn(success);
d315 1
a315 1
Bool
d323 1
a323 1
    BoolErrorReturn(errCouldNotLaunch);
d330 1
a330 1
    BoolErrorReturn(errCouldNotLaunch);
d367 1
a367 1
  BoolErrorReturn(success);
d381 1
a381 1
  while (TRUE) {
d387 1
a387 1
      if (AskPTMForDistiller(&type, status)==FALSE) {
d404 1
a404 1
    if (distiller->IsConnected()==TRUE) {
d411 1
a411 1
    else if (distiller->Connect()==TRUE) {
d437 1
a437 1
Bool
d441 2
a442 2
  if (IsPTMFound()==FALSE) return FALSE;
  if (ptmConnection==NULL) return FALSE;
d445 1
a445 1
  if (askRequest.SendAndWait(type)==FALSE) return FALSE;
d447 1
a447 1
  return (status==ptmOk) ? TRUE : FALSE;
d459 1
a459 1
Bool
d470 1
a470 1
      if (stream.IsGood()==FALSE) return FALSE;
d476 2
a477 2
      if (packet.Send(ptmConnection)==FALSE) {
	if (GlobalErrorCode==errOutOfMemory) return FALSE;
d480 1
a480 1
	BoolErrorReturn(success);
d483 1
a483 1
	BoolErrorReturn(success);
d487 1
a487 1
    BoolErrorReturn(errEvSysInvalidEvent);
d492 1
a492 1
Bool
d496 1
a496 1
  if (args==NULL) BoolErrorReturn(errOutOfMemory);
d500 1
a500 1
      PostEvent(evAskForDistiller, CacheManager::getInstance(), args)==FALSE) {
d502 1
a502 1
    return FALSE;
d507 1
a507 1
  BoolErrorReturn(success);
d511 1
a511 1
Bool
d519 1
a519 1
  BoolErrorReturn(success);
d523 1
a523 1
Bool
d530 1
a530 1
  BoolErrorReturn(success);
d537 1
a537 1
  if (evs->Run()==FALSE) {
d554 1
a554 1
Bool
d558 2
a559 2
  if (instance==NULL) BoolErrorReturn(errOutOfMemory);
  if (GlobalErrorCode!=success) return FALSE;
d562 1
a562 1
  return TRUE;
d595 1
a595 1
Bool
@


1.8
log
@Removed bugs from stub.cc etc.
@
text
@d17 1
a17 3
CacheManager::CacheManager(char *ptmExecutable_,
			   RemoteID &ptm, RemoteID &multicast, int ttl,
			   RemoteID &logAddr, int logTTL)
d25 1
a25 2
    startPTMTimer(NULL),
    ptmExecutable(NULL)
d27 4
d34 15
a48 1
  NEW(bus, SharedBus(multicast, ttl));
d51 4
a54 7
  ptmExecutable = new char [strlen(ptmExecutable_)+1];
  if (ptmExecutable==NULL) VoidErrorReturn(errOutOfMemory);
  strcpy(ptmExecutable, ptmExecutable_);

  sprintf(coordinationMulticast, "%s/%d/%d", multicast.ipAddress,
	  multicast.port, ttl);
  if (strcmp(logAddr.ipAddress, "")!=0) {
d59 2
a60 2
    monitorClient = new MonitorClient(unitID, logAddr.ipAddress,logAddr.port,
				      logTTL);
a64 2
    sprintf(monitorMulticast, "%s/%d/%d", logAddr.ipAddress,
	  logAddr.port, logTTL);
a65 1
  else strcpy(monitorMulticast, "");
a91 1
  if (ptmExecutable!=NULL) { delete [] ptmExecutable; ptmExecutable=NULL; }
d100 92
d319 1
d321 1
d333 10
d344 1
a344 1
    int argc=0;
d346 8
a353 4
    argv[argc++] = ptmExecutable;
    if (*monitorMulticast!='\0') {
      argv[argc++] = "-l";
      argv[argc++] = monitorMulticast;
d355 3
a357 4

    if (*coordinationMulticast!='\0') {
      argv[argc++] = "-m";
      argv[argc++] = coordinationMulticast;
d359 1
a359 1
    argv[argc++] = NULL;
d555 1
a555 3
CacheManager::CreateInstance(char *ptmExecutable, RemoteID &ptmAddress, 
			     RemoteID &multicast, int ttl, 
			     RemoteID &logAddr, int logTTL)
d557 1
a557 2
  instance = new CacheManager(ptmExecutable, ptmAddress, multicast, ttl, 
			      logAddr, logTTL);
d574 1
a574 1
CacheManager::Abort(char *string)
d596 2
a597 5
InitializeDistillerCache(char *ptmExecutable_, char *multicastIPAddress, 
			 Port multicastPort, int ttl,
			 char *ptmIPAddress, Port ptmPort,
			 char *monitorIPAddress, Port monitorPort, 
			 int monitorTTL)
d599 2
a600 37
  char *ptmExecutable=NULL, *home=NULL;
  char executable[256], filename[256];
  FILE *fp;

  if (ptmExecutable_!=NULL && *ptmExecutable_!='\0') {
    ptmExecutable = ptmExecutable_;
  }

  if (ptmExecutable==NULL) {
    // try in ./.ptmrc
    fp = fopen(".ptmrc", "r");
    if (fp!=NULL) {
      if (fscanf(fp, "%s", executable)==1) ptmExecutable = executable;
      fclose(fp);
    }
  }

  if (ptmExecutable==NULL && (home = getenv("HOME"))!=NULL) {
    // try in $HOME/.ptmrc
    sprintf(filename, "%s/.ptmrc", home);
    fp = fopen(filename, "r");
    if (fp!=NULL) {
      if (fscanf(fp, "%s", executable)==1) ptmExecutable = executable;
      fclose(fp);
    }
  }

  if (ptmExecutable==NULL) {
    // nothing worked; simply use ./ptm
    ptmExecutable = "ptm";
  }

  RemoteID ptmAddress(ptmIPAddress, ptmPort),
    multicast(multicastIPAddress, multicastPort),
    monitorAddr(monitorIPAddress, monitorPort);
  return CacheManager::CreateInstance(ptmExecutable, ptmAddress, multicast, 
				      ttl, monitorAddr, monitorTTL);
@


1.7
log
@The proxy front-ends can now spawn new PTM if it detects that there isn't
any PTM running.
@
text
@d148 5
d157 14
d554 5
@


1.6
log
@Modified the logging mechanism to use the monitor entity
Multiple PTM detect each other and die gracefully
Still need to do auto start of PTM by the proxy front end
@
text
@a4 1
#include "thread.h"
d17 2
a18 1
CacheManager::CacheManager(RemoteID &ptm, RemoteID &multicast, int ttl,
d27 2
a28 1
    startPTMTimer(NULL)
d36 6
d53 2
d56 1
d83 1
d146 1
a146 1
  //if (startPTMTimer!=NULL) startPTMTimer->Disable();
a154 2
  //UINT32 delay;

d158 3
a160 1
  /*if (startPTMTimer!=NULL) BoolErrorReturn(errGenericError);
d162 4
d169 1
a169 4
  delay = 4000 + (rand() % 2000);
  startPTMTimer = new StartPTMTimer(evs, delay);*/

  BoolErrorReturn(success);
d173 1
a173 1
/*Bool
d178 1
a178 1
    CacheManager::getInstance()->SetTimer(NULL);
d183 2
a184 1
  if (packet.Send(PTM::getInstance()->getSharedBus()->getSender())==FALSE)
d188 2
a189 1
  CacheManager::getInstance()->SetTimer(new StartPTMTimer(evs));
d193 1
a193 1
}*/
d196 1
a196 1
/*Bool
d201 5
d212 14
a225 2
    char executable[100]="/disks/barad-dur/wolfpack/users/yatin/research/tcsproxy/ptm/ptm"; 
    char *argv[] = { executable, NULL };
d227 2
a228 2
    if (execv(executable, argv) < 0) {
      LOG("Error starting process: " << executable << '\n');
d234 1
a234 1
}*/
d421 3
a423 2
CacheManager::CreateInstance(RemoteID &ptmAddress, RemoteID &multicast, 
			     int ttl, RemoteID &logAddr, int logTTL)
d425 2
a426 1
  instance = new CacheManager(ptmAddress, multicast, ttl, logAddr, logTTL);
d465 2
a466 1
InitializeDistillerCache(char *multicastIPAddress, Port multicastPort, int ttl,
d471 32
d506 2
a507 2
  return CacheManager::CreateInstance(ptmAddress, multicast, ttl,
				      monitorAddr, monitorTTL);
@


1.5
log
@Just before adding stuff for using the monitoring GUI
@
text
@d1 1
d12 1
d18 2
a19 1
CacheManager::CacheManager(RemoteID &ptm, RemoteID &multicast, int ttl)
d26 1
d35 13
d76 1
d135 1
a135 1
  if (startPTMTimer!=NULL) startPTMTimer->Disable();
d144 1
a144 1
  UINT32 delay;
d149 1
a149 1
  if (startPTMTimer!=NULL) BoolErrorReturn(errGenericError);
d155 1
a155 1
  startPTMTimer = new StartPTMTimer(evs, delay);
d161 1
a161 1
Bool
d179 1
a179 1
}
d182 1
a182 1
Bool
d203 1
a203 1
}
d390 2
a391 1
CacheManager::CreateInstance(RemoteID &ptmAddress, RemoteID &multicast)
d393 1
a393 1
  instance = new CacheManager(ptmAddress, multicast, DefaultTTL);
d432 4
a435 2
InitializeDistillerCache(char *multicastIPAddress, Port multicastPort,
			 char *ptmIPAddress, Port ptmPort)
d438 4
a441 2
    multicast(multicastIPAddress, multicastPort);
  return CacheManager::CreateInstance(ptmAddress, multicast);
@


1.4
log
@Modified cacheman.cc so that FreeOutputBuffer works correctly irrespective
of the distiller-status that Distill() returned
@
text
@d16 1
a16 1
CacheManager::CacheManager(RemoteID &ptm, RemoteID &multicast)
d20 1
a20 1
    listener(NULL), 
d22 2
a23 1
    cache(NULL)
d28 2
a29 2
  NEW(listener, Listener(multicast));
  if (evs->AddCommunicationObject(listener)==FALSE) return;
d34 1
a34 1
  NoPTM();
d46 4
a49 4
  if (listener!=NULL) {
    evs->RemoveCommunicationObject(listener);
    delete listener;
    listener = NULL;
d83 1
a83 1
void
d90 1
a90 1
    NoPTM();
d92 2
d116 68
d190 2
a191 2
	void *input,   UINT32 inputLength,
	void **output, UINT32 *outputLength)
d374 1
a374 1
  instance = new CacheManager(ptmAddress, multicast);
d423 1
a423 1
Distill(C_DistillerType type, Argument *args, int numberOfArgs,
d427 1
a427 1
  DistillerType distType(type);
a447 218


















#if 0
struct DistillerIDObject {

  RemoteID      rid;
  DistillerType type;
};


CacheManager *CacheManager::cm=NULL;


CacheManager::CacheManager(char *mip, Port mp, char *ip, Port p)
  : ptmAddress(ip, p)
{
  NEW (cache,         DistillerCache);
  NEW (packetHandler, CMPacketHandler);
  NEW (managerThread, Thread);
  NEW (ptmConnection, PTMConnection);
  NEW (listener,      Listener(mip, mp));
  NEW (evs,           EventSystem);
  if (evs->AddCommunicationObject(listener)==FALSE) return;

  if (managerThread->Fork(ForkHelper, (void*) this)==FALSE)
    return;
}


CacheManager::~CacheManager()
{
  DELETE(cache);
  DELETE(packetHandler);

  if (ptmConnection!=NULL) {
    evs->RemoveCommunicationObject(ptmConnection); // might not be in evs at
				                   // all, but that's fine...
    delete ptmConnection;
    ptmConnection = NULL;
  }

  if (listener!=NULL) {
    evs->RemoveCommunicationObject(listener);
    delete listener;
    listener = NULL;
  }

  DELETE(evs);
  DELETE(managerThread);
}


void
CacheManager::Abort(char *string)
{
  LOG("Aborting program: " << string << "\n\n"
      << "Abort status: Global error code = " << GlobalErrorCode << "\n"
      << "              Thread error code = " << ThreadErrorCode << "\n");

  if (GlobalErrorCode!=success) {
    LOG( "              Error file-name   = " << ErrorFilename << "\n"
      << "              Error line number = " << ErrorLineNo   << "\n");
  }

  LOG("              errno = " << errno << "\n");
  if (errno!=0) {
    LOG( "              Errno explanation: " << strerror(errno) << "\n");
  }

  if (cm!=NULL) delete cm;
  exit(-1);
}


void *
CacheManager::ForkHelper(void *args)
{
  ((CacheManager*)args)->Main();
  return 0;
}


void
CacheManager::Main()
{
  if (IsPTMFound()==TRUE) {
    if (ptmConnection->Connect(ptmAddress.ipAddress, ptmAddress.port)==TRUE) {
      evs->AddCommunicationObject(ptmConnection);
    }
    else {
      NoPTM();
    }
  }

  if (evs->Run()==FALSE) {
    Abort("Untrapped error occurred in Distiller Cache Manager");
  }
  else {
    Abort("Distiller Cache Manager exited. Shouldn't have happenned");
  }
}


Bool
CacheManager::HandleEvent(EventSystem */*evs*/, EventType eventType, 
			  void *args)
{
  switch(eventType) {
  case evFindDistillersFromPTM:
    {
      Packet packet(pktFindDistillers,strlen((char*)args)+1, 100, (char*)args);
      packet.Send(ptmConnection);
      break;
    }
  default:
    BoolErrorReturn(errEvSysInvalidEvent);
  }
}


Bool
CacheManager::PTMLocationReceived(RemoteID &newPtmAddress)
{
  if (IsPTMFound()==TRUE) {
    if (ptmAddress.Equal(&newPtmAddress)==TRUE) BoolErrorReturn(success);

    LOG ("PTM already exists at " << ptmAddress << ". Ignoring new location: "
	 << newPtmAddress << '\n');
    BoolErrorReturn(success);
  }
  else {
    ptmAddress = newPtmAddress;
    LOG("Located PTM at " << ptmAddress << ". Trying to connect... ");
    if (ptmConnection->Connect(ptmAddress.ipAddress, ptmAddress.port)==TRUE) {
      LOG("Succeeded\n");
      evs->AddCommunicationObject(ptmConnection);
      BoolErrorReturn(success);
    }
    else {
      LOG("Failed\n");
      NoPTM();
      BoolErrorReturn(success);
    }
  }
}


struct DistillationOperation {
  char *results;
  int  resultLength;
  int  errorCode;

  Condition cv;
};



Bool
InitializeDistillerCache(char *multicastAddress, Port multicastPort, 
			 char *ptmIPAddress, Port ptmPort)
{
  if ((CacheManager::cm = new CacheManager(multicastAddress, multicastPort, 
					   ptmIPAddress, ptmPort))==NULL)
    BoolErrorReturn(errOutOfMemory);
  if (GlobalErrorCode!=success) return FALSE;

  BoolErrorReturn(success);
}


DistillerID
GetDistillerID(C_DistillerType *c_type)
{
  /*DistillerType type(*c_type);
  CachedDistiller *distiller;
  Bool done = FALSE;

  while (done==FALSE) {
    distiller = CacheManager::cm->getCache()->Find(&type);
    if (distiller==NULL) {
      if (CacheManager::cm->GetNewDistiller(&type)==FALSE)
	return 0;
    }
    else done = TRUE;
  }

  DistillerIDObject *idObject = new DistillerIDObject(distiller);
  if (idObject==NULL) ErrorReturn(errOutOfMemory, 0);

  ErrorReturn(success, (DistillerID) idObject);*/
  return 0;
}


void
Send__(char* distillerType)
{
  CacheManager::cm->getEventSystem()->PostEvent(evFindDistillersFromPTM,
						CacheManager::cm,
						(void*)distillerType);
}
#endif
@


1.3
log
@Distiller and proxy communication layers are working.
PTM can auto-spawn distillers
Glurun and load balancing not yet implemented
@
text
@d358 3
d371 1
a371 1
  Packet::UnfreezeData((char*)buffer);
@


1.2
log
@Distiller front end working
Cache manager broken
PTM network stuff not completely done
@
text
@d10 1
d17 6
a22 1
  : ptmAddress(ptm), cache(NULL)
d42 18
d94 186
d283 3
a285 1
  evs->Run();
d287 2
d305 1
d307 1
a307 1
  if (GlobalErrorCode!=success) return FALSE;
d312 29
d349 23
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#include "distiller.h"
d5 3
a7 1
#include "distcache.h"
d12 114
d208 1
a208 1
  if (strcmp(ptmAddress.ipAddress, "")!=0) {
d213 1
a213 2
      strcpy(ptmAddress.ipAddress, "");
      ptmAddress.port = 0;
d227 17
d246 1
a246 1
  if (strcmp(ptmAddress.ipAddress, "")!=0) {
d263 1
a263 2
      strcpy(ptmAddress.ipAddress, "");
      ptmAddress.port = 0;
d270 9
d317 2
a318 2
Bool
Send(DistillerID id)
d320 3
d324 1
@


1.1.1.1
log
@
@
text
@@
