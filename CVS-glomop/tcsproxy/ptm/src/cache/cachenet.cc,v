head	1.28;
access;
symbols
	Yatin-final:1.27.2.3
	Yatin:1.27.0.2
	pre-yatin-merge:1.27
	transend-beta2:1.23
	fox-dev:1.23
	ptm-ng:1.22
	transend-beta-latest:1.22
	Aggregators:1.22
	NoAggregators:1.22
	iang:1.22.0.2
	transend-beta:1.20.0.2
	SOSP:1.20
	stable_ptm:1.13
	merged_preintegrate:1.9
	heisenbug:1.8
	PRE_INTEGRATION:1.8
	initial:1.1.1.1
	initial:1.1.1;
locks; strict;
comment	@// @;


1.28
date	98.01.16.22.16.21;	author yatin;	state Exp;
branches;
next	1.27;

1.27
date	97.10.26.00.30.58;	author fox;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	97.09.22.20.33.01;	author fox;	state Exp;
branches;
next	1.25;

1.25
date	97.09.18.22.45.23;	author yatin;	state Exp;
branches;
next	1.24;

1.24
date	97.09.15.03.09.36;	author yatin;	state Exp;
branches;
next	1.23;

1.23
date	97.06.14.05.05.47;	author yatin;	state Exp;
branches;
next	1.22;

1.22
date	97.04.28.18.46.42;	author yatin;	state Exp;
branches;
next	1.21;

1.21
date	97.04.28.17.35.40;	author fox;	state Exp;
branches;
next	1.20;

1.20
date	97.03.06.07.18.19;	author yatin;	state Exp;
branches;
next	1.19;

1.19
date	97.03.06.05.42.44;	author yatin;	state Exp;
branches;
next	1.18;

1.18
date	97.03.06.02.49.18;	author yatin;	state Exp;
branches;
next	1.17;

1.17
date	97.03.04.17.59.26;	author yatin;	state Exp;
branches;
next	1.16;

1.16
date	97.02.27.01.13.59;	author yatin;	state Exp;
branches;
next	1.15;

1.15
date	97.02.26.04.15.03;	author yatin;	state Exp;
branches;
next	1.14;

1.14
date	97.02.17.03.01.17;	author yatin;	state Exp;
branches;
next	1.13;

1.13
date	97.02.05.21.59.34;	author yatin;	state Exp;
branches;
next	1.12;

1.12
date	97.02.05.20.20.52;	author yatin;	state Exp;
branches;
next	1.11;

1.11
date	97.01.29.06.00.53;	author yatin;	state Exp;
branches;
next	1.10;

1.10
date	97.01.04.09.55.42;	author yatin;	state Exp;
branches;
next	1.9;

1.9
date	96.12.15.13.46.37;	author yatin;	state Exp;
branches;
next	1.8;

1.8
date	96.12.07.01.47.46;	author yatin;	state Exp;
branches;
next	1.7;

1.7
date	96.12.05.01.27.19;	author yatin;	state Exp;
branches;
next	1.6;

1.6
date	96.11.22.09.42.47;	author yatin;	state Exp;
branches;
next	1.5;

1.5
date	96.11.22.08.21.37;	author yatin;	state Exp;
branches;
next	1.4;

1.4
date	96.11.22.00.42.29;	author yatin;	state Exp;
branches;
next	1.3;

1.3
date	96.11.08.21.27.52;	author yatin;	state Exp;
branches;
next	1.2;

1.2
date	96.11.06.23.42.47;	author yatin;	state Exp;
branches;
next	1.1;

1.1
date	96.10.25.00.39.42;	author yatin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.25.00.39.42;	author yatin;	state Exp;
branches;
next	;

1.27.2.1
date	97.11.17.22.07.05;	author yatin;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	97.12.01.22.19.34;	author iang;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	97.12.02.22.04.47;	author iang;	state Exp;
branches;
next	;


desc
@@


1.28
log
@- new wingman frontend
- new wingman aggregators mechanism
- DistillAsync

(merged from branch Yatin-final)
@
text
@#include "log.h"
#include "distdb.h"
#include "cache.h"
#include "cachenet.h"
#include "cacheman.h"
#include <stdlib.h>
#include <errno.h>


gm_Bool
MultipleUsersSocket::Write(gm_Packet *packet)
{
  gm_Bool returnValue;
  writeMutex.Lock();
  returnValue = TcpSocket::Write(packet);
  writeMutex.Unlock();
  return returnValue;
}


gm_Bool
MultipleUsersSocket::Read(gm_Packet *packet)
{
  gm_Bool returnValue;
  readMutex.Lock();
  returnValue = TcpSocket::Read(packet);
  readMutex.Unlock();
  return returnValue;
}


void
ThreadedSocket::ThreadMain()
{
  fd_set readfds, exceptfds;
  int returnValue, id;

  IncrReference();

  Mutex::Log_("started ThreadMain", "", (Mutex*)this);
  while (gm_True) {
    if (IsDeleted()==gm_True) break;

    id = getID();
    FD_ZERO(&readfds);
    FD_ZERO(&exceptfds);
    FD_SET(id, &readfds);
    FD_SET(id, &exceptfds);
    returnValue = select(id+1, &readfds, (fd_set*)NULL, NULL , NULL);
    Mutex::Log_("ThreadMain selected", "", (Mutex*)this);
    if (returnValue < 0) {
      if (errno==EINTR) continue;
      if (errno!=EBADF) {
	gm_Log("ThreadedSocket(" << name << ") failed on select. Errno was " 
	       << errno << " (" << strerror(errno) << ")\n");
	abort();
      }
      break;
    }

    if (EvSelect(evs)==gm_False) {
      gm_Log("ThreadedSocket(" << name << ") failed on EvSelect()\n");
      Error::Print();
      abort();
    }
  }

  gm_Log("ThreadedSocket(" << name << ") is exiting\n");
  Mutex::Log_("ThreadMain exiting", "", NULL);
  DecrReference();
}


gm_Bool
FE_PTMConnection::EvConnectionBroken(EventSystem */*evs*/)
{
  return CacheManager::getInstance()->ClosePTMConnection__();
}


/*
 * Format: <number-of-distillers>[per-distiller-info]|...\0
 */
gm_Bool
DistillerInfoHandler::Handle(IStream &stream, gm_Bool completeUpdate_)
{
  stream >> Binary(gm_True) >> numberOfDistillers >> Delimit('|');
  if (stream.IsGood()==gm_False) return gm_False;
  //XXXgm_Log("Got " << numberOfDistillers << " distillers **********\n");
  streamPtr = &stream;
  completeUpdate = completeUpdate_;
  return CacheManager::getInstance()->UpdateCache__(this);
}


gm_Bool
DistillerInfoHandler::getNext(BasicDistiller *record)
{
  if (idx >= numberOfDistillers) {
    // return gm_False *without* setting Error::status
    return gm_False;
  }

  idx++;
  (*streamPtr) >> (*record) >> Skip;
  if (streamPtr->IsGood()==gm_False) return gm_False;
  return gm_True;
}

  
class PTMBeaconHandler : public DistillerInfoHandler {
public:
  gm_Bool Handle(gm_Packet *packet);
};


/*
 * Format: <ptm-ip-address/port>|distiller-info
 */
gm_Bool
PTMBeaconHandler::Handle(gm_Packet *packet)
{
  RemoteID rid;
  UINT32 dummyRandomID;
  IStream stream(packet->getData(), packet->getLength());

  stream >> Delimit('|') >> rid >> Skip >> Binary(gm_True) >> dummyRandomID 
	 >> Binary(gm_False) >> Skip;
  if (stream.IsGood()==gm_False || rid.port==0) return gm_False;

  if (CacheManager::getInstance()->EvPTMLocationReceived__(rid)==gm_False) {
    // the only error that could have occurred is errOutOfMemory
    // all other errors are trapped inside CacheManager::PTMLocationReceived
    return gm_False;
  }

  return DistillerInfoHandler::Handle(stream, gm_True);
}


class AskForDistillerReplyHandler : public DistillerInfoHandler {
public:
  gm_Bool Handle(gm_Packet *packet);
};


gm_Bool
AskForDistillerReplyHandler::Handle(gm_Packet *packet)
{
  UINT32 replyStatus;
  IStream stream(packet->getData(), packet->getLength());

  stream >> Delimit('|') >> replyStatus >> Skip;

  if (replyStatus==ptmOk) {
    if (DistillerInfoHandler::Handle(stream, gm_False)==gm_False) 
      return gm_False;
  }

  return CacheManager::getInstance()->getEventSystem()->
    SendReplyReceivedEvent(packet->getRequestReplyID(), (void*)replyStatus);
}
  

gm_Bool
FE_PTMConnection::EvPacketReceived(EventSystem */*evs*/, gm_Packet *packet)
{
  switch (packet->getType()) {
  case pktAskForDistillerReply: 
    {
      AskForDistillerReplyHandler handler;
      return handler.Handle(packet);
    }

  case pktPTMBeacon: 
    {
      gm_Log("Received unicast beacon from PTM\n");
      PTMBeaconHandler handler;
      gm_Bool returnValue = handler.Handle(packet);
      if (returnValue==gm_False) {
	gm_Log("Error in pktPTMBeacon!!!\n");
	Error::Print();
      }
      return returnValue;
    }

  case pktFlushNCache:
    {
      gm_Log("Flushing negative cache at frontend\n");
      CacheManager::getInstance()->FlushNCache();
      return gm_True;
    }
  default:
    Return(gm_False, errInvalidPacketType);
  }  
}


gm_Bool
SharedBus::EvPacketReceived(EventSystem */*evs*/, gm_Packet *packet)
{
  switch (packet->getType()) {
  case pktPTMBeacon: 
    {
      PTMBeaconHandler handler;
      return handler.Handle(packet);
    }

  case pktWillStartPTM:
    {
      if (CacheManager::getInstance()->IsConnectedToPTM__()==gm_True)
	return gm_True;

      // someone else is going to start the PTM; I'm going to disable my timer
      // and wait for the PTM to start up
      return CacheManager::getInstance()->RestartPTMTimer__();
    }

  default:
    Return(gm_False, errInvalidPacketType);
  }  
}


DistillerConnection::DistillerConnection(CachedDistiller *distiller_)
  : ThreadedSocket(CacheManager::getInstance()->getEventSystem(),
		   "DistillerConnection"),
    gm_PacketHandler(),
    distiller(distiller_) 
{
  distiller->IncrReference();
}


DistillerConnection::~DistillerConnection()
{
  distiller->DecrReference();
}


/*void 
DistillerConnection::RemoveAllRequests()
{
  DistillerRequest *request;
  while (pendingRequests.IsEmpty()==gm_False) {
    request = pendingRequests.RemoveFromHead();
    request->EvDistillerConnectionBroken();
  }
}*/



gm_Bool
DistillerConnection::EvConnectionBroken(EventSystem */*evs*/)
{
  CachedDistiller *dist = distiller;
  // notify waiting requests
  dist->IncrReference();
  dist->EvConnectionBroken(); // dist->EvConnectionBroken results in 'this'
                              // being deleted
  dist->DecrReference();
  return gm_True;
}


gm_Bool
DistillerConnection::EvPacketReceived(EventSystem *evs, gm_Packet *packet)
{
  UINT32 statusUINT32;
  switch (packet->getType()) {
  case pktDistillerOutput:
    {
      DistillerReply reply;
      IStream stream(packet->getData(), packet->getLength());
      stream >> Binary(gm_True) >> statusUINT32 >> reply.output.data.length 
	     >> Binary(gm_False);
      if (stream.IsGood()==gm_False) {
	return gm_False;
      }

      reply.status = (DistillerStatus) statusUINT32;
      if (reply.output.data.length > 0) {
	reply.output.data.data = DistillerMalloc(1+reply.output.data.length);
	if (reply.output.data.data==NULL) {
	  Return(gm_False, errOutOfMemory);
	}
	reply.output.data.maxLength = 1+reply.output.data.length;
	
	stream.Extract(reply.output.data.data, reply.output.data.length);
	if (stream.IsGood()==gm_False) {
	  return gm_False;
	}
        ((char*)reply.output.data.data)[reply.output.data.length] = '\0';
      }
      else {
	reply.output.data.data = NULL;
      }

      stream >> Binary(gm_True) >> reply.output.metadata.length
	     >> Binary(gm_False);
      if (reply.output.metadata.length > 0) {
	reply.output.metadata.data = 
	  DistillerMalloc(1+reply.output.metadata.length);
	if (reply.output.metadata.data==NULL) {
	  Return(gm_False, errOutOfMemory);
	}
	reply.output.metadata.maxLength = 1+reply.output.metadata.length;

	stream.Extract(reply.output.metadata.data, 
		       reply.output.metadata.length);
	if (stream.IsGood()==gm_False) {
	  return gm_False;
	}
        ((char*)reply.output.metadata.data)[reply.output.metadata.length] = '\0';
      }
      else {
	reply.output.metadata.data = NULL;
      }


      stream >> reply.output.mimeType;
      if (stream.IsGood()==gm_False) {
	return gm_False;
      }

      char buf[80];
      sprintf(buf, "request-reply id = %lu", packet->getRequestReplyID());
      Mutex::Log_(buf, "", NULL);
      return ((RequestReplyEventSystem*)evs)->SendReplyReceivedEvent
	(packet->getRequestReplyID(), &reply);
    }

  default:
    Return(gm_False, errInvalidPacketType);
  }
}







DistillerRequest::DistillerRequest(CachedDistiller *dist_)
  : RequestReply(CacheManager::getInstance()->getEventSystem(),
		 SECONDS(DistillerRequestTimeout_ms),
		 USECONDS(DistillerRequestTimeout_ms)), 
    dist(dist_), reply(), stopWaiting(gm_False), mutex("*-distreq")
{
}


gm_Bool
DistillerRequest::Send(DistillerConnection *connection, Argument *args, 
		       int numberOfArgs, DistillerInput *input)
{
  OStream stream;
  int idx;


  SetThreadState(THR_DISTILLERSEND);
  // marshall the arguments

  stream << Binary(gm_True) << numberOfArgs;
  if (stream.IsGood()==gm_False) return gm_False;

  for (idx=0; idx < numberOfArgs; idx++) {
    stream << (UINT32) args->type << ARG_ID(*args);
    switch(args->type) {
    case typeInt:       stream << ARG_INT(*args); break;
    case typeString:    stream << ARG_STRING(*args) << '\0'; break;
    case typeDouble:
      {
	char   doubleString[MAX_ARG_STRING];
	double arg_double = ARG_DOUBLE(*args);
	sprintf(doubleString, "%f", arg_double);
	stream << doubleString << '\0'; 
	break;
      }
    }
    args++;

    if (stream.IsGood()==gm_False) return gm_False;
  }


  // marshall the data
  if (input->data.data==NULL) input->data.length = 0;

  stream << Binary(gm_True) << input->data.length << Binary(gm_False);
  if (stream.IsGood()==gm_False) return gm_False;

  if (input->data.length > 0) {
    stream.Append(input->data.data, input->data.length);
    if (stream.IsGood()==gm_False) return gm_False;
  }

  // marshall the metadata
  if (input->metadata.data==NULL) input->metadata.length = 0;

  stream << Binary(gm_True) << input->metadata.length << Binary(gm_False);
  if (stream.IsGood()==gm_False) return gm_False;

  if (input->metadata.length > 0) {
    stream.Append(input->metadata.data, input->metadata.length);
    if (stream.IsGood()==gm_False) return gm_False;
  }

  // finally, the return MIME type (really part of the metadata now...)
  stream << input->mimeType;
  if (stream.IsGood()==gm_False) return gm_False;
 
  gm_Packet packet(pktDistillerInput, stream.getLength(), getID(), 
		stream.getData());
  return connection->Write(&packet);
}

// Returns gm_True if we got a result, gm_False if tv expired (or error).
gm_Bool
DistillerRequest::Wait(struct timeval *tv)
{
  int waitres = 0;
  SetThreadState(THR_DISTILLERWAIT);
  mutex.Lock();
  while (stopWaiting == gm_False && waitres == 0) {
    // we haven't yet got a reply, so wait
    waitres = condition.TimedWait(&mutex, tv);
  }
  mutex.Unlock();
  return waitres ? gm_False : gm_True;
}

gm_Bool
DistillerRequest::SendAndWait(DistillerConnection *connection, Argument *args, 
			      int numberOfArgs, DistillerInput *input)
{
  if (Send(connection, args, numberOfArgs, input)==gm_False) return gm_False;
  char buf[80];
  sprintf(buf, "waiting for reply id = %lu", getID());
  Mutex::Log_(buf, "", NULL);
  SetThreadState(THR_DISTILLERWAIT);
  mutex.Lock();
  while (stopWaiting == gm_False) {
    // we haven't yet got a reply, so wait
    condition.Wait(&mutex);
  }
  mutex.Unlock();
  sprintf(buf, "got reply %d", reply.status);
  Mutex::Log_(buf, "", NULL);
  return gm_True;
}

void
DistillerRequest::Destroy(void)
{
    mutex.Lock();
    getOutput()->Free();
    if (!stopWaiting) {
	reply.status = distFatalError;
	stopWaiting = gm_True;
	dist->RemoveRequest_(this);
	condition.Signal();
    }
    dist->DecrPendingCount();
    dist->DecrReference();
    mutex.Unlock();
}


gm_Bool
DistillerRequest::EvReplyReceived(RequestReplyEventSystem */*evs*/, void *args)
{
  DistillerReply *distReply = (DistillerReply*) args;
  mutex.Lock();
  if (!stopWaiting) {
      reply = *distReply;
      distReply->output.DontFreeMe();
      stopWaiting = gm_True;
      dist->RemoveRequest_(this);
      condition.Signal();
  }
  mutex.Unlock();
  return gm_True;
}


gm_Bool
DistillerRequest::EvTimer(RequestReplyEventSystem */*evs*/)
{
  mutex.Lock();
  if (!stopWaiting) {
      reply.status = distReplyTimeout;
      stopWaiting = gm_True;
      dist->RemoveRequest_(this);
      condition.Signal();
  }
  mutex.Unlock();
  return gm_True;
}


void
DistillerRequest::EvDistillerConnectionBroken()
  // distMutex has already been locked; so don't lock it again
  // 'this' has already been removed from dist->pendingRequests, 
  // so don't remove it
{
  mutex.Lock();
  if (!stopWaiting) {
      reply.status = distConnectionBroken;
      stopWaiting = gm_True;
      condition.Signal();
  }
  mutex.Unlock();
}
@


1.27
log
@changed ptm to always alloc and fill in a null term when receiving
metadata (headers) from workers.  also added StringBuffer function for
setting a distillerbuffer to an ascii string, which implements the same
behavior (adding the null term and setting length and maxLength appropriately).
@
text
@d49 1
a49 1
    returnValue = select(id+1, &readfds, (fd_set*)NULL, &exceptfds,NULL);
d348 1
a348 1
    dist(dist_), reply(), replyReceived(gm_False), mutex("*-distreq")
d418 14
a436 1
  mutex.Lock();
d442 2
a443 1
  if (replyReceived==gm_False) {
d447 1
a449 1
  mutex.Unlock();
d453 16
d475 7
a481 5
  reply = *distReply;
  distReply->output.DontFreeMe();
  replyReceived = gm_True;
  dist->RemoveRequest_(this);
  condition.Signal();
d491 6
a496 4
  reply.status = distReplyTimeout;
  replyReceived= gm_True;
  dist->RemoveRequest_(this);
  condition.Signal();
d508 7
a514 3
  reply.status = distConnectionBroken;
  replyReceived= gm_True;
  condition.Signal();
@


1.27.2.1
log
@- Modularized the wingman frontend by splitting wing_go_proc into
  multiple smaller functions

- New aggregator mechanism for wingman proxies. The WingDispatch worker
  receives a request with a special content-type application/x-wingman-agg.
  The body of the request contains the full aggregator url

  The worker should return a valid HTTP response, which might be a
  pilot-ready document (i.e. an x-wingman/* document) or an HTTP
  redirect to a new URL, or whatever it chooses!)

- The WingDispatcher is now expected to weed out unintelligible content-types
  and return a content-type of x-wingman/<integer> to the frontend, where
  <integer> represents the integral content type returned to the pilot client.

- Agglist: this appears at the dispatcher as a special aggregator request
  with a url of agg://agglist/ (this URL is actually defined in the
  gm_options file, so the worker should check against the gm_options
  entry, rather than a hard-coded entry). The worker that handles this
  request *MUST* return a document with content type
  x-wingman/2 and the actual agglist as part of the data.

  For old browsers, the data part of this response is stuffed into an
  appropriate metadata field by the frontend before sending the reply to
  the client (i.e. it is backward compatible). For browsers with the new
  version number, the browser will no longer set any special flags in the
  metadata field of the client request. Instead it will explicitly request
  for the agg://agglist/ url. It'll check the ContentType field in the
  response for content type 2 to match up the correct response.

- Created a new version number for the agglist changes:
  #define CLIENT_VERSION_NEWAGG 0x01050200

- gm_options changes:
  Here are the three new gm_options entries for wingman: (the
  wingman.text.prefetch_href replaces the old prefetch.href entry)

  wingman.about_url: http://www.isaac.cs.berkeley.edu/pilot/wingman/about-
  wingman.agglist_url: agg://agglist/
  wingman.text.prefetch_href: 10

- PTM changes:
  - Background distillers work. Specify the -e flag before the -- in the
    gm_options line for the distiller. The PTM will IMMEDIATELY respawn the
    distiller if it crashes. This mechanism is still very simple and naive
  - Distillers can rename themselves: API function DistillerReregister.
@
text
@d49 1
a49 1
    returnValue = select(id+1, &readfds, (fd_set*)NULL, NULL , NULL);
@


1.27.2.2
log
@Added DistillAsync and friends
@
text
@d348 1
a348 1
    dist(dist_), reply(), stopWaiting(gm_False), mutex("*-distreq")
a417 14
// Returns gm_True if we got a result, gm_False if tv expired (or error).
gm_Bool
DistillerRequest::Wait(struct timeval *tv)
{
  int waitres = 0;
  SetThreadState(THR_DISTILLERWAIT);
  mutex.Lock();
  while (stopWaiting == gm_False && waitres != -1) {
    // we haven't yet got a reply, so wait
    waitres = condition.TimedWait(&mutex, tv);
  }
  mutex.Unlock();
  return waitres ? gm_False : gm_True;
}
d423 1
d429 1
a429 2
  mutex.Lock();
  while (stopWaiting == gm_False) {
a432 1
  mutex.Unlock();
d435 1
a438 16
void
DistillerRequest::Destroy(void)
{
    mutex.Lock();
    getOutput()->Free();
    if (!stopWaiting) {
	reply.status = distFatalError;
	stopWaiting = gm_True;
	dist->RemoveRequest_(this);
	condition.Signal();
    }
    dist->DecrPendingCount();
    dist->DecrReference();
    mutex.Unlock();
}

d445 5
a449 7
  if (!stopWaiting) {
      reply = *distReply;
      distReply->output.DontFreeMe();
      stopWaiting = gm_True;
      dist->RemoveRequest_(this);
      condition.Signal();
  }
d459 4
a462 6
  if (!stopWaiting) {
      reply.status = distReplyTimeout;
      stopWaiting = gm_True;
      dist->RemoveRequest_(this);
      condition.Signal();
  }
d474 3
a476 7
  mutex.Lock();
  if (!stopWaiting) {
      reply.status = distConnectionBroken;
      stopWaiting = gm_True;
      condition.Signal();
  }
  mutex.Unlock();
@


1.27.2.3
log
@DistillRendezvous() now works on Solaris
@
text
@d425 1
a425 1
  while (stopWaiting == gm_False && waitres == 0) {
@


1.26
log
@max_length wasn't getting set properly in distiller stub routines in
cachenet.cc and distnet.cc.  also modified SET_ARG_STRING macro to copy
at most N-1 characters of the arg, to ensure there is room for strncpy
to add a terminating null
@
text
@d283 1
a283 1
	reply.output.data.data = DistillerMalloc(reply.output.data.length);
d287 1
a287 1
	reply.output.data.maxLength = reply.output.data.length;
d293 1
d303 1
a303 1
	  DistillerMalloc(reply.output.metadata.length);
d307 1
a307 1
	reply.output.metadata.maxLength = reply.output.metadata.length;
d314 1
@


1.25
log
@added mash_stub
mash_stub is compiled only if --with-mashdir flag is set
added a --enable/disable-mkdep flag to configure
configure can read default arguments from a special file .configure in
the toplevel tcsproxy directory
@
text
@d287 1
d306 2
a307 1
	
@


1.24
log
@PTM Changes:

* libdist.a now includes libptmstub.a. If you wish to invoke other
distillers from a distiller, you must call InitializeDistillerCache in
your DistillerInit method.

Please note that the arguments to InitializeDistillerCache have changed
slightly. Check out ptm/src/dist/distengine.c for an example of invoking
distillers from other distillers. I have updated the frontend to
reflect the change in arguments.

* DistillerMain times out after a certain time interval. The default
timeout is 60 seconds. You can override that on a per-distiller basis
through the gm_options file (See ahead).

* The "dist.blah:" line format has changed slightly. Here's the new
format:

dist.transend/foo/bar: sbin/foobar_munger <auto-launch-limit-ms> \
			<averaging-interval-ms> <distiller args ...> \
			-- <additional args>

Currently the auto-launch-limit-ms param is the max tolerable queue
length. Set it to zero if you want to disable auto-launching.

For both <auto-launch-limit-ms> and <averaging-interval-ms>, you can
specify - or 0 to use the built-in default value.

<distiller-args> can be any of the command line arguments that the
distiller can understand. Specifically you can use the -n argument to se
the notification timeout and -m to set the DistillerMain timeout.

Please update your gm_options file to the new format. Look at
gm_options.yatin for examples.


* The PTM Makefile does dependencies correctly (finally!!!). The
dependency file has been generated currently for Linux. If you are
compiling on a Solaris box, it might complain about not finding some of
the linux .h files. Simply run "make depend" in the ptm subdirectory on
your solaris box. Hopefully it'll work. If it doesn't work, comment out
the "source Makefile.depend" line from your Makefile.
@
text
@d11 1
a11 1
MultipleUsersSocket::Write(Packet *packet)
d22 1
a22 1
MultipleUsersSocket::Read(Packet *packet)
d113 1
a113 1
  gm_Bool Handle(Packet *packet);
d121 1
a121 1
PTMBeaconHandler::Handle(Packet *packet)
d143 1
a143 1
  gm_Bool Handle(Packet *packet);
d148 1
a148 1
AskForDistillerReplyHandler::Handle(Packet *packet)
d166 1
a166 1
FE_PTMConnection::EvPacketReceived(EventSystem */*evs*/, Packet *packet)
d200 1
a200 1
SharedBus::EvPacketReceived(EventSystem */*evs*/, Packet *packet)
d228 1
a228 1
    PacketHandler(),
d267 1
a267 1
DistillerConnection::EvPacketReceived(EventSystem *evs, Packet *packet)
d409 1
a409 1
  Packet packet(pktDistillerInput, stream.getLength(), getID(), 
@


1.23
log
@combined distillers.db into gm_options
added re-reading of the options file to the PTM, thru a SIGUSR1
added arbitrary arguments capability to distillers. Extra args are passed
on to DistillerInit()
added functionality to flush the negative cache when the PTM re-reads the
options file or when it restarts
@
text
@d75 1
a75 1
PTMConnection::EvConnectionBroken(EventSystem */*evs*/)
d166 1
a166 1
PTMConnection::EvPacketReceived(EventSystem */*evs*/, Packet *packet)
@


1.22
log
@Added the DistillerBuffer data structure to provide a more elegant way of
freeing buffers between the library and the main program
@
text
@d187 6
@


1.21
log
@added metadata support to distiller data struct
@
text
@d269 1
a269 1
      stream >> Binary(gm_True) >> statusUINT32 >> reply.output.length 
d276 3
a278 3
      if (reply.output.length > 0) {
	reply.output.data = new char [reply.output.length];
	if (reply.output.data==NULL) {
d282 1
a282 1
	stream.Extract(reply.output.data, reply.output.length);
d288 1
a288 1
	reply.output.data = NULL;
d291 6
a296 4
      stream >> Binary(gm_True) >> reply.output.metalength >> Binary(gm_False);
      if (reply.output.metalength > 0) {
	reply.output.metadata = new char [reply.output.metalength];
	if (reply.output.metadata==NULL) {
d300 2
a301 1
	stream.Extract(reply.output.metadata, reply.output.metalength);
d307 1
a307 1
	reply.output.metadata = NULL;
d338 1
a338 1
    dist(dist_), replyReceived(gm_False), mutex("*-distreq")
d378 1
a378 1
  if (input->data==NULL) input->length = 0;
d380 1
a380 1
  stream << Binary(gm_True) << input->length << Binary(gm_False);
d383 2
a384 2
  if (input->length > 0) {
    stream.Append(input->data, input->length);
d389 1
a389 1
  if (input->metadata==NULL) input->metalength = 0;
d391 1
a391 1
  stream << Binary(gm_True) << input->metalength << Binary(gm_False);
d394 2
a395 2
  if (input->metalength > 0) {
    stream.Append(input->metadata, input->metalength);
d436 1
@


1.20
log
@Modified the frontend and libptmstub to provide a more detailed "blinking
light" view of the stuff being done inside the Distill() call
@
text
@d291 16
d385 12
@


1.19
log
@stupid fixes
@
text
@d332 1
d387 1
@


1.18
log
@Modified the PTM code to make a whole bunch of #defines customizable thru
the gm_options/distillers.db file
@
text
@d42 2
d68 2
a70 2
  gm_Log("ThreadedSocket(" << name << ") is exiting()\n");
  Mutex::Log_("ThreadMain exiting", "", NULL);
@


1.17
log
@Minor modifications to the PTM
@
text
@d52 2
a53 1
	gm_Log("ThreadedSocket failed on select\n");
d60 2
a61 1
      gm_Log("Threaded socket failed on EvSelect()\n");
d67 1
a67 1
  gm_Log("ThreadedSocket is exiting()\n");
a74 1
  gm_Log("PTM connection lost; trying to listen for new PTM address\n");
d83 1
a83 1
DistillerInfoHandler::Handle(IStream &stream)
d87 1
d89 1
d135 1
a135 1
  return DistillerInfoHandler::Handle(stream);
d154 2
a155 1
    if (DistillerInfoHandler::Handle(stream)==gm_False) return gm_False;
d172 13
d218 2
a219 1
  : ThreadedSocket(CacheManager::getInstance()->getEventSystem()),
@


1.16
log
@Added priorities to remote execution
Added FE_getDistillerStatusString to cacheman.cc
Modified PTM invocation from the frontend to use the gm_options file rather
than pass all options via the command line
@
text
@d255 1
@


1.15
log
@Major changes to the PTM. The PTM can now auto-launch new distillers when
the load on the system gets too high. The frontend stub has a separate
thread per connection to the distillers and PTM to handle network events
@
text
@d205 1
d211 1
@


1.14
log
@Major changes to the PTM stuff. The previous version has been tagged
stable_ptm.

The new version uses a new LinkedList library; the distiller-cache at
the frontend was rewritten to remove some concurrency bugs
@
text
@d7 1
d11 1
a11 1
MultipleUsersSocket::Write(char *data, int size)
d14 3
a16 3
  mutex.Lock();
  returnValue = TcpSocket::Write(data, size);
  mutex.Unlock();
d21 2
a22 2
int
MultipleUsersSocket::Read(char *data, int size)
d24 4
a27 4
  int returnValue;
  mutex.Lock();
  returnValue = TcpSocket::Read(data, size);
  mutex.Unlock();
d32 38
d74 1
a74 1
  return CacheManager::getInstance()->ClosePTMConnection();
d87 1
a87 1
  return CacheManager::getInstance()->UpdateCache(this);
a105 29
#if 0
  UINT32 numberOfDistillers, idx;
  DistillerCache *cache;
  CachedDistiller record;

  stream >> Binary(gm_True) >> numberOfDistillers;
  if (stream.IsGood()==gm_False) return gm_False;

  cache = CacheManager::getInstance()->getCache();
  cache->Lock();
  cache->MarkAsValid(gm_False);

  stream >> Delimit('|');
  for (idx=0; idx < numberOfDistillers; idx++) {
    stream >> record >> Skip;
    if (stream.IsGood()==gm_False) {
      cache->MarkAsValid(gm_True);
      cache->Unlock();
      return gm_False;
    }

    if (cache->Update(&record)==gm_False) { cache->Unlock(); return gm_False;}
  }
  cache->Sweep();
  cache->Unlock();
  return gm_True;
#endif


d126 1
a126 1
  if (CacheManager::getInstance()->EvPTMLocationReceived(rid)==gm_False) {
d175 1
a175 1
SharedBus::EvPacketReceived(EventSystem *evs, Packet *packet)
d186 3
d191 1
a191 6
      StartPTMTimer *startTimer;
      startTimer = CacheManager::getInstance()->getStartPTMTimer();
      if (startTimer!=NULL) startTimer->Disable();
      CacheManager::getInstance()->SetStartPTMTimer
	(new StartPTMTimer(evs, StartPTMTimer::RandomDelay()));
      return gm_True;
d200 13
d224 1
d274 3
d296 1
a296 1
    dist(dist_)
d302 2
a303 1
DistillerRequest::Send(Argument *args, int numberOfArgs, DistillerInput *input)
d350 1
a350 1
  return dist->Send_(&packet);
d355 2
a356 2
DistillerRequest::SendAndWait(Argument *args, int numberOfArgs, 
			      DistillerInput *input)
d358 12
a369 3
  if (dist->AddRequest_(this)==gm_False) return gm_False;
  if (Send(args, numberOfArgs, input)==gm_False) return gm_False;
  condition.Wait(dist->getMutex());
d378 1
a378 1
  dist->getMutex()->Lock();
d380 1
d383 1
a383 1
  dist->getMutex()->Unlock();
d391 1
a391 1
  dist->getMutex()->Lock();
d393 1
d396 1
a396 1
  dist->getMutex()->Unlock();
d408 1
@


1.13
log
@Forgot to remove minor bugs before previous commit
@
text
@a38 6
class DistillerInfoHandler {
public:
  gm_Bool Handle(IStream &istream);
};


d45 23
d84 1
d88 1
a88 1
    if (cache->Update(&record)==gm_False) return gm_False;
d93 1
a93 1
}
d116 1
a116 1
  if (CacheManager::getInstance()->PTMLocationReceived(rid)==gm_False) {
d192 1
a192 1
void 
a195 1
  mutex.Lock();
d200 1
a200 2
  mutex.Unlock();
}
d206 1
d208 5
a212 3
  RemoveAllRequests();

  return distiller->Disconnect();
a219 3
  DistillerCache *cache = CacheManager::getInstance()->getCache();

  cache->Lock();
a227 1
	cache->Unlock();
a233 1
	  cache->Unlock();
a238 1
	  cache->Unlock();
a248 1
	cache->Unlock();
a251 1
      cache->Unlock();
a256 1
    cache->Unlock();
d259 113
@


1.12
log
@PTM stub now does a random selection from multiple distillers
@
text
@d174 13
@


1.11
log
@Modified the ptm stub and distiller stub to use the new distiller API
@
text
@a176 2
  DistillerRequest *request;

d178 1
a178 4
  while (pendingRequests.IsEmpty()==gm_False) {
    request = pendingRequests.RemoveFromHead();
    request->EvDistillerConnectionBroken();
  }
@


1.10
log
@Modifications made to the PTM to remove bugs found while in India.
@
text
@d197 1
a197 1
  case pktDistillerStatus:
d199 1
a199 4
      if (status.IsFull()==gm_True) {
	cache->Unlock();
	Return(gm_False, errOutOfContextPacket);
      }
d201 2
a202 1
      stream >> Binary(gm_True) >> statusUINT32;
a206 7
      
      status.status         = (DistillerStatus) statusUINT32;
      status.requestReplyID = packet->getRequestReplyID();
      status.SetFull(gm_True);
      cache->Unlock();
      return gm_True;
    }
d208 15
a222 5
  case pktDistillerReply:
    {
      if (status.IsFull()==gm_False) {
	cache->Unlock();
	Return(gm_False, errOutOfContextPacket);
d224 4
a227 4
      if (packet->getRequestReplyID()!=status.requestReplyID) {
	gm_Log("Invalid ID's received for status and reply packets. "
	       "Ignoring the packets\n");	
	status.SetFull(gm_False);
d229 1
a229 1
	return gm_True;
a231 5
      status.SetFull(gm_False);
      DistillerReply reply;
      reply.status     = status.status;
      reply.data       = packet->FreezeData();
      reply.dataLength = packet->getLength();
d234 1
a234 1
	(status.requestReplyID, &reply);
@


1.9
log
@Yatin's first commit from India
@
text
@d10 1
a10 1
MultipleWritersSocket::Write(char *data, int size)
d20 11
d34 1
a34 1
  LOG ("PTM connection lost; trying to listen for new PTM address\n");
d59 1
d73 2
a74 1
  gm_BoolErrorReturn(success);
d127 1
a127 1
    SendReplyReceivedEvent(packet->getRequestReplyID(), &replyStatus);
d141 1
a141 1
    gm_BoolErrorReturn(errInvalidPacketType);
d165 1
a165 1
      gm_BoolErrorReturn(success);
d169 1
a169 1
    gm_BoolErrorReturn(errInvalidPacketType);
d175 1
a175 1
DistillerConnection::EvConnectionBroken(EventSystem *evs)
d185 1
a185 4
  evs->RemoveCommunicationObject(this);
  delete this;

  return gm_True;
d193 1
d195 1
d199 4
a202 1
      if (status.IsFull()==gm_True) gm_BoolErrorReturn(errOutOfContextPacket);
d205 4
a208 1
      if (stream.IsGood()==gm_False) return gm_False;
d213 2
a214 1
      gm_BoolErrorReturn(success);
d219 4
a222 1
      if (status.IsFull()==gm_False) gm_BoolErrorReturn(errOutOfContextPacket);
d224 2
a225 2
	LOG("Invalid ID's received for status and reply packets. "
	    "Ignoring the packets\n");	
d227 2
a228 1
	gm_BoolErrorReturn(success);
d236 1
d242 2
a243 1
    gm_BoolErrorReturn(errInvalidPacketType);
@


1.8
log
@Just doing a commit before leaving for India
@
text
@a80 8
  DEBUG("Beacon: ");
  char *d=packet->getData();
  for(int i=0; i<packet->getLength(); i++) {
    char ch = *d++;
    DEBUG( ((ch <32) ? '?' : (char)ch) );
  }
  DEBUG('\n');

@


1.7
log
@Modified Bool, FALSE and TRUE to gm_Bool, gm_False and gm_True respectively
@
text
@d81 8
@


1.6
log
@The proxy front-ends can now spawn new PTM if it detects that there isn't
any PTM running.
@
text
@d9 1
a9 1
Bool
d12 1
a12 1
  Bool returnValue;
d20 1
a20 1
Bool
d30 1
a30 1
  Bool Handle(IStream &istream);
d37 1
a37 1
Bool
d44 2
a45 2
  stream >> Binary(TRUE) >> numberOfDistillers;
  if (stream.IsGood()==FALSE) return FALSE;
d48 1
a48 1
  cache->MarkAsValid(FALSE);
d53 3
a55 3
    if (stream.IsGood()==FALSE) {
      cache->MarkAsValid(TRUE);
      return FALSE;
d58 1
a58 1
    if (cache->Update(&record)==FALSE) return FALSE;
d61 1
a61 1
  BoolErrorReturn(success);
d67 1
a67 1
  Bool Handle(Packet *packet);
d74 1
a74 1
Bool
d81 3
a83 3
  stream >> Delimit('|') >> rid >> Skip >> Binary(TRUE) >> dummyRandomID 
	 >> Binary(FALSE) >> Skip;
  if (stream.IsGood()==FALSE || rid.port==0) return FALSE;
d85 1
a85 1
  if (CacheManager::getInstance()->PTMLocationReceived(rid)==FALSE) {
d88 1
a88 1
    return FALSE;
d97 1
a97 1
  Bool Handle(Packet *packet);
d101 1
a101 1
Bool
d110 1
a110 1
    if (DistillerInfoHandler::Handle(stream)==FALSE) return FALSE;
d118 1
a118 1
Bool
d128 1
a128 1
    BoolErrorReturn(errInvalidPacketType);
d133 1
a133 1
Bool
d152 1
a152 1
      BoolErrorReturn(success);
d156 1
a156 1
    BoolErrorReturn(errInvalidPacketType);
d161 1
a161 1
Bool
d167 1
a167 1
  while (pendingRequests.IsEmpty()==FALSE) {
d175 1
a175 1
  return TRUE;
d179 1
a179 1
Bool
d187 1
a187 1
      if (status.IsFull()==TRUE) BoolErrorReturn(errOutOfContextPacket);
d189 2
a190 2
      stream >> Binary(TRUE) >> statusUINT32;
      if (stream.IsGood()==FALSE) return FALSE;
d194 2
a195 2
      status.SetFull(TRUE);
      BoolErrorReturn(success);
d200 1
a200 1
      if (status.IsFull()==FALSE) BoolErrorReturn(errOutOfContextPacket);
d204 2
a205 2
	status.SetFull(FALSE);
	BoolErrorReturn(success);
d208 1
a208 1
      status.SetFull(FALSE);
d218 1
a218 1
    BoolErrorReturn(errInvalidPacketType);
@


1.5
log
@Modified the logging mechanism to use the monitor entity
Multiple PTM detect each other and die gracefully
Still need to do auto start of PTM by the proxy front end
@
text
@a108 2
  DEBUG("Got reply: " << replyStatus << ", ID=" 
	<< packet->getRequestReplyID() << '\n');
d143 1
a143 1
  /*case pktWillStartPTM:
d145 7
a151 2
      CacheManager::getInstance()->getStartPTMTimer()->Disable();
      CacheManager::getInstance()->SetStartPTMTimer(new StartPTMTimer(evs));
d153 1
a153 1
    }*/
@


1.4
log
@Just before adding stuff for using the monitoring GUI
@
text
@d1 1
d145 1
a145 1
  case pktWillStartPTM:
d150 1
a150 1
    }
@


1.3
log
@Distiller and proxy communication layers are working.
PTM can auto-spawn distillers
Glurun and load balancing not yet implemented
@
text
@d23 1
a23 2
  CacheManager::getInstance()->ClosePTMConnection();
  BoolErrorReturn(success);
d77 1
a77 1

d80 2
a81 1
  stream >> Delimit('|') >> rid >> Skip;
d135 1
a135 1
Listener::EvPacketReceived(EventSystem */*evs*/, Packet *packet)
d143 8
@


1.2
log
@Distiller front end working
Cache manager broken
PTM network stuff not completely done
@
text
@a18 29
/*Bool
PTMConnection::EvSelect(EventSystem *evs)
{
  Packet packet;
  if (packet.ReceiveAndHandle(evs, (PacketHandler*)
			      PTM::getInstance()->getPacketHandler(), 
			      this) == FALSE) {
    packet.HandleIgnorableErrors(Log);

    switch(GlobalErrorCode) {
    case success:
      BoolErrorReturn(success);
      
    case errSocketReadEOF:
      SetGlobalError(success);
      LOG ("PTM connection lost; trying to listen for new PTM address\n");
      Distiller::getInstance()->ClosePTMConnection();
      BoolErrorReturn(success);
      
    default:
      return FALSE;
    }
  }
  else {
    BoolErrorReturn(success);
  }
}*/


d28 11
a38 2
/*Bool
Listener::EvSelect(EventSystem *evs)
d40 6
a45 5
  Packet packet;
  if (packet.ReceiveAndHandle(evs, (PacketHandler*)
			      PTM::getInstance()->getPacketHandler(), 
			      this) == FALSE) {
    packet.HandleIgnorableErrors(Log);
d47 8
a54 8
    switch(GlobalErrorCode) {
    case success:
      BoolErrorReturn(success);
      
    case errSocketReadEOF:
    // couldn't happen; fall thru to the default case
      
    default:
d57 2
d60 3
a62 4
  else {
    BoolErrorReturn(success);
  }
}*/
d65 4
d71 2
a72 3
/* 
 * Packet format:
 *   "PTM-IP-Address|PTM-Port-No|No-of-distillers|Distiller-info|....\0"
d74 21
a94 1
class PTMBeaconHandler {
d96 1
a96 1
  Bool Handle(Packet *packet, CommunicationObject *object);
d101 1
a101 1
PTMBeaconHandler::Handle(Packet *packet, CommunicationObject *object)
d103 1
a103 3
  RemoteID rid;
  LinkedList<CachedDistiller> list;

d106 1
a106 2
  stream.Delimit('|').SetW(MAXIP) >> rid.ipAddress;
  if (stream.IsGood()==FALSE) return FALSE;
d108 5
a112 2
  stream.Delimit('|') >> rid.port;
  if (stream.IsGood()==FALSE || rid.port==0) return FALSE;
d114 4
a117 2
  stream.Delimit('|') >> numberOfDistillers;
  if (stream.IsGood()==FALSE) return FALSE;
d119 12
a130 4
  if (CacheManager::getInstance()->PTMLocationReceived(rid)==FALSE) 
    return FALSE;
  
  BoolErrorReturn(success);
a133 1

d135 1
a135 1
PTMConnection::EvPacketReceived(EventSystem *evs, Packet *packet)
d141 1
a141 1
      return handler.Handle(packet, this);
d150 1
a150 1
Listener::EvPacketReceived(EventSystem *evs, Packet *packet)
d152 56
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
#include "distiller.h"
d8 2
a9 2
static void
Log(char *string)
d11 5
a15 1
  LOG(string);
d19 2
a20 2
Bool
Listener::EvSelect(EventSystem *evs)
d24 2
a25 2
			      CacheManager::cm->getPacketHandler(), 
			      this)==FALSE){
d27 14
a40 2
    
    if (GlobalErrorCode!=success) return FALSE;
d42 4
a45 3
  
  BoolErrorReturn(success);
}
d48 2
a49 20

class Stream {

public:
  Stream(char *d, uint32 l);
  char *SkipBeyond(char ch);
  char *Skip(int howMany);

  Bool IsDone() 
  { return (current!=NULL && data!=NULL && uint32(current-data) < length)
      ? FALSE : TRUE;};
protected:
  char   *data;
  uint32 length;
  char   *current;
};


Stream::Stream(char *d, uint32 l) 
  : data(d), length(l), current(NULL)
d51 3
a53 1
  if (data!=NULL && length>0) current = data;
d57 2
a58 2
char *
Stream::SkipBeyond(char ch)
d60 5
a64 1
  char *original = current;
d66 15
a80 18
  while (IsDone()==FALSE && *current!=ch) current++;
  if (IsDone()==TRUE) { current = original; return NULL; }

  current++;
  return original;
}


char *
Stream::Skip(int howMany)
{
  char *original = current;
  if (IsDone()==TRUE) return NULL;

  if (  int(length - (current-data)) < howMany  ) return NULL;
  current += howMany;
  return original;
}
d85 4
d98 2
a99 1
  char *ipAddress, *portPtr;
d101 1
a101 4
  if (object!=(CommunicationObject*)CacheManager::cm->getListener()) {
    // can receive beaconing packets only on the listener
    BoolErrorReturn(errOutOfContextPacket);
  }
d103 2
a104 1
  Stream stream(packet->getData(), packet->getLength());
d106 2
a107 4
  if ((ipAddress = stream.SkipBeyond('/'))==NULL) 
    BoolErrorReturn(errInvalidPacketFormat);
  if ((portPtr = stream.SkipBeyond('\0'))==NULL)
    BoolErrorReturn(errInvalidPacketFormat);
d109 2
a110 3
  *(portPtr-1) = '\0';		// replace the '/' with a '\0'
  
  RemoteID rid(ipAddress, Port(atol(portPtr)));
d112 2
a113 1
  if (CacheManager::cm->PTMLocationReceived(rid)==FALSE) return FALSE;
d121 1
a121 3
CMPacketHandler::EvPacketReceived(EventSystem */*evs*/, 
				  Packet *packet,
				  CommunicationObject *object)
d124 1
a124 1
  case pktPTMBeacon:
d127 1
a127 1
      return handler.Handle(packet, object);
a128 1

d131 1
a131 1
  }
d135 4
@


1.1.1.1
log
@
@
text
@@
