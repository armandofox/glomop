head	1.46;
access;
symbols
	Yatin-final:1.45.2.3
	Yatin:1.45.0.2
	pre-yatin-merge:1.45
	transend-beta2:1.40
	fox-dev:1.40
	ptm-ng:1.35
	transend-beta-latest:1.35
	Aggregators:1.35
	NoAggregators:1.35
	iang:1.30.0.2
	transend-beta:1.27.0.2
	SOSP:1.24
	stable_ptm:1.18
	merged_preintegrate:1.7
	heisenbug:1.6
	PRE_INTEGRATION:1.6;
locks; strict;
comment	@// @;


1.46
date	98.01.16.22.16.24;	author yatin;	state Exp;
branches;
next	1.45;

1.45
date	97.10.26.00.31.00;	author fox;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	97.09.24.00.30.49;	author yatin;	state Exp;
branches;
next	1.43;

1.43
date	97.09.18.22.45.24;	author yatin;	state Exp;
branches;
next	1.42;

1.42
date	97.09.15.03.09.39;	author yatin;	state Exp;
branches;
next	1.41;

1.41
date	97.09.10.23.26.46;	author yatin;	state Exp;
branches;
next	1.40;

1.40
date	97.07.23.23.54.44;	author yatin;	state Exp;
branches;
next	1.39;

1.39
date	97.07.15.18.38.31;	author yatin;	state Exp;
branches;
next	1.38;

1.38
date	97.07.03.17.56.31;	author fox;	state Exp;
branches;
next	1.37;

1.37
date	97.06.14.05.05.49;	author yatin;	state Exp;
branches;
next	1.36;

1.36
date	97.06.06.01.09.10;	author gribble;	state Exp;
branches;
next	1.35;

1.35
date	97.05.11.10.24.35;	author fox;	state Exp;
branches;
next	1.34;

1.34
date	97.05.07.06.41.24;	author gribble;	state Exp;
branches;
next	1.33;

1.33
date	97.05.07.03.53.06;	author gribble;	state Exp;
branches;
next	1.32;

1.32
date	97.05.01.03.01.44;	author gribble;	state Exp;
branches;
next	1.31;

1.31
date	97.05.01.02.38.54;	author gribble;	state Exp;
branches;
next	1.30;

1.30
date	97.04.30.09.04.22;	author gribble;	state Exp;
branches;
next	1.29;

1.29
date	97.04.30.07.55.30;	author fox;	state Exp;
branches;
next	1.28;

1.28
date	97.04.28.18.46.43;	author yatin;	state Exp;
branches;
next	1.27;

1.27
date	97.04.17.21.45.20;	author aspolito;	state Exp;
branches;
next	1.26;

1.26
date	97.04.15.22.36.46;	author yatin;	state Exp;
branches;
next	1.25;

1.25
date	97.04.07.00.26.30;	author yatin;	state Exp;
branches;
next	1.24;

1.24
date	97.03.09.05.51.06;	author yatin;	state Exp;
branches;
next	1.23;

1.23
date	97.03.07.20.36.53;	author yatin;	state Exp;
branches;
next	1.22;

1.22
date	97.03.06.06.57.24;	author yatin;	state Exp;
branches;
next	1.21;

1.21
date	97.03.06.02.49.20;	author yatin;	state Exp;
branches;
next	1.20;

1.20
date	97.02.26.04.15.06;	author yatin;	state Exp;
branches;
next	1.19;

1.19
date	97.02.17.03.01.22;	author yatin;	state Exp;
branches;
next	1.18;

1.18
date	97.02.12.20.02.56;	author yatin;	state Exp;
branches;
next	1.17;

1.17
date	97.02.08.02.14.03;	author yatin;	state Exp;
branches;
next	1.16;

1.16
date	97.02.07.21.54.54;	author yatin;	state Exp;
branches;
next	1.15;

1.15
date	97.02.05.20.20.55;	author yatin;	state Exp;
branches;
next	1.14;

1.14
date	97.01.29.23.26.14;	author yatin;	state Exp;
branches;
next	1.13;

1.13
date	97.01.29.22.15.09;	author yatin;	state Exp;
branches;
next	1.12;

1.12
date	97.01.29.06.07.57;	author yatin;	state Exp;
branches;
next	1.11;

1.11
date	97.01.29.06.00.55;	author yatin;	state Exp;
branches;
next	1.10;

1.10
date	97.01.29.04.13.31;	author fox;	state Exp;
branches;
next	1.9;

1.9
date	97.01.08.03.39.23;	author fox;	state Exp;
branches;
next	1.8;

1.8
date	97.01.04.09.55.45;	author yatin;	state Exp;
branches;
next	1.7;

1.7
date	96.12.15.13.46.39;	author yatin;	state Exp;
branches;
next	1.6;

1.6
date	96.12.05.01.40.22;	author yatin;	state Exp;
branches;
next	1.5;

1.5
date	96.12.05.01.27.24;	author yatin;	state Exp;
branches;
next	1.4;

1.4
date	96.11.24.08.12.24;	author yatin;	state Exp;
branches;
next	1.3;

1.3
date	96.11.22.08.21.40;	author yatin;	state Exp;
branches;
next	1.2;

1.2
date	96.11.08.21.27.57;	author yatin;	state Exp;
branches;
next	1.1;

1.1
date	96.11.06.23.42.55;	author yatin;	state Exp;
branches;
next	;

1.45.2.1
date	97.11.17.22.07.06;	author yatin;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	97.11.18.20.10.26;	author yatin;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	97.11.25.01.25.12;	author yatin;	state Exp;
branches;
next	;


desc
@@


1.46
log
@- new wingman frontend
- new wingman aggregators mechanism
- DistillAsync

(merged from branch Yatin-final)
@
text
@#include "defines.h"
#include "log.h"
#include "distiller.h"
#include "distinterface.h"
#include "packet.h"
#include "options.h"
#include "utils.h"
extern "C" {
#  include "libmon.h"
#  include "clib.h"
}
#include "../../../frontend/include/ARGS.h"
#include <signal.h>
#include <errno.h>
#include <string.h>



#define Opt_NotificationTimeout_ms    "private.notification_timeout"
#define Opt_DistillerMainTimeout_ms   "private.distiller_main_timeout"
#define Opt_NoLoadTimeout_sec         "private.no_load_timeout"
//#define Opt_PTMUnicast_IP             "private.ptm_unicast.ip"
//#define Opt_PTMUnicast_port           "private.ptm_unicast.port"
#define Opt_DistillerType             "private.distiller_type"
#define Opt_SleepOnStartup            "private.sleep_on_startup"
#define Opt_RestartOnDeath            "private.restart_on_death"
#define Opt_RequestID                 "private.request_id"

extern "C" {
pthread_key_t index_key;
}


static char end_string_[256]="";


class DistillerMainTimer : public gm_Timer {
public:
  DistillerMainTimer(MyDistiller *dist)
    : gm_Timer(dist->getEventSystem(), 
	       SECONDS (dist->getOptions()->
			FindUINT32(Opt_DistillerMainTimeout_ms)), 
	       USECONDS(dist->getOptions()->
			FindUINT32(Opt_DistillerMainTimeout_ms)), gm_False) {}

private:
  virtual gm_Bool EvTimer(EventSystem */*evs*/) {
    MyDistiller::Abort("Distiller seems stuck in DistillerMain()");
    return gm_True;
  }
};



void LogArgs(OptionDatabase *options, int argc, const char*const*argv)
{
  gm_Log("Distiller type: " << options->Find(Opt_DistillerType) << "\n");
  gm_Log("PTM Unicast Address: " << options->Find(Opt_PTMUnicast_IP) << "/"
	 << options->Find(Opt_PTMUnicast_port) << "\n");
  gm_Log("Notification timeout: " 
	 << options->Find(Opt_NotificationTimeout_ms) << " ms\n");
  gm_Log("DistillerMain timeout: "
	 << options->Find(Opt_DistillerMainTimeout_ms) << " ms\n");
  gm_Log("Sleep on startup: " << options->Find(Opt_SleepOnStartup) << "\n");
  gm_Log("Restart on death: " << options->Find(Opt_RestartOnDeath) << "\n");
  char buf[2048];
  buf[0] = '\0';
  for(int i=0; i<argc; i++) {
    sprintf(buf, "%s %s", buf, argv[i]);
  }
  gm_Log(argc << " additional arguments: " << buf << "\n");
}


Monitor gMon;

Work::~Work()
{
  if (args!=NULL) delete [] args;
  /*if (input.data!=NULL) delete [] ((char*)input.data);
  if (freeOutputBuffer==gm_True) DistillerFree(output.data);*/

  // the input and output data structures ought to free themselves!
  replyObject->RemoveReference();
}


#ifdef _REPORT_STATS
Statistics::Statistics(EventSystem *evs)
 : /*currentQLengthWindow(0),*/ totalRequests(0), doneRequests(0), 
   badRequests(0), timer(NULL), mutex("*-stats")
{
  timer = new StatsTimer(evs);
  if (timer==NULL) VoidReturn(errOutOfMemory);
}


/*void
Statistics::AdjustAvgQLength(UINT32 length)
{
  mutex.Lock();
  windows[currentQLengthWindow].AdjustAvgQLength(length);
  if (windows[currentQLengthWindow].totalTime > Size_Of_QLengthWindow_usec) {
    currentQLengthWindow = (currentQLengthWindow+1) % No_Of_QLengthWindows;
    windows[currentQLengthWindow].Reset();
  }

  mutex.Unlock();
}


void
Statistics::QLengthWindow::AdjustAvgQLength(UINT32 length)
{
  timeval now, diff;
  UINT32  uintDiff;

  // compute the time diff between now and the last time the avgQLength was
  // updated
  gettimeofday(&now, NULL);
  diff.tv_sec  = now.tv_sec  - lastUpdate.tv_sec;
  diff.tv_usec = now.tv_usec - lastUpdate.tv_usec;

  if (diff.tv_usec < 0) {
    diff.tv_usec += 1000000;
    diff.tv_sec--;
  }

  if (diff.tv_sec < 0) {
    diff.tv_sec = diff.tv_usec = 0;
  }
  
  uintDiff  = diff.tv_sec*1000000 + diff.tv_usec;
  totalTime+= uintDiff;
  lengthTimeProduct += length * uintDiff;

  lastUpdate = now;
}


double
Statistics::getAvgQLength()
{
  double avg;
  UINT32 totalTime=0, lengthTimeProduct=0;
  int i;
  mutex.Lock();
  
  for (i=0; i< No_Of_QLengthWindows; i++) {
    totalTime         += windows[i].totalTime;
    lengthTimeProduct += windows[i].lengthTimeProduct;
  }

  if (totalTime==0) avg = 0.0;
  else avg = double(lengthTimeProduct)/double(totalTime);
  mutex.Unlock();
  return avg;
}*/


void
Statistics::Report()
{
  //double avg = getAvgQLength();
  mutex.Lock();
  MonitorClient *monitorClient = 
    MyDistiller::getInstance()->getMonitorClient();
  if (monitorClient!=NULL) {
    char buffer[100];
    sprintf(buffer, "%lu", totalRequests);
    monitorClient->Send("Total requests", buffer, "");
    sprintf(buffer, "%lu", doneRequests);
    monitorClient->Send("Completed requests", buffer, "");
    sprintf(buffer, "%lu", badRequests);
    monitorClient->Send("Bad requests", buffer, "");
    /*sprintf(buffer, "%0.3f", (float) avg);
    monitorClient->Send("Avg queue length", buffer, "");*/
  }
  mutex.Unlock();
}


gm_Bool
Statistics::StatsTimer::EvTimer(EventSystem */*evs*/)
{
  MyDistiller::getInstance()->ReportStats();
  return gm_True;
}


void
MyDistiller::ReportStats()
{
  //getStats()->AdjustAvgQLength(workQueue->getSize());
  char buffer[100];
  sprintf(buffer, "%lu", reporter->getAvgLatency());
  if (monitorClient!=NULL) monitorClient->Send("Avg queue length", buffer, "");
  getStats()->Report();
}

#endif


#ifndef __INSTRUMENT__
LoadReporter::LoadReporter(EventSystem *evs)
#else
LoadReporter::LoadReporter(EventSystem *evs, DistillerType *type)
#endif
  : instTotalLatency_ms(0), area(0),
    noLoadTimer(NULL)
#ifdef __INSTRUMENT__
  , instFile(NULL)
#endif
{
  gettimeofday(&lastUpdate, NULL);
  start = lastUpdate;
  
  long noLoadTimeout_sec = MyDistiller::getInstance()->getOptions()->
	  FindUINT32(Opt_NoLoadTimeout_sec);
  if (noLoadTimeout_sec!=0) {
	  // create timer object only if the timeout value is non-zero
	  NEW(noLoadTimer, NoLoadTimer(evs, noLoadTimeout_sec));
  }
  
#ifdef __INSTRUMENT__
  char filename[256], hostname[256], distType[256], *ptr;
  CommunicationObject::GetHostName(hostname);
  ptr = strchr(hostname, '.');
  if (ptr!=NULL) *ptr = '\0';
  strcpy(distType, (char*)(*type));
  ptr = distType;
  while (*ptr) {
    if (*ptr=='/') *ptr = '.';
    ptr++;
  }
  sprintf(filename, "ptm/%s.%s.%ld", distType, hostname, getpid());
  gm_Log("Trying to open inst file: " << filename << "\n");
  instFile = fopen(filename, "w");
#endif
}


void
LoadReporter::AdjustAvgLatency()
{
  timeval now, diff;
  UINT32 diff_ms;
  gettimeofday(&now, NULL);
  diff    = tv_timesub(now, lastUpdate);
  diff_ms = timeval_to_ms(diff);
  area += instTotalLatency_ms * diff_ms;
  lastUpdate = now;
}


UINT32
LoadReporter::getAvgLatency()
{
  timeval now, diff;
  UINT32 diff_ms;
  AdjustAvgLatency();
  gettimeofday(&now, NULL);
  diff    = tv_timesub(now, start);
  diff_ms = timeval_to_ms(diff);
  return ((diff_ms==0) ? instTotalLatency_ms : ( (area + diff_ms/2)/diff_ms));
}


void
LoadReporter::NewWork(Work *work)
{
  AdjustAvgLatency();
  instTotalLatency_ms += work->cost.estimatedTime_ms;
  if (noLoadTimer!=NULL) noLoadTimer->workReceived = gm_True;
#ifdef __INSTRUMENT__
  if (instFile!=NULL) {
    timeval now, diff;
    UINT32 diff_ms, avg;
    gettimeofday(&now, NULL);
    diff    = tv_timesub(now, start);
    diff_ms = timeval_to_ms(diff);
    avg = ((diff_ms==0) ? instTotalLatency_ms : ( (area + diff_ms/2)/diff_ms));
    fprintf(instFile, "%ld.%06ld\t%lu\t%lu\n", now.tv_sec, now.tv_usec, 
	    instTotalLatency_ms, avg);
  }
#endif
}


void
LoadReporter::WorkDone(Work *work)
{
  AdjustAvgLatency();
  instTotalLatency_ms -= work->cost.estimatedTime_ms;
#ifdef __INSTRUMENT__
  if (instFile!=NULL) {
    timeval now, diff;
    UINT32 diff_ms, avg;
    gettimeofday(&now, NULL);
    diff    = tv_timesub(now, start);
    diff_ms = timeval_to_ms(diff);
    avg = ((diff_ms==0) ? instTotalLatency_ms : ( (area + diff_ms/2)/diff_ms));
    fprintf(instFile, "%ld.%06ld\t%lu\t%lu\t%lu\t%lu\t%ld.%06ld\n", now.tv_sec,
	    now.tv_usec, instTotalLatency_ms, avg, work->input.data.length, 
	    work->output.data.length, work->distillTime.tv_sec, 
	    work->distillTime.tv_usec);
  }
#endif
}


void
LoadReporter::Report(Load *load)
{
  load->totalLatency_ms = getAvgLatency();
  // reset the area and start of time-interval
  area = 0;
  start = lastUpdate;
}


gm_Bool
LoadReporter::NoLoadTimer::EvTimer(EventSystem */*evs*/)
{
  if (workReceived==gm_False) {
    // no work has been received for a long time! I should kill myself
    MyDistiller::getInstance()->Die("Distiller has been idle");
  }
  else workReceived = gm_False;
  return gm_True;
}



MyDistiller* MyDistiller::instance=NULL;



MyDistiller::MyDistiller(OptionDatabase *options_, 
		     int argc, const char *const *argv)
  : reporter(NULL), consumer(NULL), 
    ptmUnicast(options_->Find(Opt_PTMUnicast_IP), 
	       options_->FindUINT32(Opt_PTMUnicast_port)), 
    ptmMulticast(options_->Find(Opt_PTMMulticast_IP), 
		 options_->FindUINT32(Opt_PTMMulticast_port)), 
    evs(NULL), server(NULL), ptmConnection(NULL), listener(NULL), 
    monitorClient(NULL), loadNotificationTimer(NULL),
    sleepStatus(distWakeUp), options(options_)
#ifdef _REPORT_STATS
    , stats(NULL)
#endif
{
  DistillerType distillerType(options_->Find(Opt_DistillerType));
  instance = this;

//  NEW(workQueue, ProducerConsumerQueue);
  NEW(workQueue, LotteryQueue);
  NEW(evs, EventSystem);
#ifdef __INSTRUMENT__
  NEW(reporter, LoadReporter(evs, &distillerType));
#else
  NEW(reporter, LoadReporter(evs));
#endif
  NEW(loadNotificationTimer, 
      LoadNotificationTimer(evs,
			    options->FindUINT32(Opt_NotificationTimeout_ms)));
  NEW(server, ProxyServer);
  if (evs->AddCommunicationObject(server)==gm_False) return;

#ifdef _REPORT_STATS
  NEW(stats, Statistics(evs));
#endif

  RemoteID monitorMulticast;
  int monitorTTL;
  strcpy(monitorMulticast.ipAddress, options->Find(Opt_MonitorMulticast_IP));
  monitorMulticast.port = options->FindUINT32(Opt_MonitorMulticast_port);
  monitorTTL = options->FindUINT32(Opt_MonitorMulticast_TTL);

  if (strcmp(monitorMulticast.ipAddress, "")!=0) {
    char unitID[80];
    RemoteID myAddress;
    if (CommunicationObject::GetHostIPAddress(myAddress.ipAddress)==gm_False)
      return;
    if ((myAddress.port = server->getLocalPort())==0) return;

    sprintf(unitID, "%s @@ %d", (char*)distillerType, 
	    myAddress.port);
    monitorClient = new MonitorClient(unitID, monitorMulticast.ipAddress,
				      monitorMulticast.port, monitorTTL);
    if (monitorClient==NULL) VoidReturn(errOutOfMemory);
    if (Error::getStatus()!=success) return;

    monitorClient->GaspOnStdSignals();
    SetRemoteLogging(monitorClient);
  }
  else {
    //SetFileLogging("/tmp/log.distiller");
    SetStderrLogging("Dist: ");
  }

  gm_Log("Starting up distiller on port " << server->getLocalPort() << "\n");
  LogArgs(options_, argc, argv);


  pthread_key_create(&index_key, NULL);
  pthread_setspecific(index_key, (void*)0);


  if (DistillerInit(distillerType.c_struct, argc, argv)!=distOk) {
    VoidReturn(errGenericError);
  }

  clib_response result;
  if ((result = Clib_Initialize((Options)options, NULL)) == CLIB_OK) {
      gm_Log("Cache client library initialized\n");
  } else {
    gm_Log("Cache client library wasn't initialized: error "
	   << (int)result << "\n");
  }

  // make sure the timers are disabled if we are sleeping
  DistillerSleepStatus sleepStatus_ =((options->FindUINT32(Opt_SleepOnStartup))
				      ? distSleep : distWakeUp);
  if (sleepStatus_==distSleep) Sleep_WakeUp(sleepStatus_);
  sleepStatus = sleepStatus_;

  if (IsPTMFound()==gm_True) {
    if (ConnectToPTM()==gm_True) {
      if (Register(options->FindUINT32(Opt_RequestID))==gm_True) return;
    }
  }

  Error::SetStatus(success);
  NoPTM();
  gm_Log("Could not register with the PTM; "
	 "trying to listen for new PTM address\n");
  ListenOnSharedBus();
}


MyDistiller::~MyDistiller()
{
  if (server!=NULL) {
    evs->RemoveCommunicationObject(server);
    delete server;
    server = NULL;
  }

  if (ptmConnection!=NULL) {
    evs->RemoveCommunicationObject(ptmConnection);
    delete ptmConnection;
    ptmConnection = NULL;
  }

  if (listener!=NULL) {
    evs->RemoveCommunicationObject(listener);
    delete listener;
    listener = NULL;
  }

  DELETE(loadNotificationTimer);
  DELETE(evs);
  DELETE(monitorClient);
  DELETE(workQueue);
}


gm_Bool
MyDistiller::Sleep_WakeUp(DistillerSleepStatus status)
{
  switch (status) {
  case distSleep:
  case distKill:
    if (sleepStatus==distSleep || sleepStatus==distKill) return gm_True;

    if (status==distSleep) {
      gm_Log("Distiller is going to sleep\n");
    }
    else {
      gm_Log("Distiller is trying to die. It'll exit after all current "
	     "requests have been satisfied\n");
    }
    DELETE(loadNotificationTimer);
#ifdef _REPORT_STATS
    DELETE(stats); // stats has an internal timer; must destroy it as well!
#endif
    sleepStatus = status;

    if (sleepStatus==distKill && reporter->IsThereWork()==gm_False) {
      // we are done; we can exit!
      Die("PTM is killing me");
    }

    return gm_True;

  case distWakeUp:
    if (sleepStatus==distWakeUp) return gm_True;

    gm_Log("Distiller is waking up\n");
    if (loadNotificationTimer==NULL) {
      loadNotificationTimer = new 
	LoadNotificationTimer(evs, 
			      options->FindUINT32(Opt_NotificationTimeout_ms));
      if (loadNotificationTimer==NULL) Return(gm_False, errOutOfMemory);
    }
#ifdef _REPORT_STATS
    if (stats==NULL) {
      stats = new Statistics(evs);
      if (stats==NULL) Return(gm_False, errOutOfMemory);
    }
#endif
    
    sleepStatus = status;
    return gm_True;
  }

  // this path should never get taken!
  Return(gm_False, errGenericError);
}


gm_Bool
MyDistiller::ConnectToPTM()
{
  ptmConnection = new PTMConnection;
  if (ptmConnection==NULL) Return(gm_False, errOutOfMemory);
  if (ptmConnection->Connect(ptmUnicast.ipAddress, ptmUnicast.port)==gm_False){
    delete ptmConnection;
    ptmConnection = NULL;
    return gm_False;
  }

  if (evs->AddCommunicationObject(ptmConnection)==gm_False) {
    delete ptmConnection;
    ptmConnection = NULL;
    return gm_False;
  }

  // we were able to set up a PTM connection - no need to listen on the shared
  // bus any more

  if (listener!=NULL) {
    evs->RemoveCommunicationObject(listener);
    delete listener;
    listener = NULL;
  }

  return gm_True;
}


gm_Bool
MyDistiller::ListenOnSharedBus()
{
  if (listener!=NULL) return gm_True;

  listener = new Listener(ptmMulticast.ipAddress, ptmMulticast.port);
  if (listener==NULL) Return(gm_False, errOutOfMemory);
  if (Error::getStatus()!=success) return gm_False;

  if (evs->AddCommunicationObject(listener)==gm_False) return gm_False;
  return gm_True;
}


void
MyDistiller::ClosePTMConnection()
{
  if (ptmConnection!=NULL) {
    evs->RemoveCommunicationObject(ptmConnection);
    delete ptmConnection;
    ptmConnection = NULL;
    NoPTM();
  }
}


gm_Bool
MyDistiller::PTMLocationReceived(RemoteID &newPtmAddress)
{
  if (ptmConnection!=NULL) return gm_True;

  gm_Log("Found PTM at " << newPtmAddress.ipAddress << '/' 
	 << newPtmAddress.port << '\n');
  strcpy(ptmUnicast.ipAddress, newPtmAddress.ipAddress);
  ptmUnicast.port = newPtmAddress.port;

  if (ConnectToPTM()==gm_False) {
    // only errOutOfMemory is a real error
    if (Error::getStatus()==errOutOfMemory) return gm_False;
    Error::SetStatus(success);
  }

  return Register(0);
}


gm_Bool
MyDistiller::Register(UINT32 requestID)
{
  RemoteID myAddress;
  OStream  ostream;

  if (ptmConnection==NULL) Return(gm_False, errGenericError);

  if (CommunicationObject::GetHostIPAddress(myAddress.ipAddress)==gm_False)
    return gm_False;
  if ((myAddress.port = server->getLocalPort())==gm_False) return gm_False;

  ostream << myAddress << '|' << options->Find(Opt_DistillerType) << '|' 
	  << (UINT32)sleepStatus << '|' 
	  << options->FindUINT32(Opt_RestartOnDeath);
  if (ostream.IsGood()==gm_False) return gm_False;

  gm_Packet packet(pktRegisterDistiller, ostream.getLength(), requestID, 
		ostream.getData());
  if (ptmConnection->Write(&packet)==gm_False) {
    // could not send to the PTM
    // probably connection just went down
    // let the event handler detect it
    // for now simply return success
  
    return gm_True;
  }

  gm_Log("Registered successfully with the PTM\n");
  return gm_True;
}


void
MyDistiller::Deregister()
{
  if (ptmConnection==NULL) return;

  gm_Packet packet(pktDeregisterDistiller, 0, 0, NULL);
  if (ptmConnection->Write(&packet)==gm_False) {
    // could not send to the PTM
    // probably connection just went down
    // let the event handler detect it
    // for now simply return success
  
    return;
  }

  gm_Log("Deregistered successfully from the PTM\n");
}


gm_Bool
MyDistiller::Reregister(DistillerType *type)
{
  options->Remove(Opt_DistillerType);
  if (options->Add(Opt_DistillerType, (char*)(*type))==gm_False) 
    return gm_False;

  gm_Log("Reregistering a new type: " << (*type) << "\n");
  if (ptmConnection==NULL) return gm_True;

  // we are connected to the PTM; send a reregister message

  OStream  ostream;

  ostream << (*type);
  if (ostream.IsGood()==gm_False) return gm_False;

  gm_Packet packet(pktReregisterDistiller, ostream.getLength(), 0, 
		   ostream.getData());
  if (ptmConnection->Write(&packet)==gm_False) {
    // could not send to the PTM
    // probably connection just went down

    return ptmConnection->EvConnectionBroken(evs);
  }

  return gm_True;
}


gm_Bool
MyDistiller::WorkReceived(Work *work)
{
  DistillerStatus status;
  gm_Bool         res;
  Statistics     *stats;
  unsigned long   i;
  unsigned long   ip = 0;

  status = DefaultDistillationCost(&work->cost);
  /*status = ComputeDistillationCost(work->args, work->numberOfArgs,
				   &work->input, &work->cost);*/
  if (status!=distOk) {
    work->status = status;
    return evs->PostEvent(evDistillerReply, this, work);
  }

  reporter->NewWork(work);

  /* Let's pull out the client IP address out of the Work prefs structure.
     If it's not in there, leave it as 0.0.0.0 */
  for (i=0; i<work->numberOfArgs; i++) {
    if (ARG_ID(work->args[i]) == FRONT_CLIENT_IP) {
      ip = (unsigned long) ARG_INT(work->args[i]);
//      fprintf(stderr, "Got ip %lu\n", ntohl(ip));
      break;
    }
  }
  res = workQueue->Add((void *) work, ip);
#ifdef _REPORT_STATS
  stats = MyDistiller::getInstance()->getStats();
  if (stats != NULL) stats->IncrementTotalRequests();
  //MyDistiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
#endif
  return res;
}


gm_Bool
MyDistiller::SendLoadInformation()
{
  Load load;
  reporter->Report(&load);
  if (ptmConnection==NULL || IsPTMFound()==gm_False) return gm_True;
  OStream stream;
  stream << load;
  if (stream.IsGood()==gm_False) return gm_False;
  gm_Packet packet(pktDistillerLoad, stream.getLength(), stream.getData());
  if (ptmConnection->Write(&packet)==gm_False) {
    // ignore network errors
    Error::SetStatus(success);
    return gm_True;
  }
  return gm_True;
}


gm_Bool
LoadNotificationTimer::EvTimer(EventSystem */*evs*/)
{
  return MyDistiller::getInstance()->SendLoadInformation();
}


gm_Bool
MyDistiller::HandleEvent(EventSystem */*evs*/, EventType evType, void *args)
{
  switch (evType) {
  case evDistillerReply:
    {
      Work *work = (Work*)args;
      if (work==NULL) Return(gm_False, errGenericError);
      reporter->WorkDone(work);
      if (work->replyObject->IsDeleted()==gm_False) {
	// only if the connection is still alive, should we try to send
	// stuff on it
	work->replyObject->SendReply(work->status, &work->output, 
				     work->replyID);
      }
      delete work;
      if (sleepStatus==distKill && reporter->IsThereWork()==gm_False) {
	// we are done; we can exit!
	Die("PTM is killing me");
      }
      return gm_True;
    }

  case evDistillerReregister:
    {
      DistillerType *type = (DistillerType*) args;
      gm_Bool retval = Reregister(type);
      delete type;
      return retval;
    }

  default:
    Return(gm_False, errEvSysInvalidEvent);
  }
}


gm_Bool
MyDistiller::Run()
{
  consumer = new Thread;
  if (consumer==NULL) Return(gm_False, errOutOfMemory);
  if (consumer->Fork(ForkHelper, (void*)this)==gm_False) return gm_False;

  return evs->Run();
}


void*
MyDistiller::ForkHelper(void *args)
{
  ((MyDistiller*)args)->ConsumerMain();
  return 0;
}


void
MyDistiller::ConsumerMain()
{
  Work *work;

  while (gm_True) {
    work = (Work *) workQueue->Remove();

#ifdef _REPORT_STATS
  //MyDistiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
#endif

    if (work==NULL) {
      // there is no more work! so finish this thread
      return;
    }

    if (work->replyObject->IsDeleted()==gm_True) {
      // the reply connection is gone; no point in distilling this stuff
      delete work;
      continue;
    }

    strcpy(work->output.mimeType, work->input.mimeType);
#ifdef __INSTRUMENT__
    timeval start, end;
    gettimeofday(&start, NULL);
#endif
    DistillerMainTimer *timer = NULL;
    timer = new DistillerMainTimer(this);
    work->status = DistillerMain(work->args,   work->numberOfArgs,
				 &work->input, &work->output);
    if (timer!=NULL) delete timer;
#ifdef __INSTRUMENT__
    gettimeofday(&end, NULL);
    work->distillTime = tv_timesub(end, start);
#endif
    evs->PostEvent(evDistillerReply, this, work);
#ifdef _REPORT_STATS
    Statistics *stats = MyDistiller::getInstance()->getStats();
    if (stats!=NULL) stats->IncrementDoneRequests();
#endif
  }
}


gm_Bool
MyDistiller::ExpandOptions(OptionDatabase *optDB)
{
  const char *value;
  char *slash1, *slash2;

  value = optDB->Find(Opt_PTMMulticast);
  if (value==NULL) {
    optDB->Add(Opt_PTMMulticast_IP,   DefaultMulticastAddress);
    optDB->Add(Opt_PTMMulticast_port, DefaultMulticastPort);
    optDB->Add(Opt_PTMMulticast_TTL,  DefaultTTL);
  }
  else {
    RemoteID multicast;
    int ttl;

    slash1 = strchr(value, '/');
    if (slash1==NULL || slash1==value) Return(gm_False, errFormattingError);

    if (slash1 >= value + MAXIP) Return(gm_False, errBufferOverflow);
    strncpy(multicast.ipAddress, value, slash1-value);
    multicast.ipAddress[slash1-value] = '\0';
    
    slash2 = strchr(slash1+1, '/');
    if (slash2==NULL) {
      multicast.port = atoi(slash1+1);
      if (multicast.port==0) Return(gm_False, errFormattingError);
      ttl = DefaultTTL;
    }
    else {
      if (sscanf(slash1+1, "%d/%d", &multicast.port, &ttl)!=2) 
	Return(gm_False, errFormattingError);
      if (multicast.port==0 || ttl==0) Return(gm_False, errFormattingError);
    }
    optDB->Add(Opt_PTMMulticast_IP,   multicast.ipAddress);
    optDB->Add(Opt_PTMMulticast_port, (UINT32) multicast.port);
    optDB->Add(Opt_PTMMulticast_TTL,  (UINT32) ttl);
  }

  value = optDB->Find(Opt_MonitorMulticast);
  if (value==NULL) {
    optDB->Add(Opt_MonitorMulticast_IP,   DefaultMonitorAddress);
    optDB->Add(Opt_MonitorMulticast_port, DefaultMonitorPort);
    optDB->Add(Opt_MonitorMulticast_TTL,  DefaultTTL);
  }
  else if (*value=='\0') {
    // we have explicitly mentioned that we don't want to use a monitor
    // All log messages will be output to stderr
    optDB->Add(Opt_MonitorMulticast_IP,   "");
    optDB->Add(Opt_MonitorMulticast_port, (UINT32)-1);
    optDB->Add(Opt_MonitorMulticast_TTL,  (UINT32)-1);
  }
  else {
    RemoteID multicast;
    int ttl;

    slash1 = strchr(value, '/');
    if (slash1==NULL || slash1==value) Return(gm_False, errFormattingError);

    if (slash1 >= value + MAXIP) Return(gm_False, errBufferOverflow);
    strncpy(multicast.ipAddress, value, slash1-value);
    multicast.ipAddress[slash1-value] = '\0';
    
    slash2 = strchr(slash1+1, '/');
    if (slash2==NULL) {
      multicast.port = atoi(slash1+1);
      if (multicast.port==0) Return(gm_False, errFormattingError);
      ttl = DefaultTTL;
    }
    else {
      if (sscanf(slash1+1, "%d/%d", &multicast.port, &ttl)!=2) 
	Return(gm_False, errFormattingError);
      if (multicast.port==0 || ttl==0) Return(gm_False, errFormattingError);
    }
    optDB->Add(Opt_MonitorMulticast_IP,   multicast.ipAddress);
    optDB->Add(Opt_MonitorMulticast_port, (UINT32) multicast.port);
    optDB->Add(Opt_MonitorMulticast_TTL,  (UINT32) ttl);
  }

  return gm_True;
}


gm_Bool
MyDistiller::CreateInstance(OptionDatabase *options,
                          int argc, const char *const *argv)
{
  /*instance = new MyDistiller(ptmAddress, multicast, monitorAddr, monitorTTL,
			   distillerType, notificationTimeout_ms, 
			   sleepOnStartup, optionsDBfile, requestID,
			   argc, argv);*/
  instance = new MyDistiller(options, argc, argv);
  if (instance==NULL) Return(gm_False, errOutOfMemory);
  if (Error::getStatus()!=success) return gm_False;

  signal(SIGINT,  SigInt);
  /*void (*handler)(int);
  handler = signal(SIGTERM, SigTerm);
  printf("Prev handler (%p) %s SIG_ERR\n", handler, 
	 (handler==SIG_ERR) ? "is" : "is not");*/
  return gm_True;
}


void
MyDistiller::SigInt(int /*sig*/)
{
  //MyDistiller::getInstance()->Die("Ctl-C pressed");
  Abort("Ctl-C pressed");
}


void
MyDistiller::SigTerm(int /*sig*/)
{
  //printf("Starting to die\n");
  MyDistiller::getInstance()->Die("Normal termination");
  //printf("Dying\n");
}


void
MyDistiller::Die(const char *message)
{
  /*Deregister();

  gm_Log("Ending the distiller: " << message << "\n");
  Error::Print();
  MonitorClient *client = getMonitorClient();
  if (client!=NULL) client->Gasp(0);*/
  
  strcpy(end_string_, message);
  evs->PostEvent(evQuit, NULL, NULL);
}


void
MyDistiller::Abort(char *string)
{
  gm_Log("Aborting program: " << string << "\n\n");
  Error::Print();
  //if (instance!=NULL) delete instance;
  MonitorClient *client = MyDistiller::getInstance()->getMonitorClient();
  if (client!=NULL) client->Gasp(0);
  exit(-1);
}


void
MyDistiller::Usage(char *programPath)
{
  char *programName;
  programName = strrchr(programPath, '/');
  programName = ((programName==NULL) ? programPath : programName+1);

  gm_Log("Usage: " << programName << " [options]\n\n"
	 <<"Options:\n"
         <<"    -o <options-file-name> /*optional*/\n"
	 <<"    -p <ptm-ip-address/port-number> /*optional*/\n"
	 <<"    -t <distiller-type> /****required****/\n"
	 <<"    -n <notification-timeout-ms> /*optional*/\n"
	 <<"    -m <DistillerMain-timeout-ms> /*optional*/\n"
	 <<"    -d <die-timer-sec> /*optional*/\n"
	 <<"    -s /* optional:indicates whether to go to sleep on startup*/\n"
	 <<"    -e /* optional:indicates to PTM whether to go to try \n"
	 <<"          restarting this distiller if it dies unnaturally*/\n"
	 <<"    -r <request-id> /*optional*/\n"
	 <<"       /*defaults to zero; used only when the PTM spawns a "
	   "distiller*/\n");
  exit(-1);
}


MonitorClientID
DistillerGetMonitorClientID()
{
  return (MonitorClientID) MyDistiller::getInstance()->getMonitorClient();
}


void
DistillerRename(C_DistillerType type_)
{
  MyDistiller *instance = MyDistiller::getInstance();
  DistillerType *type = new DistillerType(type_);
  instance->getEventSystem()->PostEvent(evDistillerReregister, instance, type);
}


extern "C" {
#include "thr_cntl.h"
}

void INST_set_thread_state(int thrindex, thread_state_t state)
{
  char msg[32], args[256];

  /*
   *  Generate thread state "deltas" vector
   */
  thrindex = 0;
  sprintf(msg,"%d=%d", thrindex, state);
  sprintf(args, "Array 1 %d", THREAD_STATE_MAX);

  MyDistiller::getInstance()->getMonitorClient()->
    Send("Relaxen und watchen das Blinkenlights", msg, args);
}



int
main(int argc, char *argv[])
{
  char     distillerType[MAXDISTILLER_TYPE_STRING]="";
  UINT32   requestID=0, notificationTimeout_ms=DefaultNotificationTimeout_ms,
    distillerMainTimeout_ms=DefaultDistillerMainTimeout_ms,
    noLoadTimeout_sec=NoLoadTimeout_sec;
  RemoteID ptmUnicast("", 0);
  char     *cmdLineOptions = "o:p:t:n:m:d:r:se";
  char     optionsDBfile[MAXPATH]="";
  int      optCh;
  gm_Bool  sleepOnStartup = gm_False, mustRestartOnDeath = gm_False;

  optind = 1;
  while ( (optCh = getopt(argc, argv, cmdLineOptions))!=-1) {
    switch (optCh) {
    case 'o':
      strcpy(optionsDBfile, optarg);
      break;
      
    case 'p':
      if (sscanf(optarg,"%[^/]/%d",ptmUnicast.ipAddress,&ptmUnicast.port)!=2)
	MyDistiller::Usage(argv[0]);
      break;

    case 't':
      strcpy(distillerType, optarg);
      break;

    case 'n':
      sscanf(optarg, "%lu", &notificationTimeout_ms);
      if (notificationTimeout_ms==0) 
	notificationTimeout_ms = DefaultNotificationTimeout_ms;
      break;

    case 'm':
      sscanf(optarg, "%lu", &distillerMainTimeout_ms);
      if (distillerMainTimeout_ms==0) 
	distillerMainTimeout_ms = DefaultDistillerMainTimeout_ms;
      break;

    case 'd':
      sscanf(optarg, "%lu", &noLoadTimeout_sec);
      break;

    case 'r':
      sscanf(optarg, "%lu", &requestID);
      break;

    case 's':
      sleepOnStartup = gm_True;
      break;

    case 'e':
      mustRestartOnDeath = gm_True;
      break;

    case ':':
    case '?':
    default:
      MyDistiller::Usage(argv[0]);
      break;
    }
  }

  if (*distillerType=='\0') MyDistiller::Usage(argv[0]);

  OptionDatabase options;
  if (*optionsDBfile!='\0') {
    if (options.Create(optionsDBfile)==gm_False)
      MyDistiller::Abort("Could not open the options file");
  }
      
  options.Add(Opt_DistillerType, distillerType);
  options.Add(Opt_PTMUnicast_IP, ptmUnicast.ipAddress);
  options.Add(Opt_PTMUnicast_port, ptmUnicast.port);
  options.Add(Opt_NotificationTimeout_ms, notificationTimeout_ms);
  options.Add(Opt_DistillerMainTimeout_ms, distillerMainTimeout_ms);
  options.Add(Opt_NoLoadTimeout_sec, noLoadTimeout_sec);
  options.Add(Opt_RequestID, requestID);
  options.Add(Opt_SleepOnStartup, sleepOnStartup);
  options.Add(Opt_RestartOnDeath, mustRestartOnDeath);
  if (MyDistiller::ExpandOptions(&options)==gm_False) {
    MyDistiller::Abort("Could not expand options database");
  }

  char debugString[256];
  sprintf(debugString, "%s: ", distillerType);
  /*char debugName[256], *slash;
  slash = strchr(distillerType, '/');
  if (slash==NULL) slash = distillerType-1;
  sprintf(debugName, "debug.%s", slash+1);
  Debug_::getInstance()->Initialize("et", debugString, debugName);*/
  Debug_::getInstance()->Initialize("et", debugString);
  if (MyDistiller::CreateInstance(&options, 
				argc - optind, argv+optind)==gm_False) {
    MyDistiller::Abort("Could not start up the distiller");
  }

  if (MyDistiller::getInstance()->Run()==gm_False)
    MyDistiller::Abort("Error occurred while running the distiller");

  //printf("Finished the Run() call\n");
  // the distiller is ending normally
  MyDistiller::getInstance()->Deregister();

  gm_Log("Ending the distiller: " << end_string_ << "\n");
  Error::Print();
  MonitorClient *client = MyDistiller::getInstance()->getMonitorClient();
  if (client!=NULL) client->Gasp(0);

  return 0;
}
@


1.45
log
@changed ptm to always alloc and fill in a null term when receiving
metadata (headers) from workers.  also added StringBuffer function for
setting a distillerbuffer to an ascii string, which implements the same
behavior (adding the null term and setting length and maxLength appropriately).
@
text
@d21 1
d26 1
d34 2
d65 1
d209 2
a210 1
  : instTotalLatency_ms(0), area(0), noLoadTimer(evs)
d217 8
a224 1

d274 1
a274 1
  noLoadTimer.workReceived = gm_True;
d327 1
a327 1
    MyDistiller::getInstance()->Die();
d492 1
a492 1
      Die();
d605 1
a605 1
  if (ptmConnection==NULL) return gm_False;
d612 2
a613 1
	  << (UINT32)sleepStatus;
d632 49
d763 1
a763 1
	Die();
d768 8
d942 5
a946 1
  signal (SIGINT, CtlCPressed);
d952 1
a952 1
MyDistiller::CtlCPressed(int /*sig*/)
d954 1
d960 24
d1009 1
d1011 2
d1027 9
d1062 2
a1063 1
    distillerMainTimeout_ms=DefaultDistillerMainTimeout_ms;
d1065 1
a1065 1
  char     *cmdLineOptions = "o:p:t:n:m:r:s";
d1068 1
a1068 1
  gm_Bool  sleepOnStartup = gm_False;
d1098 4
d1110 4
d1135 1
d1138 1
d1159 9
a1167 2
  gm_Log("Ending the distiller normally\n");
  MyDistiller::getInstance()->getMonitorClient()->Gasp(0);
@


1.45.2.1
log
@- Modularized the wingman frontend by splitting wing_go_proc into
  multiple smaller functions

- New aggregator mechanism for wingman proxies. The WingDispatch worker
  receives a request with a special content-type application/x-wingman-agg.
  The body of the request contains the full aggregator url

  The worker should return a valid HTTP response, which might be a
  pilot-ready document (i.e. an x-wingman/* document) or an HTTP
  redirect to a new URL, or whatever it chooses!)

- The WingDispatcher is now expected to weed out unintelligible content-types
  and return a content-type of x-wingman/<integer> to the frontend, where
  <integer> represents the integral content type returned to the pilot client.

- Agglist: this appears at the dispatcher as a special aggregator request
  with a url of agg://agglist/ (this URL is actually defined in the
  gm_options file, so the worker should check against the gm_options
  entry, rather than a hard-coded entry). The worker that handles this
  request *MUST* return a document with content type
  x-wingman/2 and the actual agglist as part of the data.

  For old browsers, the data part of this response is stuffed into an
  appropriate metadata field by the frontend before sending the reply to
  the client (i.e. it is backward compatible). For browsers with the new
  version number, the browser will no longer set any special flags in the
  metadata field of the client request. Instead it will explicitly request
  for the agg://agglist/ url. It'll check the ContentType field in the
  response for content type 2 to match up the correct response.

- Created a new version number for the agglist changes:
  #define CLIENT_VERSION_NEWAGG 0x01050200

- gm_options changes:
  Here are the three new gm_options entries for wingman: (the
  wingman.text.prefetch_href replaces the old prefetch.href entry)

  wingman.about_url: http://www.isaac.cs.berkeley.edu/pilot/wingman/about-
  wingman.agglist_url: agg://agglist/
  wingman.text.prefetch_href: 10

- PTM changes:
  - Background distillers work. Specify the -e flag before the -- in the
    gm_options line for the distiller. The PTM will IMMEDIATELY respawn the
    distiller if it crashes. This mechanism is still very simple and naive
  - Distillers can rename themselves: API function DistillerReregister.
@
text
@a20 1
#define Opt_NoLoadTimeout_sec         "private.no_load_timeout"
a24 1
#define Opt_RestartOnDeath            "private.restart_on_death"
a31 2
static char end_string_[256]="";

a60 1
  gm_Log("Restart on death: " << options->Find(Opt_RestartOnDeath) << "\n");
d204 1
a204 2
  : instTotalLatency_ms(0), area(0),
    noLoadTimer(NULL)
d211 1
a211 8
  
  long noLoadTimeout_sec = MyDistiller::getInstance()->getOptions()->
	  FindUINT32(Opt_NoLoadTimeout_sec);
  if (noLoadTimeout_sec!=0) {
	  // create timer object only if the timeout value is non-zero
	  NEW(noLoadTimer, NoLoadTimer(evs, noLoadTimeout_sec));
  }
  
d261 1
a261 1
  if (noLoadTimer!=NULL) noLoadTimer->workReceived = gm_True;
d314 1
a314 1
    MyDistiller::getInstance()->Die("Distiller has been idle");
d479 1
a479 1
      Die("PTM is killing me");
d592 1
a592 1
  if (ptmConnection==NULL) Return(gm_False, errGenericError);
d599 1
a599 2
	  << (UINT32)sleepStatus << '|' 
	  << options->FindUINT32(Opt_RestartOnDeath);
a617 49
void
MyDistiller::Deregister()
{
  if (ptmConnection==NULL) return;

  gm_Packet packet(pktDeregisterDistiller, 0, 0, NULL);
  if (ptmConnection->Write(&packet)==gm_False) {
    // could not send to the PTM
    // probably connection just went down
    // let the event handler detect it
    // for now simply return success
  
    return;
  }

  gm_Log("Deregistered successfully from the PTM\n");
}


gm_Bool
MyDistiller::Reregister(DistillerType *type)
{
  options->Remove(Opt_DistillerType);
  if (options->Add(Opt_DistillerType, (char*)(*type))==gm_False) 
    return gm_False;

  gm_Log("Reregistering a new type: " << (*type) << "\n");
  if (ptmConnection==NULL) return gm_True;

  // we are connected to the PTM; send a reregister message

  OStream  ostream;

  ostream << (*type);
  if (ostream.IsGood()==gm_False) return gm_False;

  gm_Packet packet(pktReregisterDistiller, ostream.getLength(), 0, 
		   ostream.getData());
  if (ptmConnection->Write(&packet)==gm_False) {
    // could not send to the PTM
    // probably connection just went down

    return ptmConnection->EvConnectionBroken(evs);
  }

  return gm_True;
}


d700 1
a700 1
	Die("PTM is killing me");
a704 8
  case evDistillerReregister:
    {
      DistillerType *type = (DistillerType*) args;
      gm_Bool retval = Reregister(type);
      delete type;
      return retval;
    }

d871 1
a871 5
  /*signal(SIGINT,  SigInt);
  void (*handler)(int);
  handler = signal(SIGTERM, SigTerm);
  printf("Prev handler (%p) %s SIG_ERR\n", handler, 
	 (handler==SIG_ERR) ? "is" : "is not");*/
d877 1
a877 1
MyDistiller::SigInt(int /*sig*/)
a878 1
  //MyDistiller::getInstance()->Die("Ctl-C pressed");
a883 24
MyDistiller::SigTerm(int /*sig*/)
{
  printf("Starting to die\n");
  MyDistiller::getInstance()->Die("Normal termination");
  printf("Dying\n");
}


void
MyDistiller::Die(const char *message)
{
  /*Deregister();

  gm_Log("Ending the distiller: " << message << "\n");
  Error::Print();
  MonitorClient *client = getMonitorClient();
  if (client!=NULL) client->Gasp(0);*/
  
  strcpy(end_string_, message);
  evs->PostEvent(evQuit, NULL, NULL);
}


void
a908 1
	 <<"    -d <die-timer-sec> /*optional*/\n"
a909 2
	 <<"    -e /* optional:indicates to PTM whether to go to try \n"
	 <<"          restarting this distiller if it dies unnaturally*/\n"
a923 9
void
DistillerReregister(C_DistillerType type_)
{
  MyDistiller *instance = MyDistiller::getInstance();
  DistillerType *type = new DistillerType(type_);
  instance->getEventSystem()->PostEvent(evDistillerReregister, instance, type);
}


d950 1
a950 2
    distillerMainTimeout_ms=DefaultDistillerMainTimeout_ms,
    noLoadTimeout_sec=NoLoadTimeout_sec;
d952 1
a952 1
  char     *cmdLineOptions = "o:p:t:n:m:d:r:se";
d955 1
a955 1
  gm_Bool  sleepOnStartup = gm_False, mustRestartOnDeath = gm_False;
a984 4
    case 'd':
      sscanf(optarg, "%lu", &noLoadTimeout_sec);
      break;

a992 4
    case 'e':
      mustRestartOnDeath = gm_True;
      break;

a1013 1
  options.Add(Opt_NoLoadTimeout_sec, noLoadTimeout_sec);
a1015 1
  options.Add(Opt_RestartOnDeath, mustRestartOnDeath);
d1036 2
a1037 9
  printf("Finished the Run() call\n");
  // the distiller is ending normally
  MyDistiller::getInstance()->Deregister();

  gm_Log("Ending the distiller: " << end_string_ << "\n");
  Error::Print();
  MonitorClient *client = MyDistiller::getInstance()->getMonitorClient();
  if (client!=NULL) client->Gasp(0);

@


1.45.2.2
log
@Changed the DistillerReregister API function to DistillerRename
Added gm_options support for wingman aggregators
@
text
@d1028 1
a1028 1
DistillerRename(C_DistillerType type_)
@


1.45.2.3
log
@- removed -ltcl check in configure.in. It was causing problems with tcl8.0 and
  wasn't being used anyway.
- frontend returns a sane error when transend/myurl/dispatch fails
- added more API functions to tcl_stub
- wingman gm_options aggregators work
- fixed bug in DistillerType::CanSatisfy
- removed debugging printf's from libdist
@
text
@d942 2
a943 2
  signal(SIGINT,  SigInt);
  /*void (*handler)(int);
d962 1
a962 1
  //printf("Starting to die\n");
d964 1
a964 1
  //printf("Dying\n");
d1159 1
a1159 1
  //printf("Finished the Run() call\n");
@


1.44
log
@the distiller InitializeDistillerCache() function call should know
about the PTM's unicast location. Fixed that
@
text
@d374 1
a374 1
    sprintf(unitID, "%s distiller (Port %d)", (char*)distillerType, 
@


1.43
log
@added mash_stub
mash_stub is compiled only if --with-mashdir flag is set
added a --enable/disable-mkdep flag to configure
configure can read default arguments from a special file .configure in
the toplevel tcsproxy directory
@
text
@d21 2
a22 2
#define Opt_PTMUnicast_IP             "private.ptm_unicast.ip"
#define Opt_PTMUnicast_port           "private.ptm_unicast.port"
@


1.42
log
@PTM Changes:

* libdist.a now includes libptmstub.a. If you wish to invoke other
distillers from a distiller, you must call InitializeDistillerCache in
your DistillerInit method.

Please note that the arguments to InitializeDistillerCache have changed
slightly. Check out ptm/src/dist/distengine.c for an example of invoking
distillers from other distillers. I have updated the frontend to
reflect the change in arguments.

* DistillerMain times out after a certain time interval. The default
timeout is 60 seconds. You can override that on a per-distiller basis
through the gm_options file (See ahead).

* The "dist.blah:" line format has changed slightly. Here's the new
format:

dist.transend/foo/bar: sbin/foobar_munger <auto-launch-limit-ms> \
			<averaging-interval-ms> <distiller args ...> \
			-- <additional args>

Currently the auto-launch-limit-ms param is the max tolerable queue
length. Set it to zero if you want to disable auto-launching.

For both <auto-launch-limit-ms> and <averaging-interval-ms>, you can
specify - or 0 to use the built-in default value.

<distiller-args> can be any of the command line arguments that the
distiller can understand. Specifically you can use the -n argument to se
the notification timeout and -m to set the DistillerMain timeout.

Please update your gm_options file to the new format. Look at
gm_options.yatin for examples.


* The PTM Makefile does dependencies correctly (finally!!!). The
dependency file has been generated currently for Linux. If you are
compiling on a Solaris box, it might complain about not finding some of
the linux .h files. Simply run "make depend" in the ptm subdirectory on
your solaris box. Hopefully it'll work. If it doesn't work, comment out
the "source Makefile.depend" line from your Makefile.
@
text
@d33 1
a33 1
class DistillerMainTimer : public Timer {
d36 5
a40 5
    : Timer(dist->getEventSystem(), 
	    SECONDS (dist->getOptions()->
		     FindUINT32(Opt_DistillerMainTimeout_ms)), 
	    USECONDS(dist->getOptions()->
		     FindUINT32(Opt_DistillerMainTimeout_ms)), gm_False) {}
d602 1
a602 1
  Packet packet(pktRegisterDistiller, ostream.getLength(), requestID, 
d665 1
a665 1
  Packet packet(pktDistillerLoad, stream.getLength(), stream.getData());
@


1.41
log
@bug fixes for the * character
@
text
@d20 1
d27 21
d49 3
a51 1
void LogArgs(int argc, const char*const*argv)
d53 8
d66 1
a66 1
  gm_Log("Got " << argc << " additional arguments: " << buf << "\n");
d161 2
a162 1
  MonitorClient *monitorClient = Distiller::getInstance()->getMonitorClient();
d181 1
a181 1
  Distiller::getInstance()->ReportStats();
d187 1
a187 1
Distiller::ReportStats()
d314 1
a314 1
    Distiller::getInstance()->Die();
d322 1
a322 1
Distiller* Distiller::instance=NULL;
d326 1
a326 1
Distiller::Distiller(OptionDatabase *options_, 
d390 6
a395 1
  LogArgs(argc, argv);
d429 1
a429 1
Distiller::~Distiller()
d457 1
a457 1
Distiller::Sleep_WakeUp(DistillerSleepStatus status)
d511 1
a511 1
Distiller::ConnectToPTM()
d541 1
a541 1
Distiller::ListenOnSharedBus()
d555 1
a555 1
Distiller::ClosePTMConnection()
d567 1
a567 1
Distiller::PTMLocationReceived(RemoteID &newPtmAddress)
d587 1
a587 1
Distiller::Register(UINT32 requestID)
d619 1
a619 1
Distiller::WorkReceived(Work *work)
d648 1
a648 1
  stats = Distiller::getInstance()->getStats();
d650 1
a650 1
  //Distiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
d657 1
a657 1
Distiller::SendLoadInformation()
d678 1
a678 1
  return Distiller::getInstance()->SendLoadInformation();
d683 1
a683 1
Distiller::HandleEvent(EventSystem */*evs*/, EventType evType, void *args)
d712 1
a712 1
Distiller::Run()
d723 1
a723 1
Distiller::ForkHelper(void *args)
d725 1
a725 1
  ((Distiller*)args)->ConsumerMain();
d731 1
a731 1
Distiller::ConsumerMain()
d739 1
a739 1
  //Distiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
d758 2
d762 1
d769 1
a769 1
    Statistics *stats = Distiller::getInstance()->getStats();
d777 1
a777 1
Distiller::ExpandOptions(OptionDatabase *optDB)
d860 1
a860 1
Distiller::CreateInstance(OptionDatabase *options,
d863 1
a863 1
  /*instance = new Distiller(ptmAddress, multicast, monitorAddr, monitorTTL,
d867 1
a867 1
  instance = new Distiller(options, argc, argv);
d877 1
a877 1
Distiller::CtlCPressed(int /*sig*/)
d884 1
a884 1
Distiller::Abort(char *string)
d889 1
a889 1
  MonitorClient *client = Distiller::getInstance()->getMonitorClient();
d896 1
a896 1
Distiller::Usage(char *programPath)
d908 1
d917 2
a918 2
Argument *
getArgumentFromId(Argument *args, int numberOfArgs, UINT32 id)
d920 1
a920 6
  Argument *ptr;
  if (args==NULL) return NULL;
  for(ptr=args; ptr < args+numberOfArgs; ptr++) {
    if (ARG_ID(*ptr)==id) return ptr;
  }
  return NULL;
d924 2
a925 4
/*void *
DistillerMalloc(size_t size)
{
  return malloc(size);
d928 1
a928 3

void *
DistillerRealloc(void *ptr, size_t size)
d930 1
a930 2
  return realloc(ptr, size);
}
d932 6
d939 2
a940 11
void 
DistillerFree(void *pointer)
{
  if (pointer!=NULL) free(pointer);
}*/


MonitorClientID
DistillerGetMonitorClientID()
{
  return (MonitorClientID) Distiller::getInstance()->getMonitorClient();
d949 2
a950 1
  UINT32   requestID=0, notificationTimeout_ms=DefaultNotificationTimeout_ms;
d952 1
a952 1
  char     *cmdLineOptions = "o:p:t:n:r:s";
d955 1
a955 1
  gm_Bool  sleepOnStartup = gm_False, done=gm_False;
d958 1
a958 1
  while ( done==gm_False && (optCh = getopt(argc, argv, cmdLineOptions))!=-1) {
d966 1
a966 1
	Distiller::Usage(argv[0]);
d979 6
d996 1
a996 1
      Distiller::Usage(argv[0]);
d1001 1
a1001 1
  if (*distillerType=='\0') Distiller::Usage(argv[0]);
d1006 1
a1006 1
      Distiller::Abort("Could not open the options file");
d1013 1
d1016 2
a1017 2
  if (Distiller::ExpandOptions(&options)==gm_False) {
    Distiller::Abort("Could not expand options database");
d1028 1
a1028 1
  if (Distiller::CreateInstance(&options, 
d1030 1
a1030 1
    Distiller::Abort("Could not start up the distiller");
d1033 2
a1034 2
  if (Distiller::getInstance()->Run()==gm_False)
    Distiller::Abort("Error occurred while running the distiller");
d1037 1
a1037 1
  Distiller::getInstance()->getMonitorClient()->Gasp(0);
@


1.40
log
@modified distiller stub and ptm to handle "--" correctly for additional
distiller arguments

modified distiller stubs to read the multicast addresses from the options
file instead of accepting them on the command line

added run targets for html, gig and jpg mungers
@
text
@d382 2
@


1.39
log
@Modified DistillerType::CanSatisfy to accept wildcards between slashes

Changed the thread-unsafe gethostbyname/getprotobyname to the corresponding
thread safe version
@
text
@d6 1
d19 8
d293 8
a300 8
Distiller::Distiller(RemoteID &ptm, RemoteID &multicast, 
		     RemoteID &monitorAddr, int monitorTTL,
		     DistillerType &type, UINT32 notificationTimeout_ms_, 
		     gm_Bool sleepOnStartup, char *optionsDBfile,
                     UINT32 requestID, int argc, const char *const *argv)
  : reporter(NULL), consumer(NULL), ptmAddress(ptm), 
    multicastAddress(multicast), distillerType(type), evs(NULL), 
    server(NULL), ptmConnection(NULL), listener(NULL), 
d302 1
a302 2
    notificationTimeout_ms(notificationTimeout_ms_),
    sleepStatus(distWakeUp)
d307 1
d314 1
a314 1
  NEW(reporter, LoadReporter(evs, &type));
d318 3
a320 2
  NEW(loadNotificationTimer, LoadNotificationTimer(evs,
						   notificationTimeout_ms));
d328 7
a334 2
  
  if (strcmp(monitorAddr.ipAddress, "")!=0) {
d341 4
a344 3
    sprintf(unitID, "%s distiller (Port %d)", (char*)type, myAddress.port);
    monitorClient = new MonitorClient(unitID, monitorAddr.ipAddress,
				      monitorAddr.port, monitorTTL);
d359 1
a359 1
  if (DistillerInit(type.c_struct, argc, argv)!=distOk) {
a362 1
  Options options;
d364 1
a364 2
  if (Options_New(&options, optionsDBfile) == 0) {
    if ((result = Clib_Initialize(options, NULL)) == CLIB_OK) {
a365 4
    } else {
      gm_Log("Cache client library wasn't initialized: error "
             << (int)result << "\n");
    }
d367 2
a368 1
    gm_Log("Couldn't open options file to initialize Clib\n");
d372 2
a373 2
  DistillerSleepStatus sleepStatus_ = ((sleepOnStartup==gm_True) ? 
				       distSleep : distWakeUp);
d379 1
a379 1
      if (Register(requestID)==gm_True) return;
d449 3
a451 2
      loadNotificationTimer = new LoadNotificationTimer(evs,
						notificationTimeout_ms);
d475 1
a475 1
  if (ptmConnection->Connect(ptmAddress.ipAddress, ptmAddress.port)==gm_False) {
d505 1
a505 1
  listener = new Listener(multicastAddress.ipAddress, multicastAddress.port);
d533 2
a534 2
  strcpy(ptmAddress.ipAddress, newPtmAddress.ipAddress);
  ptmAddress.port = newPtmAddress.port;
d558 2
a559 1
  ostream << myAddress << '|' << distillerType << '|' << (UINT32)sleepStatus;
d734 1
a734 6
Distiller::CreateInstance(RemoteID &ptmAddress, RemoteID &multicast, 
			  RemoteID &monitorAddr, int monitorTTL,
			  DistillerType &distillerType, 
			  UINT32 notificationTimeout_ms, 
			  gm_Bool sleepOnStartup, char *optionsDBfile,
                          UINT32 requestID, int argc, const char *const *argv)
d736 85
a820 1
  instance = new Distiller(ptmAddress, multicast, monitorAddr, monitorTTL,
d823 2
a824 1
			   argc, argv);
d861 1
a861 1
         <<"    -o- <options-file-name>\n"
a862 1
	 <<"    -m <multicast-address/port-number> /*optional*/\n"
a863 1
	 <<"    -l <monitor-address/port-number[/ttl]> /*optional*/\n"
d866 1
a866 1
	 <<"    -i <request-id> /*optional*/\n"
d917 1
a917 1
  char     distillerTypeString[MAXDISTILLER_TYPE_STRING];
d919 4
a922 5
  RemoteID ptmAddress("", 0), monitor("", 0);
  RemoteID multicast(DefaultMulticastAddress, DefaultMulticastPort);
  char     *options = "o:p:m:t:l:n:i:s", *ptr;
  char     optionsDBfile[MAXPATH];
  int      optCh, monitorTTL=DefaultTTL;
a924 4
  strcpy(ptmAddress.ipAddress, "");
  ptmAddress.port = 0;
  strcpy(distillerTypeString, "");

d926 1
a926 1
  while ( done==gm_False && (optCh = getopt(argc, argv, options))!=-1) {
d933 1
a933 6
      if (sscanf(optarg,"%[^/]/%d",ptmAddress.ipAddress,&ptmAddress.port)!=2)
	Distiller::Usage(argv[0]);
      break;

    case 'm':
      if (sscanf(optarg, "%[^/]/%d", multicast.ipAddress, &multicast.port)!=2)
d938 1
a938 13
      strcpy(distillerTypeString, optarg);
      break;

    case 'l':
      ptr = strchr(optarg, '/');
      if (ptr==NULL) Distiller::Usage(argv[0]);
      if (sscanf(optarg, "%[^/]/%d", monitor.ipAddress, &monitor.port)!=2)
	Distiller::Usage(argv[0]);

      ptr = strchr(ptr+1, '/');
      if (ptr!=NULL) {
	sscanf(ptr+1, "%d", &monitorTTL);
      }
d947 1
a947 1
    case 'i':
d958 1
a958 1
      done = gm_True;
d963 17
a979 2
  if (*distillerTypeString=='\0') Distiller::Usage(argv[0]);
  DistillerType distillerType(distillerTypeString);
d982 1
a982 1
  sprintf(debugString, "%s: ", distillerTypeString);
d984 2
a985 2
  slash = strchr(distillerTypeString, '/');
  if (slash==NULL) slash = distillerTypeString-1;
d989 1
a989 3
  if (Distiller::CreateInstance(ptmAddress, multicast, monitor, monitorTTL, 
				distillerType, notificationTimeout_ms, 
				sleepOnStartup, optionsDBfile, requestID, 
@


1.38
log
@distiller.cc should include ARGS.h, not ALLARGS.h, from frontend
@
text
@d324 1
a324 1
    if ((myAddress.port = server->getLocalPort())==gm_False) return;
@


1.37
log
@combined distillers.db into gm_options
added re-reading of the options file to the PTM, thru a SIGUSR1
added arbitrary arguments capability to distillers. Extra args are passed
on to DistillerInit()
added functionality to flush the negative cache when the PTM re-reads the
options file or when it restarts
@
text
@d11 1
a11 1
#include "../../../frontend/include/ALLARGS.h"
@


1.36
log
@Fixed up so that both Armando and I are happy...
@
text
@d16 13
d288 1
a288 1
                     UINT32 requestID)
d341 1
d343 1
a343 1
  if (DistillerInit(type.c_struct)!=distOk) {
d726 1
a726 1
                          UINT32 requestID)
d730 2
a731 1
			   sleepOnStartup, optionsDBfile, requestID);
d833 1
a833 1
  gm_Bool  sleepOnStartup = gm_False;
d840 1
a840 1
  while ( (optCh = getopt(argc, argv, options))!=-1) {
d876 1
d889 1
a889 1
      Distiller::Usage(argv[0]);
d907 2
a908 2
				sleepOnStartup, optionsDBfile,
				requestID)==gm_False) {
@


1.35
log
@added distAsyncBegin to distiller return code.  modified ptm and distiller stubs to allow passing of options file name on distiller cmd line with -o
@
text
@d168 1
a168 1
  sprintf(filename, "../ptm/%s.%s.%ld", distType, hostname, getpid());
@


1.34
log
@priority and lottery now work.
@
text
@d7 4
d16 1
d274 2
a275 1
		     gm_Bool sleepOnStartup, UINT32 requestID)
d333 13
d711 2
a712 1
			  gm_Bool sleepOnStartup, UINT32 requestID)
d716 1
a716 1
			   sleepOnStartup, requestID);
d753 1
d815 2
a816 1
  char     *options = "p:m:t:l:n:i:s", *ptr;
d827 4
d891 1
a891 1
				sleepOnStartup,
@


1.33
log
@Priority queueing now works.
@
text
@d283 1
a283 1
  NEW(workQueue, PriorityQueue);
d556 1
a556 1
      fprintf(stderr, "Got ip %lu\n", ntohl(ip));
@


1.32
log
@IP addresses are now coming through OK.
@
text
@d282 2
a283 1
  NEW(workQueue, ProducerConsumerQueue);
@


1.31
log
@now pull out client IP address out of arg list.
@
text
@d555 1
a555 1
      fprintf(stderr, "Got ip %lu\n", ip);
@


1.30
log
@finalize queue changes.
@
text
@d4 1
d7 1
d537 2
d549 11
a559 1
  res = workQueue->Add((void *) work);
@


1.29
log
@frontend and ptm changes for new distiller api
@
text
@d127 1
a127 1
  //getStats()->AdjustAvgQLength(workQueue.getSize());
d229 2
a230 2
	    now.tv_usec, instTotalLatency_ms, avg, work->input.length, 
	    work->output.length, work->distillTime.tv_sec, 
a259 41
gm_Bool
ProducerConsumerQueue::Add(Work *work)
{
  mutex.Lock();

#ifdef _REPORT_STATS
  Statistics *stats = Distiller::getInstance()->getStats();
  if (stats!=NULL) stats->IncrementTotalRequests();
  //Distiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
#endif

  if (queue.InsertAtTail(work)==gm_False) {
    mutex.Unlock();
    return gm_False;
  }
  workInQueue.Signal();
  mutex.Unlock();
  return gm_True;
}


Work*
ProducerConsumerQueue::Remove()
{
  mutex.Lock();

#ifdef _REPORT_STATS
  //Distiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
#endif

  while (queue.IsEmpty()==gm_True) {
    workInQueue.Wait(&mutex);
  }

  Work *work = queue.RemoveFromHead();
  mutex.Unlock();
  return work;
}



d280 1
d365 1
d533 3
d545 7
a551 1
  return workQueue.Add(work);
d635 6
a640 1
    work = workQueue.Remove();
@


1.28
log
@Added the DistillerBuffer data structure to provide a more elegant way of
freeing buffers between the library and the main program
@
text
@a21 8
DistillerBuffer::~DistillerBuffer()
{
  if (freeMe==gm_True && data!=NULL) {
    DistillerFree(data);
  }
}


@


1.27
log
@config.h is now config_tr.h
@
text
@d14 4
a17 2
  if (input.data!=NULL) delete [] ((char*)input.data);
  if (freeOutputBuffer==gm_True) DistillerFree(output.data);
d22 8
d691 1
a691 2
				 &work->input, &work->output,
				 &work->freeOutputBuffer);
d776 1
a776 1
void *
d794 1
a794 1
}
@


1.26
log
@Added an extra arg to distillerinit to specify the distiller's name
@
text
@d129 1
a129 1
  //getStats()->Report();
@


1.25
log
@Removed debugging information from the PTM code.
Removed the setspecific/getspecific calls from frontend code
@
text
@d358 1
a358 1
  if (DistillerInit()!=distOk) {
@


1.24
log
@Modified distiller side code for instrumentation
Added stuff to the frontend side code to do predicting of the queue length
@
text
@d128 1
a128 1
  monitorClient->Send("Avg queue length", buffer, "");
d727 2
a728 1
  Distiller::getInstance()->getMonitorClient()->Gasp(0);
d864 1
a864 1
  char debugString[256], debugName[256], *slash;
d866 1
d870 2
a871 1
  Debug_::getInstance()->Initialize("et", debugString, debugName);
@


1.23
log
@Added sleep mechanism to the distillers
@
text
@d135 1
d137 3
d141 3
d147 16
d193 1
a193 1
LoadReporter::NewWork(DistillationCost *cost)
d196 1
a196 1
  instTotalLatency_ms += cost->estimatedTime_ms;
d198 12
d214 1
a214 1
LoadReporter::WorkDone(DistillationCost *cost)
d217 15
a231 1
  instTotalLatency_ms -= cost->estimatedTime_ms;
d320 3
d324 1
d578 1
a578 1
  reporter->NewWork(&work->cost);
d617 1
a617 1
      reporter->WorkDone(&work->cost);
d676 4
d683 4
@


1.22
log
@Distiller reports avg queue length every 8 seconds
@
text
@d127 1
a127 1
  sprintf(buffer, "%lu", reporter.getAvgLatency());
d135 2
a136 2
LoadReporter::LoadReporter()
  : instTotalLatency_ms(0), area(0)
d174 1
d196 12
d215 2
a216 1
  Distiller::getInstance()->getStats()->IncrementTotalRequests();
d256 8
a263 6
		     DistillerType &type, UINT32 notificationTimeout_ms, 
		     UINT32 requestID)
  : consumer(NULL), ptmAddress(ptm), multicastAddress(multicast), 
    distillerType(type), evs(NULL), server(NULL),
    ptmConnection(NULL), listener(NULL), 
    monitorClient(NULL), loadNotificationTimer(NULL)
d271 1
d309 6
a320 1

d354 53
d494 1
a494 1
  ostream << myAddress << '|' << distillerType;
d525 1
a525 1
  reporter.NewWork(&work->cost);
d534 1
a534 1
  reporter.Report(&load);
d564 1
a564 1
      reporter.WorkDone(&work->cost);
d572 4
d627 4
a630 1
    Distiller::getInstance()->getStats()->IncrementDoneRequests();
d639 2
a640 1
			  UINT32 notificationTimeout_ms, UINT32 requestID)
d643 2
a644 1
			   distillerType, notificationTimeout_ms, requestID);
d679 10
a688 9
	 << "Options:\n"
	 << "    -p <ptm-ip-address/port-number> (optional)\n"
	 << "    -m <multicast-address/port-number> (optional)\n"
	 << "    -t <distiller-type> (required)\n"
	 << "    -l <monitor-address/port-number[/ttl]> (optional)\n"
	 << "    -n <notification-timeout-ms> (optional)\n"
	 << "    -i <request-id> (optional)\n"
	 << "       (defaults to zero; used only when the PTM spawns a "
	    "distiller)\n");
d741 1
a741 1
  char     *options = "p:m:t:l:n:i:", *ptr;
d743 1
d787 4
d810 1
@


1.21
log
@Modified the PTM code to make a whole bunch of #defines customizable thru
the gm_options/distillers.db file
@
text
@d117 1
a117 1
  //Distiller::getInstance()->ReportStats();
d129 1
a129 1
  getStats()->Report();
@


1.20
log
@Major changes to the PTM. The PTM can now auto-launch new distillers when
the load on the system gets too high. The frontend stub has a separate
thread per connection to the distillers and PTM to handle network events
@
text
@d117 1
a117 1
  Distiller::getInstance()->ReportStats();
d242 2
a243 1
		     DistillerType &type, UINT32 requestID)
d255 2
a256 1
  NEW(loadNotificationTimer, LoadNotificationTimer(evs));
d459 1
a460 1

a461 1
  reporter.Report(&load);
d556 2
a557 1
			  DistillerType &distillerType, UINT32 requestID)
d560 1
a560 1
			   distillerType, requestID);
d600 1
d653 1
a653 1
  UINT32   requestID=0;
d656 1
a656 1
  char     *options = "p:m:t:l:i:", *ptr;
d692 5
d719 2
a720 1
				distillerType, requestID)==gm_False) {
@


1.19
log
@Major changes to the PTM stuff. The previous version has been tagged
stable_ptm.

The new version uses a new LinkedList library; the distiller-cache at
the frontend was rewritten to remove some concurrency bugs
@
text
@d5 1
d22 2
a23 2
 : currentQLengthWindow(0), totalRequests(0), doneRequests(0), badRequests(0),
   timer(NULL)
d30 1
a30 1
void
d90 1
a90 1
}
d96 1
a96 1
  double avg = getAvgQLength();
d107 2
a108 6
    sprintf(buffer, "%0.3f", (float) avg);
    monitorClient->Send("Avg queue length", buffer, "");
    /*sprintf(buffer, "%lu", lengthTimeProduct);
    monitorClient->Send("Product", buffer, "");
    sprintf(buffer, "%lu", totalTime);
    monitorClient->Send("Total time", buffer, "");*/
d125 4
a128 1
  getStats()->AdjustAvgQLength(workQueue.getSize());
d135 61
d203 1
a203 1
  Distiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
d222 1
a222 1
  Distiller::getInstance()->getStats()->AdjustAvgQLength(queue.getSize());
d422 1
a422 1
  if (packet.Send(ptmConnection)==gm_False) {
d440 3
a442 2
  status = ComputeDistillationCost(work->args, work->numberOfArgs,&work->input,
				   &work->cost);
d448 1
a448 1
  load.NewWork(&work->cost);
d456 1
d460 1
d464 1
a464 1
  if (packet.Send(ptmConnection)==gm_False) {
d488 1
a488 1
      load.WorkDone(&work->cost);
d704 6
a709 1
  Debug_::getInstance()->Initialize("et", "Dist: ");
@


1.18
log
@Added DistillerRealloc
@
text
@d21 1
a21 1
 : totalRequests(0), badRequests(0), lengthTimeProduct(0), totalTime(0),
a23 2
  gettimeofday(&lastUpdate, NULL);

d32 14
a48 1
  mutex.Lock();
a68 1
  mutex.Unlock();
d76 2
d79 8
a86 2
  if (totalTime==0) avg = 0;
  else avg = lengthTimeProduct/totalTime;
d102 2
d106 3
a108 3
    /*sprintf(buffer, "%0.3f", (float) avg);
    monitorClient->Send("Avg queue length", buffer, "");*/
    sprintf(buffer, "%lu", lengthTimeProduct);
d111 1
a111 1
    monitorClient->Send("Total time", buffer, "");
a196 3
  gm_Debug(dbgTmp, "Starting up distiller on port " << 
           server->getLocalPort() << "\n");

d223 2
d483 1
a485 1

@


1.17
log
@Committing changes before going in to modify the linked list routines
@
text
@d541 7
@


1.16
log
@Modified the PTM stuff to enable remote execution of processes
Currently using rsh and round-robin to select machines
@
text
@d24 1
a24 1
  gettimeofday(lastUpdate, NULL);
d32 1
a32 1
Statistics::AdjustAvgQLength(int length)
d79 14
a92 3
  cerr << "Total # of requests: " << totalRequests 
       << ", Bad requests: " << badRequests << '\n';
  cerr << "Avg Queue Length: " << avg << '\n';
@


1.15
log
@PTM stub now does a random selection from multiple distillers
@
text
@d19 85
d108 6
a117 2
  //numberOfItems++;
  totalRequests++;
d128 5
a137 1
  //numberOfItems--;
d155 3
d168 5
a363 5
  if (monitorClient!=NULL) {
    char totRequestsString[100];
    sprintf(totRequestsString, "%lu", workQueue.getTotalRequests());
    monitorClient->Send("Total requests", totRequestsString, "");
  }
@


1.14
log
@More changes for killing processes via the monitor
@
text
@d27 2
a28 1
  numberOfItems++;
d44 1
a44 1
  numberOfItems--;
d263 5
@


1.13
log
@Changes to the monitor for killing
@
text
@d85 1
a85 3
    int sigs[] = { SIGUSR1, SIGILL, SIGABRT, SIGBUS, SIGSEGV };
    monitorClient->GaspOnSignals(5, sigs);

d384 1
d511 1
@


1.12
log
@Modified distiller.cc to so that before calling DistillerMain,
output->mimeType is set to input->mimeType.
@
text
@d79 1
a79 2
    sprintf(unitID, "%s distiller: %s/%d", (char*)type, myAddress.ipAddress,
	    myAddress.port);
@


1.11
log
@Modified the ptm stub and distiller stub to use the new distiller API
@
text
@d349 1
@


1.10
log
@changed distiller interface to use struct DistillerInput/DistillerOutput in frontend,gif_munge,html_munge
@
text
@d13 2
a14 2
  if (input!=NULL) Packet::UnfreezeData((char*)input);
  if (freeOutputBuffer==gm_True) DistillerFree(output);
d62 1
a62 1
  if (DistillerInit()!=distOk) VoidReturn(errGenericError);
d84 1
a88 2
    if (Error::getStatus()!=success) return;

d96 4
d250 2
a251 2
  status = ComputeDistillationCost(work->args, work->numberOfArgs, work->input,
				   work->inputLength, &work->cost);
d254 1
a254 1
    evs->PostEvent(evDistillerReply, this, work);
d299 2
a300 2
	work->replyObject->SendReply(work->status, work->output, 
				     work->outputLength, work->replyID);
d349 2
a350 3
    work->status = DistillerMain(work->args,    work->numberOfArgs,
				 work->input,   work->inputLength,
				 &work->output, &work->outputLength,
d434 8
@


1.9
log
@Added "dying gasp" functionality to MonitorClient class: whenever a new
monitor is created, globals are set to record its socket id and unit
name, so that the program can respond to signals by jumping to a signal
handler that announces the program's death by sending a death packet.
New functions in monitor.cc: DyingGasp (class method), GaspOnSignals
(instance method), extern "C" void MonitorClientSigHandler (C signal
handler), CurrentMonitorSock and CurrentUnitId (static variables in
monitor.h).  If you can think of a better way to do this, please change
it.

Fixed bug in frontend HTTP request parsing that caused multi-packet
requests not to be read correctly.

Many changes to the monitor, mostly cosmetic, some functional, including
addition of "kill" button (there is now a "death protocol") and more
sane show/hide behavior that is integrated with iconifying.
@
text
@d69 3
@


1.8
log
@Modifications made to the PTM to remove bugs found while in India.
@
text
@d81 4
@


1.7
log
@Yatin's first commit from India
@
text
@d62 1
a62 1
  if (DistillerInit()!=distOk) VoidErrorReturn(errGenericError);
d80 2
a81 2
    if (monitorClient==NULL) VoidErrorReturn(errOutOfMemory);
    if (GlobalErrorCode!=success) return;
d86 2
a87 1
    SetFileLogging("/tmp/log.distiller");
d97 2
a98 2
  LOG ("Could not register with the PTM; "
       "trying to listen for new PTM address\n");
d133 1
a133 1
  if (ptmConnection==NULL) gm_BoolErrorReturn(errOutOfMemory);
d155 1
a155 1
  gm_BoolErrorReturn(success);
d162 1
a162 1
  if (listener!=NULL) gm_BoolErrorReturn(success);
d165 2
a166 2
  if (listener==NULL) gm_BoolErrorReturn(errOutOfMemory);
  if (GlobalErrorCode!=success) return gm_False;
d169 1
a169 1
  gm_BoolErrorReturn(success);
d188 1
a188 1
  if (ptmConnection!=NULL) gm_BoolErrorReturn(success);
d190 2
a191 2
  LOG("Found PTM at " << newPtmAddress.ipAddress << '/' 
      << newPtmAddress.port << '\n');
d197 2
a198 1
    if (GlobalErrorCode==errOutOfMemory) return gm_False;
d228 1
a228 1
    gm_BoolErrorReturn(success);
d231 2
a232 2
  LOG("Registered successfully with the PTM\n");
  gm_BoolErrorReturn(success);
d263 2
a264 1
    gm_BoolErrorReturn(success);
d266 1
a266 1
  gm_BoolErrorReturn(success);
d284 1
a284 1
      if (work==NULL) gm_BoolErrorReturn(errGenericError);
d293 1
a293 1
      gm_BoolErrorReturn(success);
d297 1
a297 1
    gm_BoolErrorReturn(errEvSysInvalidEvent);
d306 1
a306 1
  if (consumer==NULL) gm_BoolErrorReturn(errOutOfMemory);
d356 2
a357 2
  if (instance==NULL) gm_BoolErrorReturn(errOutOfMemory);
  if (GlobalErrorCode!=success) return gm_False;
d374 3
a376 15
  LOG("Aborting program: " << string << "\n\n"
      << "Abort status: Global error code = " << GlobalErrorCode << "\n"
      << "              Thread error code = " << ThreadErrorCode << "\n");

  if (GlobalErrorCode!=success) {
    LOG( "              Error file-name   = " << ErrorFilename << "\n"
      << "              Error line number = " << ErrorLineNo   << "\n");
  }

  LOG("              errno = " << errno << "\n");
  if (errno!=0) {
    LOG( "              Errno explanation: " << strerror(errno) << "\n");
  }

  if (instance!=NULL) delete instance;
d388 9
a396 9
  LOG("Usage: " << programName << " [options]\n\n"
      << "Options:\n"
      << "    -p <ptm-ip-address/port-number> (optional)\n"
      << "    -m <multicast-address/port-number> (optional)\n"
      << "    -t <distiller-type> (required)\n"
      << "    -l <monitor-address/port-number[/ttl]> (optional)\n"
      << "    -i <request-id> (optional)\n"
      << "       (defaults to zero; used only when the PTM spawns a "
                 "distiller)\n");
a436 4
  for (int i=0; i<argc; i++) {
    printf("argv[%d] = %s\n", i, argv[i]);
  }

d485 1
d494 1
a494 1
  LOG("Ending the distiller normally\n");
@


1.6
log
@Added DistillerMalloc and DistillerFree to distiller.cc
@
text
@d85 3
a87 1

d445 4
@


1.5
log
@Modified Bool, FALSE and TRUE to gm_Bool, gm_False and gm_True respectively
@
text
@d420 14
@


1.4
log
@Added load balancing stuff to the distiller and ptm. Still need to add
lottery scheduling to the cache manager
@
text
@d14 1
a14 1
  if (freeOutputBuffer==TRUE) DistillerFree(output);
d19 1
a19 1
Bool
d23 1
a23 1
  if (queue.InsertAtTail(work)==FALSE) {
d25 1
a25 1
    return FALSE;
d30 1
a30 1
  return TRUE;
d38 1
a38 1
  while (queue.IsEmpty()==TRUE) {
d67 1
a67 1
  if (evs->AddCommunicationObject(server)==FALSE) return;
d72 1
a72 1
    if (CommunicationObject::GetHostIPAddress(myAddress.ipAddress)==FALSE)
d74 1
a74 1
    if ((myAddress.port = server->getLocalPort())==FALSE) return;
d87 3
a89 3
  if (IsPTMFound()==TRUE) {
    if (ConnectToPTM()==TRUE) {
      if (Register(requestID)==TRUE) return;
d126 1
a126 1
Bool
d130 2
a131 2
  if (ptmConnection==NULL) BoolErrorReturn(errOutOfMemory);
  if (ptmConnection->Connect(ptmAddress.ipAddress, ptmAddress.port)==FALSE) {
d134 1
a134 1
    return FALSE;
d137 1
a137 1
  if (evs->AddCommunicationObject(ptmConnection)==FALSE) {
d140 1
a140 1
    return FALSE;
d152 1
a152 1
  BoolErrorReturn(success);
d156 1
a156 1
Bool
d159 1
a159 1
  if (listener!=NULL) BoolErrorReturn(success);
d162 2
a163 2
  if (listener==NULL) BoolErrorReturn(errOutOfMemory);
  if (GlobalErrorCode!=success) return FALSE;
d165 2
a166 2
  if (evs->AddCommunicationObject(listener)==FALSE) return FALSE;
  BoolErrorReturn(success);
d182 1
a182 1
Bool
d185 1
a185 1
  if (ptmConnection!=NULL) BoolErrorReturn(success);
d192 1
a192 1
  if (ConnectToPTM()==FALSE) {
d194 1
a194 1
    if (GlobalErrorCode==errOutOfMemory) return FALSE;
d201 1
a201 1
Bool
d207 1
a207 1
  if (ptmConnection==NULL) return FALSE;
d209 3
a211 3
  if (CommunicationObject::GetHostIPAddress(myAddress.ipAddress)==FALSE)
    return FALSE;
  if ((myAddress.port = server->getLocalPort())==FALSE) return FALSE;
d214 1
a214 1
  if (ostream.IsGood()==FALSE) return FALSE;
d218 1
a218 1
  if (packet.Send(ptmConnection)==FALSE) {
d224 1
a224 1
    BoolErrorReturn(success);
d228 1
a228 1
  BoolErrorReturn(success);
d232 1
a232 1
Bool
d248 1
a248 1
Bool
d251 1
a251 1
  if (ptmConnection==NULL || IsPTMFound()==FALSE) return TRUE;
d255 1
a255 1
  if (stream.IsGood()==FALSE) return FALSE;
d257 1
a257 1
  if (packet.Send(ptmConnection)==FALSE) {
d259 1
a259 1
    BoolErrorReturn(success);
d261 1
a261 1
  BoolErrorReturn(success);
d265 1
a265 1
Bool
d272 1
a272 1
Bool
d279 1
a279 1
      if (work==NULL) BoolErrorReturn(errGenericError);
d281 1
a281 1
      if (work->replyObject->IsDeleted()==FALSE) {
d288 1
a288 1
      BoolErrorReturn(success);
d292 1
a292 1
    BoolErrorReturn(errEvSysInvalidEvent);
d297 1
a297 1
Bool
d301 2
a302 2
  if (consumer==NULL) BoolErrorReturn(errOutOfMemory);
  if (consumer->Fork(ForkHelper, (void*)this)==FALSE) return FALSE;
d321 1
a321 1
  while (TRUE) {
d328 1
a328 1
    if (work->replyObject->IsDeleted()==TRUE) {
d344 1
a344 1
Bool
d351 2
a352 2
  if (instance==NULL) BoolErrorReturn(errOutOfMemory);
  if (GlobalErrorCode!=success) return FALSE;
d355 1
a355 1
  return TRUE;
d479 1
a479 1
				distillerType, requestID)==FALSE) {
d483 1
a483 1
  if (Distiller::getInstance()->Run()==FALSE)
@


1.3
log
@Modified the logging mechanism to use the monitor entity
Multiple PTM detect each other and die gracefully
Still need to do auto start of PTM by the proxy front end
@
text
@d233 40
d280 1
@


1.2
log
@Distiller and proxy communication layers are working.
PTM can auto-spawn distillers
Glurun and load balancing not yet implemented
@
text
@d1 2
d14 1
a14 1
  DistillerFree(output);
d54 2
a55 1
Distiller::Distiller(RemoteID &ptm, RemoteID &multicast,
d57 1
a57 1
  : consumer(NULL), ptmAddress(ptm), multicastAddress(multicast),
d59 2
a60 1
    ptmConnection(NULL), listener(NULL), loadNotificationTimer(NULL)
d62 2
d69 18
d122 1
d295 2
a296 1
				 &work->output, &work->outputLength);
d305 1
d308 2
a309 1
  instance = new Distiller(ptmAddress, multicast, distillerType, requestID);
d359 1
d367 12
d384 1
a384 1
  RemoteID ptmAddress("", 0);
d386 2
a387 2
  char     *options = "p:m:t:i:";
  int      optCh;
d410 12
d437 2
a438 2
  if (Distiller::CreateInstance(ptmAddress, multicast, distillerType, 
				requestID)==FALSE) {
@


1.1
log
@Distiller front end working
Cache manager broken
PTM network stuff not completely done
@
text
@d13 1
d188 1
a188 2
  ostream << myAddress.ipAddress << '|' << myAddress.port << '|'
	  << (char*) distillerType;
d215 6
a220 2
      work->replyObject->SendReply(work->status, work->output, 
				   work->outputLength, work->replyID);
d260 6
@
