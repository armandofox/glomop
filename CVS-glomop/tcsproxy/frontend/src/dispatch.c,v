head	1.50;
access;
symbols
	Yatin-final:1.48.2.4
	Yatin:1.48.0.2
	pre-yatin-merge:1.48
	transend-beta2:1.40
	fox-dev:1.40.4.5
	frontend-ng:1.35
	transend-beta-latest:1.35
	Aggregators:1.34
	NoAggregators:1.34
	iang:1.32.0.2
	alt-redispatch:1.30
	transend-beta:1.29.0.2
	SOSP:1.19
	merged_preintegrate:1.2
	heisenbug:1.2
	PRE_INTEGRATION:1.2;
locks; strict;
comment	@ * @;


1.50
date	98.01.24.22.51.58;	author fox;	state Exp;
branches;
next	1.49;

1.49
date	98.01.16.22.15.54;	author yatin;	state Exp;
branches;
next	1.48;

1.48
date	97.11.11.23.29.46;	author gribble;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	97.10.26.01.09.54;	author gribble;	state Exp;
branches;
next	1.46;

1.46
date	97.10.26.00.29.33;	author fox;	state Exp;
branches;
next	1.45;

1.45
date	97.10.25.00.38.34;	author gribble;	state Exp;
branches;
next	1.44;

1.44
date	97.10.18.00.57.40;	author fox;	state Exp;
branches;
next	1.43;

1.43
date	97.09.22.20.31.06;	author fox;	state Exp;
branches;
next	1.42;

1.42
date	97.09.10.06.08.39;	author gribble;	state Exp;
branches;
next	1.41;

1.41
date	97.08.30.21.34.14;	author fox;	state Exp;
branches;
next	1.40;

1.40
date	97.07.30.02.28.18;	author fox;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	97.07.29.00.31.59;	author fox;	state Exp;
branches;
next	1.38;

1.38
date	97.07.26.00.29.43;	author fox;	state Exp;
branches;
next	1.37;

1.37
date	97.07.24.18.50.02;	author fox;	state Exp;
branches;
next	1.36;

1.36
date	97.06.12.18.31.35;	author fox;	state Exp;
branches;
next	1.35;

1.35
date	97.06.04.01.16.40;	author fox;	state Exp;
branches;
next	1.34;

1.34
date	97.05.15.06.09.41;	author fox;	state Exp;
branches;
next	1.33;

1.33
date	97.05.11.11.23.31;	author fox;	state Exp;
branches;
next	1.32;

1.32
date	97.04.30.07.55.14;	author fox;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	97.04.28.19.03.47;	author fox;	state Exp;
branches;
next	1.30;

1.30
date	97.04.28.03.14.21;	author fox;	state Exp;
branches;
next	1.29;

1.29
date	97.04.26.01.32.41;	author fox;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	97.04.25.00.55.51;	author aspolito;	state Exp;
branches;
next	1.27;

1.27
date	97.04.23.00.11.42;	author fox;	state Exp;
branches;
next	1.26;

1.26
date	97.04.19.01.10.03;	author fox;	state Exp;
branches;
next	1.25;

1.25
date	97.04.09.02.14.48;	author fox;	state Exp;
branches;
next	1.24;

1.24
date	97.04.09.01.31.19;	author fox;	state Exp;
branches;
next	1.23;

1.23
date	97.04.08.17.31.21;	author fox;	state Exp;
branches;
next	1.22;

1.22
date	97.04.08.02.44.38;	author fox;	state Exp;
branches;
next	1.21;

1.21
date	97.04.06.23.57.59;	author fox;	state Exp;
branches;
next	1.20;

1.20
date	97.03.17.10.21.47;	author fox;	state Exp;
branches;
next	1.19;

1.19
date	97.03.05.00.30.57;	author fox;	state Exp;
branches;
next	1.18;

1.18
date	97.03.03.22.38.48;	author fox;	state Exp;
branches;
next	1.17;

1.17
date	97.02.27.03.10.51;	author fox;	state Exp;
branches;
next	1.16;

1.16
date	97.02.25.22.56.57;	author aspolito;	state Exp;
branches;
next	1.15;

1.15
date	97.02.24.22.36.33;	author fox;	state Exp;
branches;
next	1.14;

1.14
date	97.02.14.23.08.53;	author gribble;	state Exp;
branches;
next	1.13;

1.13
date	97.02.14.21.24.00;	author fox;	state Exp;
branches;
next	1.12;

1.12
date	97.02.14.06.35.01;	author fox;	state Exp;
branches;
next	1.11;

1.11
date	97.02.14.04.00.56;	author fox;	state Exp;
branches;
next	1.10;

1.10
date	97.02.13.02.01.54;	author yatin;	state Exp;
branches;
next	1.9;

1.9
date	97.02.08.00.46.47;	author gribble;	state Exp;
branches;
next	1.8;

1.8
date	97.02.07.22.47.54;	author fox;	state Exp;
branches;
next	1.7;

1.7
date	97.02.04.05.37.23;	author fox;	state Exp;
branches;
next	1.6;

1.6
date	97.01.29.06.00.42;	author yatin;	state Exp;
branches;
next	1.5;

1.5
date	97.01.29.05.53.26;	author fox;	state Exp;
branches;
next	1.4;

1.4
date	97.01.29.04.13.22;	author fox;	state Exp;
branches;
next	1.3;

1.3
date	97.01.06.05.43.28;	author fox;	state Exp;
branches;
next	1.2;

1.2
date	96.12.12.02.16.51;	author fox;	state Exp;
branches;
next	1.1;

1.1
date	96.12.11.05.25.51;	author fox;	state Exp;
branches;
next	;

1.29.2.1
date	97.05.09.01.01.53;	author fox;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	97.05.13.21.39.39;	author aspolito;	state Exp;
branches;
next	;

1.32.2.1
date	97.05.06.23.49.32;	author iang;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	97.05.08.23.29.07;	author iang;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	97.05.13.09.13.01;	author iang;	state Exp;
branches;
next	;

1.40.4.1
date	97.08.11.04.09.40;	author fox;	state Exp;
branches;
next	1.40.4.2;

1.40.4.2
date	97.08.14.16.40.19;	author fox;	state Exp;
branches;
next	1.40.4.3;

1.40.4.3
date	97.08.15.03.43.01;	author fox;	state Exp;
branches;
next	1.40.4.4;

1.40.4.4
date	97.08.15.07.02.54;	author fox;	state Exp;
branches;
next	1.40.4.5;

1.40.4.5
date	97.08.16.07.04.17;	author fox;	state Exp;
branches;
next	;

1.48.2.1
date	97.11.17.22.06.49;	author yatin;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	97.11.27.00.51.47;	author yatin;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	97.11.30.01.24.44;	author yatin;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	97.12.03.01.19.40;	author yatin;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Moved all browser/ files to wwwroot/ subdirs.  Added miniserver.pl to
eliminate need for separate webserver; notes about it are attached.
2 fixes to dispatch.c logic:
- for server-like dispatch, correct headers are now generated when the
server-mode worker attempts to do a redispatch. (previously, for this
case, the returned headers would be the headers of the original
*request*, not theserver response headers.)
- special-casing for the Prefs form URL was eliminated because it
interferes with the miniserver worker. (Ambiguity arises if a request
both matches the Prefs URL *and* matches the server-mode worker, and
it's ugly to have the miniserver worker special case this.)  Instead,
the miniserver.pl worker does  a redispatch to transend/text/html for
HTML documents, which should catch this case.  this is probably not the
Right Thing long term.

there is a new worker, miniserver.pl, which acts as a very simple
httpd.  the root of its filesystem is {proxy.home}/wwwroot.  note that
it doesn't currently handle cgi's or server-side includes or anything --
all it can do is serve simple static files.

i have made the following changes:

- new submodule tcsproxy/wwwroot, to hold the "support files" for TACC
  apps including transend and wingman.

- moved the existing support files for transend and wingman, including
  the java_gui stuff, from
  tcsproxy/browser to tcsproxy/wwwroot/transend, tcsproxy/wwwroot/wingman,
  and tcsproxy/wwwroot/java_gui, respectively.  tcsproxy/browser is now empty,
  and i will eventually prune it from the tree.

- updated the paths in the html munger transend.text.html to match the
  new structure.

- new perl_dir application miniserver.pl, and new toplevel file
  mime.types (used to map file suffixes to MIME types).  the application
  does in-memory caching and uses stat() to deduce when files need to be
  reloaded, so for local-disk files it shouldn't be too heavy of a
  load.  that the expectation is  that traffic to the wwwroot directory
   will be modest - this worker would suck for running a high-traffic
  server, since it doesn't bound the size of the in-memory cache or attempt
  to manage memory to keep "hot" items nearby as Harvest does.


the easiest way to make this mechanism work:

- add an entry to your options file:

        dist.myurl/dispatch: sbin/perl_stub -- perl_dir/miniserver.pl

- set frontend.aggString to the prefix of URL's that should be served
  from the "fake" web server.

- be sure frontend.webServerName matches frontend.aggString.  (this is
  necessary because frontend.webServerName is used by workers that want
  to access the "support files".  keeping these two properties separate
  leaves the option of running a separate web server if desired.)

- *** IMPORTANT *** because miniserver doesn't handle forms submission
   in any way, the frontend.prefsFormSubmitURL property must be
   constructed so that it DOES NOT MATCH anything that might be
   requested of miniserver.  this isn't so bad when you remember that
   the prefsFormSubmitUrl can be a totally imaginary server.
   UNFORTUNATELY, the file wwwroot/transend/prefs.html, which is the
   prefs-submission form, has to have some name wired into it; i picked
   "http://transend-prefs.cs.berkeley.edu", so that's what the config
   files will need to say for now.  i know this is kind of hacky.

-  note that for text/html files, miniserver.pl will redispatch to
   transend/text/html; for other files it will do nothing, ie just
   return the file.  i'm not sure this is the right thing all the time,
   though it's certainly right for transend (causes user prefs form to
   be filled in with existing prefs values).
@
text
@/*
 *  Dispatch a request by determining its MIME type and contacting the
 *  PTM/distiller cache to send the request to a distiller.  The
 *  argument list is already provided: it is the result of the user
 *  prefs lookup.  Pretty cool, huh.
 */

#include "userpref.h"
#include "debug.h"
#include "utils.h"
#include "frontend.h"
#include "ARGS.h"
#include "comm_http.h"
#include "proxyinterface.h"     /* PTM stub interface */
#include <stdio.h>
#include <string.h>

static void set_distiller_type(DistillerBuffer *mime_headers, const char *url,
                               const char *user, C_DistillerType *dtype);
static void set_distiller_type_generic(DistillerBuffer *mime_headers,
                                       const char *url,
                                       const char *user, C_DistillerType *dtype);
static DistillerStatus  do_distillation(const char *url,
                                        DistillerInput *din,
                                        DistillerOutput *dout,
                                        C_DistillerType *dtype,
                                        ArgumentList *al);


gm_Bool is_server_url(const char *url)
{
  if (*url=='/' || strncasecmp(url, fe_agg_string, strlen(fe_agg_string))==0)
    return gm_True;
  else
    return gm_False;
}

/*
 *  proxy_dispatch: dispatch a request to the correct distiller, then
 *  return result to client. This is a long blocking operation.
 *
 *  ARGS:
 *  i: argument list for distiller (from user prefs)
 *  i: task data structure
 *
 *  REENTRANT: yes
 *  ASSUMPTIONS: PTM stub has been initialized
 *  RETURNS: HTTP_Status code corresponding to server's/cache's return
 *  status for the request
 */

HTTP_Status
server_dispatch(ArgumentList *al, task_t *tsk)
{
  int thrindex = TASK_THRINDEX(tsk);
  int agg = 0;
  int nfound;
  HTTP_Status retcode = HTTP_NO_ERR;
  Request *hp = (Request *)TASK_DATA(tsk);
#ifdef LOGGING
  struct loginfo *lo = hp->lo;
#endif

  INST_set_thread_state(thrindex, THR_CACHE);

  /*
   *  If we got here, we know the request is either GET or POST,
   *  or this is a URL in the frontend's namespace
   */

  tsk->task_age = 0;            /* no pipe stages done yet */

  /*if (*hp->url == '/' || 
      strncasecmp(hp->url, fe_agg_string, strlen(fe_agg_string)) == 0) {*/
  if (is_server_url(hp->url)==gm_True) {
    /* this is a URL in the frontend's namespace, or an aggregator URL */
    const char *workerName, *val;
    int val_len, len, to_copy, already_read;
    char *orig_hdrs, *eoh, *new_hdrs, *body;
    extern Options runtime_options;

    orig_hdrs = DistillerBufferData(&hp->cli_hdrs);
    eoh = strstr(orig_hdrs, "\r\n\r\n");
    if (eoh==NULL) {
      retcode = HTTP_ERR_MALFORMED_REQUEST;
      goto DISPATCH_RETURN;
    }
    eoh += 4;

    /* clone the headers */
    DistillerBufferAlloc(&hp->svr_hdrs, eoh-orig_hdrs+1);
    new_hdrs = DistillerBufferData(&hp->svr_hdrs);
    memcpy(new_hdrs, orig_hdrs, eoh-orig_hdrs);
    *(new_hdrs+(eoh-orig_hdrs)) = '\0';
    DistillerBufferSetLength(&hp->svr_hdrs, eoh - orig_hdrs);
    DistillerBufferFreeMe(&hp->svr_hdrs, gm_True);

    /* 
     * look for the content-length field; 
     * if found, read the rest of the data and create svr_data 
     */
    if ((val = get_header_value(&hp->cli_hdrs, "content-length", &val_len,
				NULL, NULL)) != NULL) {
      len = strtoul(val, NULL, 0);
      if (len < 0) {
	retcode = HTTP_ERR_MALFORMED_REQUEST;
	goto DISPATCH_RETURN;
      }

      already_read = DistillerBufferLength(&hp->cli_hdrs) - (eoh - orig_hdrs);
      if (len <= already_read) {
	to_copy = len;
      } else {
	to_copy = already_read;
      }

      DistillerBufferAlloc(&hp->svr_data, len+1);
      body = DistillerBufferData(&hp->svr_data);
      memcpy(body, eoh, to_copy);
      
      /* get the rest of the data from the socket */
      if (to_copy < len) {
	if (readline_or_timeout(hp, len - to_copy, body+to_copy)
	    != (len-to_copy)) {
	  retcode = HTTP_ERR_MALFORMED_REQUEST;
	  goto DISPATCH_RETURN;
	}
      }

      /* add a trailing '\0' */
      *(body+len) = '\0';
      DistillerBufferSetLength(&hp->svr_data, len);
    }
    
    workerName = Options_Find(runtime_options, "frontend.myurl.dispatch");
    if (workerName==NULL) workerName = "myurl/dispatch";

    insert_header(&hp->svr_hdrs, "X-Route", workerName, 1);
    hp->svr_http_status = 200; /* everything's ok with this HTTP request */
  }
  else {
    INST_timestamp(thrindex, m_cachestart);
    if (hp->method[0] == 'g' || hp->method[0] == 'G') {
      /* handle GET */

#ifdef OLD
      /*
       *  HACK HACK HACK - this should be replaced with the real interface that
       *  does a regexp match on URL to determine if any aggregator should get
       *  dibs before the original content is fetched.
       *
       *  Any references in this function to variable 'agg' represent a place
       *  where the hack was spliced in.
       */
      if (strncasecmp(hp->url, fe_agg_string, strlen(fe_agg_string)) != 0) {
	/* not an aggregator call */
#endif
	agg = 0;
	retcode = do_get(hp, al);
	if (retcode != HTTP_NO_ERR) {
	  goto DISPATCH_RETURN;
	}
#ifdef OLD
      } else {
	/* aggregator call */
	abort();
	agg = 1;
	/* don't clone the client headers - just point to them. */
	DistillerBufferSetStatic(&hp->svr_hdrs,
				 DistillerBufferData(&hp->cli_hdrs),
				 DistillerBufferLength(&hp->cli_hdrs));
	/* since we're pointing to a copy, don't try to free */
	DistillerBufferFreeMe(&hp->svr_hdrs, gm_False);
      }
#endif
    } else {
      /* handle POST */
      retcode = do_post(hp, al);
      if (retcode != HTTP_NO_ERR) {
	/* post failed! report error to client */
	goto DISPATCH_RETURN;
      }
    }

    INST_timestamp(thrindex, m_cachedone);

    /*
     *  if there was an HTTP-level error (response code not "200"), bypass
     *  the remainder straight to client.
     */
    
    nfound = sscanf(DistillerBufferData(&hp->svr_hdrs), "%*s %lu",
		    &hp->svr_http_status);
    if (nfound < 1) {             /* no status found */
      retcode = HTTP_ERR_GET_FAILED;
      hp->svr_http_status = 0;
    } else {
      retcode = HTTP_NO_ERR;
    }
  }

#ifdef LOGGING
  lo->http_response = hp->svr_http_status;;      /* log HTTP server response */
#endif /* LOGGING */

  /*
   *  Note that HTTP_NO_ERR means "transaction to server succeeded" (ie
   *  at the transport level).  it does NOT necessarily mean that the
   *  HTTP *operation* (eg GET) succeeded -- the HTTP status code tells that.
   */

DISPATCH_RETURN:
  return retcode;
}


DistillerStatus
proxy_dispatch(ArgumentList *al, task_t *t)
{
  DistillerStatus status;       /* result of this pipe stage distillation */
  DistillerInput din;
  DistillerOutput dout;
  Request *hp = (Request *)TASK_DATA(t);
  C_DistillerType dtype;
  int thrindex = TASK_THRINDEX(t);
  DistillerStatus retcode;
  int redispatch = 0;
  char *static_route = NULL;
  int static_route_initialized = 0;
#ifdef LOGGING
  struct loginfo *lo = hp->lo;
#endif

  /*
   *  Initialize for *first* pipe stage.
   */

  DistillerBufferClone(&din.data, &hp->svr_data);
  DistillerBufferFreeMe(&din.data, gm_True);

  /*
   *  Make a **copy** of the server headers, because they may get
   *  overwritten when preparing headers to send to a distiller.
   */
  DistillerBufferClone(&din.metadata, &hp->svr_hdrs);
  DistillerBufferFreeMe(&din.metadata, gm_True);
  
  do {
    const char *char_tmp;
    char content_type[MIME_TYPE_MAX+1];
    int content_type_len;
    Argument *arg;
    int num_tries_left;

    /*
     *  Initialize for next pipe stage.
     */
    status = distFatalError;

#ifdef LOGGING
    /*
     *   Log original content-length
     */
    char_tmp = get_header_value(&din.metadata,
                                "content-length",
                                &content_type_len, NULL, NULL);
    if (char_tmp != NULL)
      lo->size_before = strtoul(char_tmp, NULL, 0);
    else
      lo->size_before = -1;
#endif /* LOGGING */
    char_tmp = get_header_value(&din.metadata,
                                "content-type",
                                &content_type_len, NULL, NULL);
    if (char_tmp != NULL) {
      strncpy(content_type, char_tmp, MIN(content_type_len+1, MIME_TYPE_MAX));
      content_type[MIN(content_type_len,MIME_TYPE_MAX)] = '\0';
    } else {
      content_type[0] = '\0';
    }

    /* if there are attributes after the content-type, remove them. */
    if ((char_tmp = strchr((const char *)content_type, ';')) != NULL)
      *(char *)char_tmp = '\0';
    /* chop any trailing spaces. */
    if ((char_tmp = strchr((const char *)content_type, ' ')) != NULL)
      *(char *)char_tmp = '\0';

    /*
     *  Distillation is definitely needed, so go do it.  In case of
     *  distConnectionBroken error, (re)try at most N
     *  times, where N is the value of the FRONT_RETRY_DISTILL argument,
     *  or PERF_HTTP_RETRY_DISTILL by default.  In case of any other
     *  error, or if all retries fail, bypass the original content.  In
     *  case of distOk (success), return the distilled content.
     */

    arg = getArgumentFromIdInList(al, FRONT_RETRY_DISTILL);
    num_tries_left = (arg ? ARG_INT(*arg) : PERF_HTTP_RETRY_DISTILL);
    INST_timestamp(thrindex, m_distillstart);
    /*
     *  Add a "Location:" header so distillers have a way to get the URL of
     *  this document, if they want. 
     */
    if (get_header_value(&din.metadata,
                         "location", NULL, NULL, NULL)
        == NULL) {
      insert_header(&din.metadata, "Location", hp->url, 0);
    }

    do {
      INST_set_thread_state(thrindex, THR_DISTILLER);
      status = do_distillation(hp->url, &din, &dout, &dtype, al);
    } while (status == distConnectionBroken
             && num_tries_left-- > 0);

#ifdef LOGGING
    lo->size_after = -status;     /* pessimistically assume failure for log */
#endif /* LOGGING */

    switch(status) {
    case distOk:
    case distRedispatch:
      /*
       *  The rules for redispatch are as follows.
       *  - If the response headers contain a nonempty X-Static-Route header, it
       *    is the final authority. X-Static-Route is only saved the
       *    first time it's seen.
       *  - Otherwise, if the response code is distRedispatch, use the
       *    default rules to figure out who to go to next.
       *  - Otherwise, the response is distOk --> just finish.
       */

      if (! static_route_initialized
          && DistillerBufferLength(&dout.metadata) > 0) {
        /* look for X-Static-Route */
        int tmp_len;
        const char *static_route_hdr =
          get_header_value(&dout.metadata,
                           "x-static-route", &tmp_len, NULL, NULL);
        if (static_route_hdr != NULL && tmp_len > 0) {
          static_route = ALLOCA(tmp_len+1);
          strncpy(static_route, static_route_hdr, tmp_len);
          static_route[tmp_len] = '\0';
          static_route_initialized = 1;
          delete_header(&dout.metadata, "x-static-route");
        }
      }

      if (static_route ||
          (status == distRedispatch && !static_route_initialized)) {
        /*
         *  this is a redispatch.
         *  The redispatch strategy is as follows.  Since the
         * DistillerInput pointer starts out being  a *clone* of the
         * server headers and data, it's always safe to free it.  THen move the
         *  DistillerOutput pointer (result of previous pipestage) to the
         *  DistillerInput pointer of this pipestage.  
         */

        DistillerBufferFree(&din.metadata);
        DistillerBufferFree(&din.data);
        DistillerBufferClone(&din.metadata, &dout.metadata);
        DistillerBufferClone(&din.data, &dout.data);
        DistillerBufferFree(&dout.metadata);
        DistillerBufferFree(&dout.data);

        /*
         *  Fix the content-length and content-type, if nec.
         */
        if (get_header_value(&din.metadata, "content-type",NULL,NULL,NULL)
            == NULL)
          insert_header(&din.metadata, "Content-type", din.mimeType, 1);
        if (get_header_value(&din.metadata, "content-length", NULL,NULL,NULL)
            == NULL) {
          char __tmp[12];
          snprintf(__tmp, 11, "%lu", DistillerBufferLength(&din.data));
          insert_header(&din.metadata, "Content-length", __tmp, 1);
        }
        if (static_route) {
          status = distRedispatch;
          /* add the X-Route header to this request */
          insert_header(&din.metadata, "X-Route", static_route, 1);
          /* scan forward to the next component of the path */
          while (*static_route && (*static_route != ';')) {
            static_route++;
          }
          if (*static_route == '\0') {
            static_route = NULL;
          } else {
            /* skip semicolon and any spaces */
            while (*static_route && ((*static_route == ';')
                                     || (*static_route == ' '))) {
              static_route++;
            }
            if (*static_route == '\0')
              static_route = NULL;
          }
        }
        redispatch++;
        t->task_age++; /* "time to live" of this request */
        retcode = distRedispatch;
      } else {
        /*
         *  Here if any of the following were true:
         *  - status was distOk and no static route header overrides this
         *  - status was distRedispatch, but an existing static route header
         *     indicates that we should override and finish with 
         */
#ifdef LOGGING
        lo->size_after = DistillerBufferLength(&dout.data);
#endif /* LOGGING */
        status = retcode = distOk;
      }
      break;

    default:                    /* some other distiller/ptm error */
      /*
       *  BUG::we shouldn't make this visible to the user unless the
       * "guru" argument is set
       */
      snprintf(hp->errmsg, HTTP_ERRMSG_MAX,
               (char *)FE_getDistillerStatusString(status));
      /*      retcode = HTTP_ERR_DISTILLER; XXX - XXX - XXX - */
      retcode = status;
      break;
      
    } /* switch(status) */

    /* Note that the data size is set last.  So if the data size is not zero,
       it's a reasonable indication that this is a compelte set of valid
       measurements.  (should really have a separate valid bit)
       */
    INST_set_size(thrindex, DistillerBufferLength(&dout.data));

  }  while ((status == distRedispatch)
            &&  t->task_age <= PERF_REQUEST_TTL);  /* do */
  
  /*
   *  "Copy" final output buffer to hp->pxy_hdrs/hp->pxy_data.  (Really
   *  we just copy the pointers, since the pxy_hdrs/pxy_data buffers
   *  will be freed by the caller.)
   *
   *  First generate headers to return to client.  If last-stage
   *  distiller returned
   *  some headers, use them; otherwise, replace the "content-length"
   *  and "content-type" fields of the ORIGINAL server headers with
   *  new values deduced from the distiller data.
   */
  if (status == distOk) {
    if (DistillerBufferLength(&(dout.metadata)) > 0) {
      DistillerBufferClone(&hp->pxy_hdrs, &dout.metadata);
    } else {
      /*
       *  If the server headers begin with an HTTP/x.x response code, they are
       *  headers from an origin server; OK to clone them and just replace the
       *  content-type and content-length.  Otherwise, they are probably
       *  the result of a server-mode dispatch worker, which means they
       *  actually look like request headers (not response headers), so delete them.
       */
      if (DistillerBufferLength(&hp->svr_hdrs) > 0
          && strncasecmp(DistillerBufferData(&hp->svr_hdrs), "HTTP/", 5) == 0) {
        DistillerBufferClone(&hp->pxy_hdrs, &hp->svr_hdrs);
        delete_header(&hp->pxy_hdrs,  "content-type");
        delete_header(&hp->pxy_hdrs,  "content-length");
      } else {
        char *s = "HTTP/1.0 200 OK\r\n\r\n";
        int l = strlen(s);
        DistillerBufferAlloc(&hp->pxy_hdrs, 1+l);
        strcpy((char *)(hp->pxy_hdrs.data), s);
        DistillerBufferSetLength(&hp->pxy_hdrs,l);
      }
    }
  
    /*
   *  Replace the "Content-length" and "Content-type"
   *  headers with the correct info.  Leave other headers
   *  alone.
   */
    if (get_header_value(&hp->pxy_hdrs, "content-type", NULL,NULL,NULL) 
	== NULL) {
      insert_header(&hp->pxy_hdrs, "Content-type", dout.mimeType, 1);
    }
    
    if (get_header_value(&hp->pxy_hdrs,"content-length",NULL,NULL,NULL)
	== NULL) {
      char __tmp[12];
      snprintf(__tmp, 11, "%lu", DistillerBufferLength(&dout.data));
      insert_header(&hp->pxy_hdrs, "Content-length", __tmp, 1);
    }

    DistillerBufferClone(&hp->pxy_data, &dout.data);
  }

  if ((status == distOk) || (status == distRedispatch)) {
    DistillerBufferFree(&dout.data);
    DistillerBufferFree(&dout.metadata);
  }

  /* Always free this */
  DistillerBufferFree(&din.data);
  DistillerBufferFree(&din.metadata);
  
  /* BUG::must do Clib_Put here??? */
  return (retcode);
}

/*
 *  HTTP headers looked OK, and we were able to determine what type of
 *  distiller was needed, so go ahead and do the distillation, returning
 *  the results to the client.  If distillation fails, return the
 *  original content and headers to the client.
 *
 *  ARGS:
 *    i:  URL (BUG::shouldn't be needed - it's currently used to
 *      determine distiller type for "aggregator" virtual-site URLs )
 *    i: input to distiller (from previous "pipestage" or from server)
 *    o: output from distiller
 *    o: distiller type descriptor
 *    i: argument list for distiller
 *
 *  RETURNS:  Distiller status for the distillation
 *  REENTRANT: yes
 *  SIDE EFFECTS:
 *    If distillation succeeds, fills in new headers (for return to client)
 *      in DistillerOutput structure
 *  ASSUMTPIONS:
 *    None
 */
static DistillerStatus
do_distillation(const char *url,
                DistillerInput *dinp, DistillerOutput *doutp,
                C_DistillerType *dtype,
                ArgumentList *al)
{
  DistillerStatus result = distFatalError;
  Argument *arg;
  const char *whichuser = "transend";
  const char *mime;
  int mime_len;

  /*
   *  HTTP headers look OK.  Extract the MIME type, figure out what
   *  distiller to use, and dispatch to it.
   */

  if ((arg = getArgumentFromIdInList(al, FRONT_USERID))) {
    whichuser = ARG_STRING(*arg);
  }

  /*
   *  If this is the set-prefs page, be sure the user's args get munged into it
   * REMOVED by fox since it interferes with the "mini-httpd" worker (miniserver.pl):
   * this routing is now enforced by X-Route instead
   */
  if (0 && strcasecmp(url, fe_set_prefs_url) == 0) {
    SET_DISTILLER_TYPE(*dtype, "transend/text/html");
  } else {
    set_distiller_type(&dinp->metadata,
                       (const char *)url, 
                       whichuser, dtype);
  }
  
  if ((mime = get_header_value(&dinp->metadata,
                               "content-type",
                               &mime_len, NULL, NULL)) != NULL) {
    strncpy(dinp->mimeType, mime, MIN(mime_len,MAX_MIMETYPE-1));
    dinp->mimeType[MIN(mime_len,MAX_MIMETYPE-1)] = '\0';
  } else {
    strcpy(dinp->mimeType, "text/html");
  }
  result = Distill(dtype, al->arg, al->nargs, dinp, doutp);
  return result;
}
/*
 *  Set the distiller type based on the HTTP MIME headers,
 *  the generic user id, and/or the URL, as follows:
 *
 *  1. If headers contain X-Route: dist1;dist2;...;distN, (or X-Route-Strict),
 *     mutate the header by 
 *     popping off the head of that list, and use that as the distiller.
 *     EXCEPTION: the "prefs" page always gets the system distiller.
 *  2. Otherwise, grab the MIME type (from headers; if not found, assume
 *     text/html), and prepend either the user's userid or "transend" if the
 *     user has no registered userid.
 *
 *  If PTM reports distiller not found, also try using the transend-generic
 *     distiller for this MIME type, *unless* the routing header 
 *     indicated strict routing.
 *
 *  ASSUMPTIONS: none
 *  THREAD-SAFE: yes
 *  RETURNS: gm_True iff OK to retry distillation using system's generic
 *     distillers 
 *  SIDE EFFECTS: none
 */
  
static void
set_distiller_type(DistillerBuffer *mime_headers, const char *url,
                   const char *user, C_DistillerType *dtype)
{
  const char *route = NULL;
  int route_len;
  char *disttype;

  if ((route = get_header_value(mime_headers,
                                "x-route",&route_len,NULL,NULL))
      == NULL) {

    /* Aggregator? */

    if (strncasecmp(url, fe_agg_string, strlen(fe_agg_string)) == 0) {
      /* distiller "type" is everything up to but not incl next slash */
      char disttype_tmp[256];
      int i,j;
      for (i=0, j=strlen(fe_agg_string);
           i < strlen(url) && url[j] != '/';
           i++,j++)
        ;
      strncpy(disttype_tmp, url+strlen(fe_agg_string), i);
      disttype_tmp[i] = '\0';
      SET_DISTILLER_TYPE(*dtype, disttype_tmp);

    } else {
      /* generic transformation */
      set_distiller_type_generic(mime_headers, url, user, dtype);
    }
  } else {
    
    /* pop off next element, up to a semicolon */
    char *header_value = (char *)ALLOCA(route_len+1);
    char *semicolon;

    strncpy(header_value, route, route_len);
    header_value[route_len] = '\0';
    
    if ((semicolon = strchr(header_value, ';')) != NULL) {
      int i;
      for (i=0; i<route_len && route[i] != ';'; i++)
        ;
      disttype = (char*)ALLOCA(i+2);
      strncpy(disttype, route, i);
      disttype[i] = '\0';
      insert_header(mime_headers, "x-route", semicolon+1, 0);
    } else {
      /* no semicolon, this is the last guy in the list */
      disttype = (char *)ALLOCA(route_len+2);
      strncpy(disttype, route, route_len);
      disttype[route_len] = '\0';
    }
    delete_header(mime_headers, "x-route");
    SET_DISTILLER_TYPE(*dtype, disttype);
  }
}

static void
set_distiller_type_generic(DistillerBuffer *mime_headers, const char *url,
                           const char *user, C_DistillerType *dtype)
{
  char *mimetype;
  int mimetype_len;
  char disttype[MAX_ARG_STRING + MAX_MIMETYPE + 1];

  /*
   *  Here if no X-Route header: use MIME type and/or username. 
   */
  mimetype = (char *)get_header_value(mime_headers,
                                      "content-type",
                                      &mimetype_len, NULL, NULL);
  if (mimetype == NULL) {
    if (user == NULL || *user == '\0')
      sprintf(disttype, "text/html");
    else
      sprintf(disttype, "%s/text/html", user);
  } else {
    if (user && *user)
      sprintf(disttype, "%s/", user);
    else
      disttype[0] = '\0';
    strncat(disttype, mimetype, mimetype_len);
  }
  SET_DISTILLER_TYPE(*dtype, disttype);
}
    
@


1.49
log
@- new wingman frontend
- new wingman aggregators mechanism
- DistillAsync

(merged from branch Yatin-final)
@
text
@d454 19
a472 3
      DistillerBufferClone(&hp->pxy_hdrs, &hp->svr_hdrs);
      delete_header(&hp->pxy_hdrs,  "content-type");
      delete_header(&hp->pxy_hdrs,  "content-length");
d553 2
d556 1
a556 1
  if (strcasecmp(url, fe_set_prefs_url) == 0) {
@


1.48
log
@Fixed buglet in dispatch.c.
@
text
@d13 1
d28 10
a64 1
  INST_timestamp(thrindex, m_cachestart);
d67 2
a68 1
   *  If we got here, we know the request is either GET or POST.
d70 1
d72 29
a100 10
  
  if (hp->method[0] == 'g' || hp->method[0] == 'G') {
    /* handle GET */
    /*
     *  HACK HACK HACK - this should be replaced with the real interface that
     *  does a regexp match on URL to determine if any aggregator should get
     *  dibs before the original content is fetched.
     *
     *  Any references in this function to variable 'agg' represent a place
     *  where the hack was spliced in.
d102 77
a178 4
    if (strncasecmp(hp->url, fe_agg_string, strlen(fe_agg_string)) != 0) {
      /* not an aggregator call */
      agg = 0;
      retcode = do_get(hp, al);
d180 2
a181 1
        goto DISPATCH_RETURN;
a182 17
    } else {
      /* aggregator call */
      abort();
      agg = 1;
      /* don't clone the client headers - just point to them. */
      DistillerBufferSetStatic(&hp->svr_hdrs,
                               DistillerBufferData(&hp->cli_hdrs),
                               DistillerBufferLength(&hp->cli_hdrs));
      /* since we're pointing to a copy, don't try to free */
      DistillerBufferFreeMe(&hp->svr_hdrs, gm_False);
    }
  } else {
    /* handle POST */
    retcode = do_post(hp, al);
    if (retcode != HTTP_NO_ERR) {
      /* post failed! report error to client */
      goto DISPATCH_RETURN;
a183 1
  }
d185 1
a185 1
  INST_timestamp(thrindex, m_cachedone);
d187 13
a199 12
  /*
   *  if there was an HTTP-level error (response code not "200"), bypass
   *  the remainder straight to client.
   */

  nfound = sscanf(DistillerBufferData(&hp->svr_hdrs), "%*s %lu",
                  &hp->svr_http_status);
  if (nfound < 1) {             /* no status found */
    retcode = HTTP_ERR_GET_FAILED;
    hp->svr_http_status = 0;
  } else {
    retcode = HTTP_NO_ERR;
d215 1
@


1.48.2.1
log
@- Modularized the wingman frontend by splitting wing_go_proc into
  multiple smaller functions

- New aggregator mechanism for wingman proxies. The WingDispatch worker
  receives a request with a special content-type application/x-wingman-agg.
  The body of the request contains the full aggregator url

  The worker should return a valid HTTP response, which might be a
  pilot-ready document (i.e. an x-wingman/* document) or an HTTP
  redirect to a new URL, or whatever it chooses!)

- The WingDispatcher is now expected to weed out unintelligible content-types
  and return a content-type of x-wingman/<integer> to the frontend, where
  <integer> represents the integral content type returned to the pilot client.

- Agglist: this appears at the dispatcher as a special aggregator request
  with a url of agg://agglist/ (this URL is actually defined in the
  gm_options file, so the worker should check against the gm_options
  entry, rather than a hard-coded entry). The worker that handles this
  request *MUST* return a document with content type
  x-wingman/2 and the actual agglist as part of the data.

  For old browsers, the data part of this response is stuffed into an
  appropriate metadata field by the frontend before sending the reply to
  the client (i.e. it is backward compatible). For browsers with the new
  version number, the browser will no longer set any special flags in the
  metadata field of the client request. Instead it will explicitly request
  for the agg://agglist/ url. It'll check the ContentType field in the
  response for content type 2 to match up the correct response.

- Created a new version number for the agglist changes:
  #define CLIENT_VERSION_NEWAGG 0x01050200

- gm_options changes:
  Here are the three new gm_options entries for wingman: (the
  wingman.text.prefetch_href replaces the old prefetch.href entry)

  wingman.about_url: http://www.isaac.cs.berkeley.edu/pilot/wingman/about-
  wingman.agglist_url: agg://agglist/
  wingman.text.prefetch_href: 10

- PTM changes:
  - Background distillers work. Specify the -e flag before the -- in the
    gm_options line for the distiller. The PTM will IMMEDIATELY respawn the
    distiller if it crashes. This mechanism is still very simple and naive
  - Distillers can rename themselves: API function DistillerReregister.
@
text
@d54 1
d57 1
a57 2
   *  If we got here, we know the request is either GET or POST,
   *  or this is a URL in the frontend's namespace
a58 1

d60 10
a69 11

  if (*hp->url == '/' || 
      strncasecmp(hp->url, fe_agg_string, strlen(fe_agg_string)) == 0) {
    /* this is a URL in the frontend's namespace, or an aggregator URL */

    DistillerBufferClone(&hp->svr_hdrs, &hp->cli_hdrs);
    DistillerBufferFreeMe(&hp->svr_hdrs, gm_True);
    
    /* 
     * HACK: setting content type to text/html, so frontend doesn't bypass
     * the data directly to the client
d71 6
a76 37
    insert_header(&hp->svr_hdrs, "Content-type", "text/html", 0);
    insert_header(&hp->svr_hdrs, "X-Route", "transend/myurl/dispatch", 0);
    hp->svr_http_status = 200; /* everything's ok with this HTTP request */
  }
  else {
    INST_timestamp(thrindex, m_cachestart);
    if (hp->method[0] == 'g' || hp->method[0] == 'G') {
      /* handle GET */

#ifdef OLD
      /*
       *  HACK HACK HACK - this should be replaced with the real interface that
       *  does a regexp match on URL to determine if any aggregator should get
       *  dibs before the original content is fetched.
       *
       *  Any references in this function to variable 'agg' represent a place
       *  where the hack was spliced in.
       */
      if (strncasecmp(hp->url, fe_agg_string, strlen(fe_agg_string)) != 0) {
	/* not an aggregator call */
#endif
	agg = 0;
	retcode = do_get(hp, al);
	if (retcode != HTTP_NO_ERR) {
	  goto DISPATCH_RETURN;
	}
#ifdef OLD
      } else {
	/* aggregator call */
	abort();
	agg = 1;
	/* don't clone the client headers - just point to them. */
	DistillerBufferSetStatic(&hp->svr_hdrs,
				 DistillerBufferData(&hp->cli_hdrs),
				 DistillerBufferLength(&hp->cli_hdrs));
	/* since we're pointing to a copy, don't try to free */
	DistillerBufferFreeMe(&hp->svr_hdrs, gm_False);
a77 1
#endif
d79 16
a94 6
      /* handle POST */
      retcode = do_post(hp, al);
      if (retcode != HTTP_NO_ERR) {
	/* post failed! report error to client */
	goto DISPATCH_RETURN;
      }
d96 1
d98 1
a98 1
    INST_timestamp(thrindex, m_cachedone);
d100 12
a111 13
    /*
     *  if there was an HTTP-level error (response code not "200"), bypass
     *  the remainder straight to client.
     */
    
    nfound = sscanf(DistillerBufferData(&hp->svr_hdrs), "%*s %lu",
		    &hp->svr_http_status);
    if (nfound < 1) {             /* no status found */
      retcode = HTTP_ERR_GET_FAILED;
      hp->svr_http_status = 0;
    } else {
      retcode = HTTP_NO_ERR;
    }
a126 1

@


1.48.2.2
log
@fixes for myurl/dispatch
exposed runtime_options globally
@
text
@d65 1
a65 3
    const char *workerName;
    extern Options runtime_options;
    
a72 3
    workerName = Options_Find(runtime_options, "frontend.myurl.dispatch");
    if (workerName==NULL) workerName = "myurl/dispatch";

d74 1
a74 1
    insert_header(&hp->svr_hdrs, "X-Route", workerName, 0);
@


1.48.2.3
log
@- Fixed POST bug for server-type URL's
- Fixed httpgo.c so it will never bypass if it is a server-type URL
  (that way I don't need a bogus "content-type: text/html" field in
   the server headers)
@
text
@a12 1
#include "comm_http.h"
d65 1
a65 3
    const char *workerName, *val;
    int val_len, len, to_copy, already_read;
    char *orig_hdrs, *eoh, *new_hdrs, *body;
d67 2
a68 15

    orig_hdrs = DistillerBufferData(&hp->cli_hdrs);
    eoh = strstr(orig_hdrs, "\r\n\r\n");
    if (eoh==NULL) {
      retcode = HTTP_ERR_MALFORMED_REQUEST;
      goto DISPATCH_RETURN;
    }
    eoh += 4;

    /* clone the headers */
    DistillerBufferAlloc(&hp->svr_hdrs, eoh-orig_hdrs+1);
    new_hdrs = DistillerBufferData(&hp->svr_hdrs);
    memcpy(new_hdrs, orig_hdrs, eoh-orig_hdrs);
    *(new_hdrs+(eoh-orig_hdrs)) = '\0';
    DistillerBufferSetLength(&hp->svr_hdrs, eoh - orig_hdrs);
d70 1
a70 1

d72 2
a73 2
     * look for the content-length field; 
     * if found, read the rest of the data and create svr_data 
a74 33
    if ((val = get_header_value(&hp->cli_hdrs, "content-length", &val_len,
				NULL, NULL)) != NULL) {
      len = strtoul(val, NULL, 0);
      if (len < 0) {
	retcode = HTTP_ERR_MALFORMED_REQUEST;
	goto DISPATCH_RETURN;
      }

      already_read = DistillerBufferLength(&hp->cli_hdrs) - (eoh - orig_hdrs);
      if (len <= already_read) {
	to_copy = len;
      } else {
	to_copy = already_read;
      }

      DistillerBufferAlloc(&hp->svr_data, len+1);
      body = DistillerBufferData(&hp->svr_data);
      memcpy(body, eoh, to_copy);
      
      /* get the rest of the data from the socket */
      if (to_copy < len) {
	if (readline_or_timeout(hp, len - to_copy, body+to_copy)
	    != (len-to_copy)) {
	  retcode = HTTP_ERR_MALFORMED_REQUEST;
	  goto DISPATCH_RETURN;
	}
      }

      /* add a trailing '\0' */
      *(body+len) = '\0';
      DistillerBufferSetLength(&hp->svr_data, len);
    }
    
d78 2
a79 1
    insert_header(&hp->svr_hdrs, "X-Route", workerName, 1);
@


1.48.2.4
log
@bug fix for non-get/post requests for web-server-like URL's
@
text
@a27 10


gm_Bool is_server_url(const char *url)
{
  if (*url=='/' || strncasecmp(url, fe_agg_string, strlen(fe_agg_string))==0)
    return gm_True;
  else
    return gm_False;
}

d63 2
a64 3
  /*if (*hp->url == '/' || 
      strncasecmp(hp->url, fe_agg_string, strlen(fe_agg_string)) == 0) {*/
  if (is_server_url(hp->url)==gm_True) {
@


1.47
log
@Fixed up logging, and spurious call to DistillerBufferSetString.
@
text
@d361 8
a368 7
  if (DistillerBufferLength(&dout.metadata) > 0) {
    DistillerBufferClone(&hp->pxy_hdrs, &dout.metadata);
  } else {
    DistillerBufferClone(&hp->pxy_hdrs, &hp->svr_hdrs);
    delete_header(&hp->pxy_hdrs,  "content-type");
    delete_header(&hp->pxy_hdrs,  "content-length");
  }
d370 1
a370 1
  /*
d375 18
a392 6
  if (get_header_value(&hp->pxy_hdrs, "content-type", NULL,NULL,NULL) == NULL)
    insert_header(&hp->pxy_hdrs, "Content-type", dout.mimeType, 1);
  if (get_header_value(&hp->pxy_hdrs,"content-length",NULL,NULL,NULL) == NULL) {
    char __tmp[12];
    snprintf(__tmp, 11, "%lu", DistillerBufferLength(&dout.data));
    insert_header(&hp->pxy_hdrs, "Content-length", __tmp, 1);
d394 2
a395 1
  DistillerBufferClone(&hp->pxy_data, &dout.data);
a397 2
  DistillerBufferFree(&dout.data);
  DistillerBufferFree(&dout.metadata);
@


1.46
log
@changes to headers functions, ptm, and server_dispatch to maintain 2
invariants: (1) DistillerBuffer length field does NOT include
terminating null; (2) terminating null is always present for headers,
and is accoutned for by the maxLength field, so that maxLength >=
length+1.  Changed dispatch logic to allow for "X-static-route"
dispatcher worker.  Somewhat convoluted interaction with existing
X-Route mechanism, which i would remove entirely but for the fact that
it enables dynamic dispatch decisions after each pipestage.  New "guru"
argument i15 allows user to see all pipeline diagnostics that would
normally result in a bypass.
@
text
@d49 3
d115 1
a115 1
  lo->http_response = tmp;      /* log HTTP server response */
d141 3
@


1.45
log
@Logging now works!  yaaay.
@
text
@a7 3
#ifdef NEWFE
#include "dataflow.h"
#endif /* NEWFE */
d17 2
a18 2
static gm_Bool set_distiller_type(DistillerBuffer *mime_headers, const char *url,
                                  const char *user, C_DistillerType *dtype);
a48 3
#ifdef LOGGING
  struct loginfo *lo = hp->lo;
#endif
d112 1
a112 1
  lo->http_response = hp->svr_http_status;      /* log HTTP server response */
d136 2
a137 3
#ifdef LOGGING
  struct loginfo *lo = hp->lo;
#endif
a142 14
  /*
   *  Add a "Location:" header so distillers have a way to get the URL of
   *  this document, if they want. 
   */
  if (get_header_value(DistillerBufferData(&hp->svr_hdrs),
                       "location", NULL, NULL, NULL)
      == NULL) {
    insert_header(&hp->svr_hdrs, "Location", hp->url, 0);
  }

#ifdef NO_REDISPATCH
  din.data = hp->svr_data;
  DistillerBufferFreeMe(&din.data, gm_False);
#else  /* ! NO_REDISPATCH */
d145 1
a145 1
#endif /* NO_REDISPATCH */
d169 1
a169 1
    char_tmp = get_header_value(DistillerBufferData(&din.metadata),
d177 1
a177 1
    char_tmp = get_header_value(DistillerBufferData(&din.metadata),
a193 10
#ifdef NEWFE
    /*
     *  If this is a "child task" of a set of async requests, handle this case
     *  and then exit.
     */
    if (TASK_PARENT(tsk) && TASK_CHILD_INDEX(tsk)) {
      handle_child_retiring(tsk);
      goto DISPATCH_RETURN;
    }
#endif /* NEWFE */
d206 10
a227 7
      /* all is well, forward distilled version */
#ifdef LOGGING
      lo->size_after = DistillerBufferLength(&dout.data);
#endif /* LOGGING */
      retcode = distOk;
      break;

d230 7
a236 5
       *  The redispatch strategy is as follows.  Since the
       * DistillerInput pointer starts out being  a *clone* of the
       * server headers and data, it's always safe to free it.  THen move the
       *  DistillerOutput pointer (result of previous pipestage) to the
       *  DistillerInput pointer of this pipestage.  
d239 15
a253 7
      DistillerBufferFree(&din.metadata);
      DistillerBufferFree(&din.data);
      din.metadata = dout.metadata;
      din.data = dout.data;
      redispatch++;
      t->task_age++; /* "time to live" of this request */
      break;
d255 53
a307 8
#ifdef NEWFE
    case distAsyncBegin:
      /*
       *  Queue up N fetches for new stuff.
       */
      if (queue_async_requests(&dout, t) != gm_True) {
        snprintf(hp->errmsg, HTTP_ERRMSG_MAX, "[parent URL]");
        retcode = HTTP_ERR_PUSH_FAILED;
d309 10
a318 2
        /* Set this task's child field to avoid closing socket. */
        SET_TASK_CHILD_INDEX(t, 1);
d321 1
a321 2
#endif /* NEWFE */
      
d329 1
a329 1
/*      retcode = HTTP_ERR_DISTILLER; XXX - XXX - XXX - */
d356 1
a356 1
    hp->pxy_hdrs = dout.metadata;
d358 13
a370 5
    /*
     *  Replace the "Content-length" and "Content-type"
     *  headers with the correct info.  Leave other headers
     *  alone.
     */
a371 4
    DistillerBufferClone(&hp->pxy_hdrs, &hp->svr_hdrs);
    delete_header(&hp->pxy_hdrs, "content-type");
    delete_header(&hp->pxy_hdrs, "content-length");
    insert_header(&hp->pxy_hdrs, "Content-type", dout.mimeType, 0);
d373 1
a373 2
    insert_header(&hp->pxy_hdrs, "Content-length", __tmp, 0);
    /* and since we won't be using the dout.metadata buffer... */
d375 1
a375 2
  hp->pxy_data = dout.data;
    
d378 3
a417 1
  gm_Bool ok_to_retry = gm_True;
d428 3
d434 3
a436 3
    ok_to_retry = set_distiller_type(&dinp->metadata,
                                     (const char *)url, 
                                     whichuser, dtype);
d439 1
a439 1
  if ((mime = get_header_value(DistillerBufferData(&dinp->metadata),
a447 7
  if ((result == distDistillerNotFound)
      && ok_to_retry) {
    /* try with 'generic' system distiller, just in case */
    set_distiller_type_generic(&dinp->metadata, url, "transend", dtype);
    result =  Distill(dtype, al->arg, al->nargs, dinp, doutp);
  }

d473 1
a473 1
static gm_Bool
a478 1
  gm_Bool strict_routing = gm_False;
d481 1
a481 1
  if ((route = get_header_value(DistillerBufferData(mime_headers),
a511 1
    delete_header(mime_headers, "x-route");
a523 4
    }
    /* strict routing? */
    route_len = strlen(disttype)-1;
    if (disttype[route_len] == '!') {
a524 1
      strict_routing = gm_True;
d526 1
a526 1

a528 1
  return (strict_routing == gm_True ? gm_False : gm_True);
d542 1
a542 1
  mimetype = (char *)get_header_value(DistillerBufferData(mime_headers),
@


1.44
log
@fixed memory leaks in frontend resulting from distiller data and
metadata being cloned but never freed (dispatch.c)
@
text
@d52 3
d118 1
a118 1
  lo->http_response = tmp;      /* log HTTP server response */
d142 3
@


1.43
log
@Redispatch mechanism now works, although i suspect it leaks memory -
must investigate with purify
@
text
@d334 2
@


1.42
log
@fixed much badness reported by purify
@
text
@d154 1
d157 4
a163 1
   *  BUG::this should be done by a Clone() method.
d254 1
a254 1
       * server headers, it's always safe to free it.  THen move the
a332 5
  /*
   *  Free the input buffer iff at least one redispatch was done (so
   *  that din->metadata and din->data do NOT any longer point to
   *  hp->svr_hdrs/hp->svr_data).
   */
@


1.41
log
@reintegrated from branch fox-dev; bug remaining in dispatch.c which should always return a DistillerStatus and not an HTTP_Status
@
text
@d192 1
a192 1
      strncpy(content_type, char_tmp, MIN(content_type_len, MIME_TYPE_MAX));
d285 2
a286 1
      retcode = HTTP_ERR_DISTILLER;
d395 1
@


1.40
log
@Toplevel Makefile slimmed down.  lib/ subdir and corresponding install
targets added, to prep for binary dist.  client_lib now has
strerror()-style error reporting.  Fixed bug in dispatch.c that caused
prefs call for an aggregator to coredump (strcpy called on null ptr).
text/html distiller more streamlined and correctly "munges" user prefs
form items.  GetOptions moved from clib to TaccUtils.  perl_stub now
passes arguments named "s11", "i2", etc. instead of "11", "2", etc.
@
text
@d8 1
a8 2
#include "proxy.h"
#include "thr_cntl.h"
d10 1
d13 2
a14 1
#include "httpreq.h"
a15 2
#include "clib.h"               /* Harvest interface */
#include "utils.h"
d20 1
a20 1
static gm_Bool set_distiller_type(const char *mime_headers, const char *url,
d22 2
a23 1
static void set_distiller_type_generic(const char *mime_headers, const char *url,
d25 2
a26 2
static DistillerStatus  do_distillation(const clib_data *dat,
                                        struct http_headers *hp,
a29 3
static void DestroyBuffers(DistillerOutput *dout);
static void complete_bypass(int sock, clib_data *dat);

a34 1
 *  i: HTTP headers of original request
a35 1
 *  i/o: loginfo structure for logging this request
d40 2
a41 1
 *  RETURNS: nothing (exits through http_error_return if an error is reported)
d44 2
a45 3
void
proxy_dispatch(struct http_headers *hp, ArgumentList *al, struct loginfo *lo,
               task_t *tsk)
a46 4
  clib_response cl;
  clib_data dat;                /* data from cache or previous pipe stage */
  DistillerStatus status;       /* result of this pipe stage distillation */
  DistillerOutput dout;         /* output from this pipe stage distillation */
a47 3
  int server_response_ok; 
  int sock = (int)TASK_DATA(tsk); /* file descriptor for first stage */
  int tmp;
d49 6
a54 3
  
  inst_set_thread_state(thrindex, THR_CACHE);
  INST_TIMESTAMP(thrindex, m_cachestart);
a58 1
  dat.mime_headers = dat.data = NULL;
d72 1
a72 1
      Argument *arg;
d74 2
a75 11
      if ((arg =getArgumentFromIdInList(al, FRONT_ANONYMIZE))
          && (ARG_INT(*arg) > 0)) {
        cl = Clib_Fetch((char *)(hp->url), "", &dat);
      } else {
        cl = Clib_Fetch((char *)(hp->url), (char *) (hp->header), &dat);
      }
      if (cl != CLIB_OK) {
        char msg[100];
        snprintf(msg, 99, "Client library error %d: %s", (int)cl,
                 clib_strerror(cl));
        http_error_return(sock, hp->version, HTTP_ERR_CACHE, msg);
d80 1
d82 6
a87 3
      dat.mime_headers = (char *)MALLOC(strlen(hp->header_data)+1);
      strcpy(dat.mime_headers, hp->header_data);
      dat.data = NULL;
d91 2
a92 2
    HTTP_Status result;
    if ((result = do_post(hp, al, sock, tsk, &dat)) != HTTP_NO_ERR) {
a93 1
      http_error_return(sock, hp->version, result, "??");
d98 1
a98 1
  INST_TIMESTAMP(thrindex, m_cachedone);
d105 8
a112 3
  server_response_ok = (agg ||
                        (sscanf(dat.mime_headers, "%*s %d", &tmp) >= 1
                         && (tmp == 200)));
d114 1
d116 27
d144 8
a151 7
  if (! server_response_ok) {
    /* HTTP error: bypass result */
    inst_set_thread_state(thrindex, THR_WRITEBACK);
    proxy_debug_4(DBG_HTTP, "Bypassing non-OK status %d for %s", (char *)tmp,
                  hp->url);
    complete_bypass(sock, &dat);
    goto DISPATCH_RETURN;       /* game over */
d154 2
d157 3
a159 1
   *  Server response indicates success
d161 3
a163 2

  dat.mime_headers = REALLOC(dat.mime_headers, PERF_HTTP_TOTAL_HEADERLEN);
a164 1
    C_DistillerType dtype;
d166 1
a166 1
    char content_type[MIME_TYPE_MAX];
a169 1
    UINT32 thresh;
d176 1
d180 3
a182 2
    char_tmp = get_header_value(dat.mime_headers, "content-length",
                                    &content_type_len, NULL, NULL);
d187 4
a190 7

    /*
     *  Is this content small enough to just bypass?  (Except for text/html;
     *  we always try to distill that, to do tag munging, etc.)
     */
    char_tmp = get_header_value(dat.mime_headers, "content-type",
                                    &content_type_len, NULL, NULL);
d192 2
a193 1
      strncpy(content_type, char_tmp, MIME_TYPE_MAX-1);
d201 1
d205 1
a205 29
    if ((arg = getArgumentFromIdInList(al, FRONT_MTU)) != NULL) {
      thresh = ARG_INT(*arg);
    } else {
      thresh = PERF_FRONT_MTU;
    }

    /*
     *  If the content-type is unknown, OR anything other than text/html,
     *  AND content-length is <= the threshold value, then bypass.
     *  (text/html is never bypassed.)
     */
    if ((agg == 0 && content_type == NULL)
        || ((strncasecmp(content_type, "text/html", content_type_len) != 0)
            && dat.data_size <= thresh)) {
      /* small enough to bypass */
      complete_bypass(sock, &dat);
      goto DISPATCH_RETURN;
    }

    /* should we bypass the url because the FRONT_NO_DISTILL arg is set 
     * EXCEPTION: Set-prefs form ALWAYS gets "distilled" so the correct arg
     * values can be filled in with this user's current prefs
     */
    if ((arg = getArgumentFromIdInList(al, FRONT_NO_DISTILL))
        && ARG_INT(*arg)
        && strcasecmp(fe_get_prefs_url, hp->url) != 0) {
      complete_bypass(sock, &dat);
      goto DISPATCH_RETURN;
    }      
d214 1
a214 10

    /*
     *  Fill in a "Location:" header so distillers have a way to get the URL of
     *  this document, if they want. 
     */
    if (get_header_value(dat.mime_headers, "location", NULL, NULL, NULL)
        == NULL) {
      insert_header(dat.mime_headers, "Location", hp->url, 0);
    }

d224 3
a226 7
    num_tries_left = ((arg = getArgumentFromIdInList(al, FRONT_RETRY_DISTILL))
                      ? ARG_INT(*arg)
                      : PERF_HTTP_RETRY_DISTILL);
    INST_TIMESTAMP(thrindex, m_distillstart);
    dat.mime_size = strlen(dat.mime_headers);
    dat.mime_headers[dat.mime_size] = '\0';

d228 2
a229 3
      inst_set_thread_state(thrindex, THR_DISTILLER);
      status = do_distillation(&dat, hp, &dout, &dtype, al);
      inst_set_thread_state(thrindex, THR_WRITEBACK);
d233 1
d235 1
a238 1

d240 4
a243 18
      lo->size_after = DataLength(&dout);
      INST_TIMESTAMP(thrindex, m_wbstart);
      if (MetadataLength(&dout) > 0)
        correct_write(sock,(char*)MetadataPtr(&dout),(int)MetadataLength(&dout));
      else
        correct_write(sock, hp->header_data, -1);
      correct_write(sock, (char*)DataPtr(&dout), (int)DataLength(&dout));
      INST_TIMESTAMP(thrindex, m_wbdone);
      break;

    case distDistillerNotFound:
    case distLaunchTimeout:
    case distBadInput:
    case distConnectionBroken:

      /* forward original if distiller for this type not found, connection
         repeatedly broken, or couldn't be launched */
      complete_bypass(sock, &dat);
d248 5
a252 2
       *  For simplicity, but obviously not performance, just free the old
       *  buffers and allocate new ones for the next pass thru the loop.
d254 7
a260 21
      {
        int len;
        Clib_Free(&dat);
        len = MetadataLength(&dout);
        dat.mime_headers = (char *)MALLOC(PERF_HTTP_TOTAL_HEADERLEN);
        memcpy(dat.mime_headers, MetadataPtr(&dout), len);
        dat.mime_headers[len] = '\0';
        dat.mime_size = MetadataLength(&dout);

        len = DataLength(&dout);
        dat.data = (char *)MALLOC(1+len);
        memcpy(dat.data, DataPtr(&dout), len);
        dat.data[len] = '\0';
        dat.data_size = DataLength(&dout);
        /*
         *  Because we've copied the dout pointers to the dat structure, 
         *  we can free the dout buffer now.
         */
        DestroyBuffers(&dout);
        tsk->task_age++; /* "time to live" of this request */
      }
d263 1
d268 3
a270 3
      if (queue_async_requests(&dout, tsk) != gm_True) {
        http_error_return(sock, hp->version, HTTP_ERR_PUSH_FAILED,
                          "[parent URL]");
d273 1
a273 1
        SET_TASK_CHILD_INDEX(tsk, 1);
d276 2
a277 1

a278 1
    
d283 3
a285 2
      http_error_return(sock, hp->version, HTTP_ERR_DISTILLER,
                        (char *)FE_getDistillerStatusString(status));
d294 1
a294 1
    INST_SET_SIZE(thrindex, dat.data_size);
d297 1
a297 1
            &&  tsk->task_age <= PERF_REQUEST_TTL);  /* do */
d300 32
a331 2
   *  See if output buffers need to be freed.
   *  BUG::this should really be a function call into ptm stub?
a332 2
  
  DestroyBuffers(&dout);
d334 2
a335 17
DISPATCH_RETURN:
  /* must do Clib_Put here??? */
  Clib_Free(&dat);
}

/*
 *  Do a complete bypass of data returned from the client lib (i.e. from
 *  the cache).  This may be done because distillation failed, because
 *  no such distiller exists, or because the content was deemed too small
 *  to be worth distilling....or perhaps some other reason.
 */

static void
complete_bypass(int sock, clib_data *dat)
{
  (void)correct_write(sock, dat->mime_headers, dat->mime_size);
  (void)correct_write(sock, dat->data, dat->data_size);
d345 6
a350 6
 *    i*: content/headers structure returned from Client Lib
 *    i*: HTTP headers structure from server (parsed version of
 *  content/headers structure)
 *    i*: distiller type structure
 *    i*: argument list for distiller
 *    o*: flag whether distillation output buffer should be freed or not
d353 1
d356 1
a356 1
 *      in hp->header_data; distilled content is left in dout structure.
d358 1
a358 1
 *      hp->header_data is a realloc'able structure.
d361 3
a363 2
do_distillation(const clib_data *dat, struct http_headers *hp,
                DistillerOutput *doutp, C_DistillerType *dtype,
a365 1
  DistillerInput din;
d382 1
a382 1
  if (strcasecmp(hp->url, fe_set_prefs_url) == 0) {
d385 2
a386 2
    ok_to_retry = set_distiller_type((const char *)dat->mime_headers,
                                     (const char *)hp->url, 
d390 2
a391 6
  SetData(&din, dat->data);
  SetDataLength(&din, dat->data_size);
  SetMetadata(&din, dat->mime_headers);
  SetMetadataLength(&din, dat->mime_size);

  if ((mime = get_header_value(dat->mime_headers, "content-type",
d393 3
a395 4
    strncpy(din.mimeType, mime, mime_len);
    din.mimeType[mime_len] = '\0';
  }  else {
    strcpy(din.mimeType, "text/html");
d397 2
a398 3
    
  if (((result = Distill(dtype, al->arg, al->nargs, &din, doutp))
       == distDistillerNotFound)
d401 2
a402 4
    set_distiller_type_generic((const char *)dat->mime_headers,
                               (const char *)hp->url, 
                               "transend", dtype);
    result =  Distill(dtype, al->arg, al->nargs, &din, doutp);
a404 40
  if (result == distOk || result == distRedispatch) {
    if (MetadataLength(doutp) > 0) {
      /*
       *  Distiller's returned headers are authoritative
       */
      strncpy(hp->header_data, MetadataPtr(doutp), PERF_HTTP_TOTAL_HEADERLEN-1);
    } else if (dat->mime_size > PERF_HTTP_TOTAL_HEADERLEN) {
      /*
       *  Generate minimal headers
       */
      sprintf(hp->header_data,
              "HTTP/1.0 200 OK\r\nContent-type: %s\r\n"
              "Content-length: %lu\r\n\r\n",
              doutp->mimeType, DataLength(doutp));
    } else {
      /*
       *  Replace the "Content-length" and "Content-type"
       *  headers with the correct info.  Leave other headers
       *  alone.
       */
      char __tmp[8];
      int status;
      /* if this was an aggregation, the MIME headers in dat don't correspond
         to any real page, so we must insert a status line ourselves.
         To be safe, we'll prepend the status line if it doesn't appear to be
         present... HACK HACK HACK
         */
      if (sscanf(dat->mime_headers, "HTTP%*s %d", &status) < 1) {
        sprintf(hp->header_data, "HTTP/1.0 200 OK\r\n");
        strcat(hp->header_data, dat->mime_headers);
      } else {
        strcpy(hp->header_data, dat->mime_headers);
      }
      delete_header(hp->header_data, "content-type");
      delete_header(hp->header_data, "content-length");
      insert_header(hp->header_data, "Content-type", doutp->mimeType, 1);
      sprintf(__tmp, "%lu", DataLength(doutp));
      insert_header(hp->header_data, "Content-length", __tmp, 1);
    }
  }
d420 2
a421 2
 *     distiller for this MIME type, *unless* the routing header was
 *     X-Route-Strict. 
d431 2
a432 2
set_distiller_type(const char *mime_headers, const char *url, const char *user,
                   C_DistillerType *dtype)
d439 2
a440 1
  if ((route = get_header_value(mime_headers,"x-route",&route_len,NULL,NULL))
d470 1
a470 1
    delete_header((char *)mime_headers, "x-route");
d478 1
a478 1
      insert_header((char *)mime_headers, "x-route", semicolon+1, 0);
d497 1
a497 1
set_distiller_type_generic(const char *mime_headers, const char *url,
d507 2
a508 1
  mimetype = (char *)get_header_value(mime_headers, "content-type",
a524 20

Argument *
getArgumentFromId(Argument *args, int numberOfArgs, UINT32 id)
{
  Argument *ptr;
  if (args==NULL) return NULL;
  for(ptr=args; ptr < args+numberOfArgs; ptr++) {
    if (ARG_ID(*ptr)==id) return ptr;
  }
  return NULL;
}

static void
DestroyBuffers(DistillerOutput *dout)
{
  if (dout->data.freeMe == gm_True)
    DistillerFree(dout->data.data);
  if (dout->metadata.freeMe == gm_True)
    DistillerFree(dout->metadata.data);
}
@


1.40.4.1
log
@*** empty log message ***
@
text
@d8 2
a9 1
#ifdef NEWFE
a10 1
#endif /* NEWFE */
d13 3
a16 2
#include "frontend.h"
#include "ARGS.h"
d25 2
a26 1
static DistillerStatus  do_distillation(Request *hp,
d30 1
d48 3
a50 2
HTTP_Status
proxy_dispatch(ArgumentList *al, task_t *tsk)
d52 2
d58 1
d61 3
a63 6
  HTTP_Status ret_code = HTTP_NO_ERR;
  Request *hp = (Request *)TASK_DATA(t);
  int sock = hp->cli_fd; /* file descriptor for first stage */

  INST_set_thread_state(thrindex, THR_CACHE);
  INST_timestamp(thrindex, m_cachestart);
d68 1
d82 1
a82 1
      /* not an aggregator call */
d84 11
a94 2
      retcode = do_get(hp, al);
      if (retcode != HTTP_NO_ERR) {
d100 3
a102 6
      /* don't clone the client headers - just point to them. */
      DistillerBufferSetStatic(&hp->svr_hdrs,
                               DistillerBufferData(&hp->cli_hdrs),
                               DistillerBufferLength(&hp->cli_hdrs));
      /* since we're pointing to a copy, don't try to free */
      DistillerBufferFreeMe(&hp->svr_hdrs, gm_False);
d106 2
a107 2
    retcode = do_post(hp, &al);
    if (retcode != HTTP_NO_ERR) {
d109 1
d114 1
a114 1
  INST_timestamp(thrindex, m_cachedone);
a124 1
#ifdef LOGGING
d126 1
a126 2
#endif /* LOGGING */
  
d129 1
a129 1
    INST_set_thread_state(thrindex, THR_WRITEBACK);
a159 1
#ifdef LOGGING
d164 1
a164 1
#endif /* LOGGING */
a211 1
#ifdef NEWFE
d220 1
a220 1
#endif /* NEWFE */
d242 1
a242 1
    INST_timestamp(thrindex, m_distillstart);
d247 1
a247 1
      INST_set_thread_state(thrindex, THR_DISTILLER);
d249 1
a249 1
      INST_set_thread_state(thrindex, THR_WRITEBACK);
a252 1
#ifdef LOGGING
a253 1
#endif /* LOGGING */
a258 1
#ifdef LOGGING
d260 1
a260 6
#endif /* LOGGING */
      retcode = HTTP_NO_ERR;

      @@@@@@@@@@@@@@@@  can't return without freeing dout buffers!  @@@@@@@@

      INST_timestamp(thrindex, m_wbstart);
d266 1
a266 1
      INST_timestamp(thrindex, m_wbdone);
a306 1
#ifdef NEWFE
d312 2
a313 2
        snprintf(hp->errmsg, HTTP_ERRMSG_MAX, "[parent URL]");
        retcode = HTTP_ERR_PUSH_FAILED;
d319 1
a319 2
#endif /* NEWFE */
      
d326 2
a327 3
      snprintf(hp->errmsg, HTTP_ERRMSG_MAX,
               (char *)FE_getDistillerStatusString(status));
      retcode = HTTP_ERR_DISTILLER;
d336 1
a336 1
    INST_set_size(thrindex, dat.data_size);
a350 1
  return (ret_code);
d389 1
a389 1
do_distillation(const clib_data *dat, Request *hp,
d599 20
@


1.40.4.2
log
@*** empty log message ***
@
text
@d46 1
a46 1
server_dispatch(ArgumentList *al, task_t *tsk)
d48 2
d51 2
d56 1
d109 3
a111 8
  nfound = sscanf(DistillerBufferGetData(hp->svr_hdrs), "%*s %lu",
                  &hp->svr_http_status);
  if (nfound < 1) {             /* no status found */
    retcode = HTTP_GET_FAILED;
    hp->svr_http_status = 0;
  } else {
    retcode = HTTP_NO_ERR;
  }
d116 9
d127 1
a127 3
   *  Note that HTTP_NO_ERR means "transaction to server succeeded" (ie
   *  at the transport level).  it does NOT necessarily mean that the
   *  HTTP *operation* succeeded -- the HTTP status code tells that.
d130 1
a130 11
  return retcode;
}

DistillerStatus
proxy_dispatch(ArgumentList *al, task_t *t)
{
  DistillerStatus status;       /* result of this pipe stage distillation */
  DistillerOutput dout;         /* output from this pipe stage distillation */
  Request *hp = (Request *)TASK_DATA(t);
  C_DistillerType dtype;

d132 1
d148 1
a148 1
    char_tmp = get_header_value(&hp->svr_hdrs, "content-length",
d160 1
a160 1
    char_tmp = get_header_value(&hp->svr_hdrs, "content-type",
a170 1
    /* chop any trailing spaces. */
a173 1
    /* determine the threshold for bypassing */
d214 1
a214 1
     *  Add a "Location:" header so distillers have a way to get the URL of
d217 1
a217 1
    if (get_header_value(&hp->svr_hdrs, "location", NULL, NULL, NULL)
d219 1
a219 1
      insert_header(&hp->svr_hdrs, "Location", hp->url, 0);
d235 1
a235 1
    dat.mime_size = strlen(&hp->svr_hdrs);
@


1.40.4.3
log
@*** empty log message ***
@
text
@d20 1
a20 1
static gm_Bool set_distiller_type(DistillerBuffer *mime_headers, const char *url,
d22 1
a22 2
static void set_distiller_type_generic(DistillerBuffer *mime_headers,
                                       const char *url,
d24 1
a24 2
static DistillerStatus  do_distillation(const char *url,
                                        DistillerInput *din,
d28 2
d35 1
d37 1
d42 1
a42 2
 *  RETURNS: HTTP_Status code corresponding to server's/cache's return
 *  status for the request
d50 2
a51 3
  int nfound;
  HTTP_Status retcode = HTTP_NO_ERR;
  Request *hp = (Request *)TASK_DATA(tsk);
d90 1
a90 1
    retcode = do_post(hp, al);
d104 1
a104 1
  nfound = sscanf(DistillerBufferData(&hp->svr_hdrs), "%*s %lu",
d107 1
a107 1
    retcode = HTTP_ERR_GET_FAILED;
a122 1
DISPATCH_RETURN:
d130 1
a130 2
  DistillerInput din;
  DistillerOutput dout;
a132 12
  int thrindex = TASK_THRINDEX(t);
  DistillerStatus retcode;
  int redispatch = 0;

  /*
   *  Initialize for *first* pipe stage.
   */

  din.metadata = hp->svr_hdrs;
  din.data = hp->svr_data;
  DistillerBufferFreeMe(&din.metadata, gm_False);
  DistillerBufferFreeMe(&din.data, gm_False);
d140 1
a146 1
#ifdef LOGGING
d150 3
a152 3
    char_tmp = get_header_value(DistillerBufferData(&din.metadata),
                                "content-length",
                                &content_type_len, NULL, NULL);
d158 6
a163 3
    char_tmp = get_header_value(DistillerBufferData(&din.metadata),
                                "content-type",
                                &content_type_len, NULL, NULL);
d177 30
d221 1
a221 2
    if (get_header_value(DistillerBufferData(&din.metadata),
                         "location", NULL, NULL, NULL)
d223 1
a223 1
      insert_header(&din.metadata, "Location", hp->url, 0);
d235 3
a237 2
    arg = getArgumentFromIdInList(al, FRONT_RETRY_DISTILL);
    num_tries_left = (arg ? ARG_INT(*arg) : PERF_HTTP_RETRY_DISTILL);
d239 3
d244 2
a245 1
      status = do_distillation(hp->url, &din, &dout, &dtype, al);
d258 1
a258 1
      lo->size_after = DistillerBufferLength(&dout.data);
d260 21
a280 1
      retcode = distOk;
d285 2
a286 12
       *  The redispatch strategy is as follows.  If this is the *first*
       * redispatch, then the DistillerInput pointer points to the
       * original server headers; so don't free it.  Otherwise, *do*
       * free the DistillerInput pointer since no one will ever use that
       * data again.  Then move the
       *  DistillerOutput pointer (result of previous pipestage) to the
       *  DistillerInput pointer of this pipestage.  When this function
       *  exits, the DistillerInput pointer will be freed if it has been
       *  switched at least once.  (If it was switched zero times, it
       *  means the DistillerInput pointer points to the same thing as
       *  the hp->svr_hdrs/hp->svr_data pointers, i.e. the original
       *  server content, in which case we should NOT free them.)
d288 20
a307 4

      if (redispatch) {
        DistillerBufferFree(&din.metadata);
        DistillerBufferFree(&din.data);
a308 4
      din.metadata = dout.metadata;
      din.data = dout.data;
      redispatch++;
      t->task_age++; /* "time to live" of this request */
d316 1
a316 1
      if (queue_async_requests(&dout, t) != gm_True) {
d321 1
a321 1
        SET_TASK_CHILD_INDEX(t, 1);
d327 1
d343 1
a343 1
    INST_set_size(thrindex, DistillerBufferLength(&dout.data));
d346 1
a346 1
            &&  t->task_age <= PERF_REQUEST_TTL);  /* do */
d349 2
a350 36
   *  "Copy" final output buffer to hp->pxy_hdrs/hp->pxy_data.  (Really
   *  we just copy the pointers, since the pxy_hdrs/pxy_data buffers
   *  will be freed by the caller.)
   *
   *  First generate headers to return to client.  If last-stage
   *  distiller returned
   *  some headers, use them; otherwise, replace the "content-length"
   *  and "content-type" fields of the ORIGINAL server headers with
   *  new values deduced from the distiller data.
   */
  if (DistillerBufferLength(&dout.metadata) > 0) {
    hp->pxy_hdrs = dout.metadata;
  } else {
    /*
     *  Replace the "Content-length" and "Content-type"
     *  headers with the correct info.  Leave other headers
     *  alone.
     */
    char __tmp[12];
    (void)DistillerBufferAlloc(&hp->pxy_hdrs,
                               DistillerBufferLength(&hp->svr_hdrs));
    memcpy(&hp->pxy_hdrs.data, DistillerBufferData(&hp->svr_hdrs),
           DistillerBufferLength(&hp->svr_hdrs));
    delete_header(&hp->pxy_hdrs, "content-type");
    delete_header(&hp->pxy_hdrs, "content-length");
    insert_header(&hp->pxy_hdrs, "Content-type", dout.mimeType, 1);
    snprintf(__tmp, 11, "%lu", DistillerBufferLength(&dout.data));
    insert_header(&hp->pxy_hdrs, "Content-length", __tmp, 1);
    /* and since we won't be using the dout.metadata buffer... */
    DistillerBufferFree(&dout.metadata);
  }
  hp->pxy_data = dout.data;
  /*
   *  Free the input buffer iff at least one redispatch was done (so
   *  that din->metadata and din->data do NOT any longer point to
   *  hp->svr_hdrs/hp->svr_data).
d352 2
d355 18
a372 2
  /* BUG::must do Clib_Put here??? */
  return (retcode);
d382 6
a387 6
 *    i:  URL (BUG::shouldn't be needed - it's currently used to
 *      determine distiller type for "aggregator" virtual-site URLs )
 *    i: input to distiller (from previous "pipestage" or from server)
 *    o: output from distiller
 *    o: distiller type descriptor
 *    i: argument list for distiller
a389 1
 *  REENTRANT: yes
d392 1
a392 1
 *      in DistillerOutput structure
d394 1
a394 1
 *    None
d397 2
a398 3
do_distillation(const char *url,
                DistillerInput *dinp, DistillerOutput *doutp,
                C_DistillerType *dtype,
d401 1
d418 1
a418 1
  if (strcasecmp(url, fe_set_prefs_url) == 0) {
d421 2
a422 2
    ok_to_retry = set_distiller_type(&dinp->metadata,
                                     (const char *)url, 
d426 6
a431 2
  if ((mime = get_header_value(DistillerBufferData(&dinp->metadata),
                               "content-type",
d433 4
a436 4
    strncpy(dinp->mimeType, mime, (mime_len < MAX_MIMETYPE-1
                                 ? mime_len : MAX_MIMETYPE-1));
  } else {
    strcpy(dinp->mimeType, "text/html");
d439 2
a440 2
  result = Distill(dtype, al->arg, al->nargs, dinp, doutp);
  if ((result == distDistillerNotFound)
d443 4
a446 2
    set_distiller_type_generic(&dinp->metadata, url, "transend", dtype);
    result =  Distill(dtype, al->arg, al->nargs, dinp, doutp);
d450 38
d515 2
a516 2
set_distiller_type(DistillerBuffer *mime_headers, const char *url,
                   const char *user, C_DistillerType *dtype)
d523 1
a523 2
  if ((route = get_header_value(DistillerBufferData(mime_headers),
                                "x-route",&route_len,NULL,NULL))
d553 1
a553 1
    delete_header(mime_headers, "x-route");
d561 1
a561 1
      insert_header(mime_headers, "x-route", semicolon+1, 0);
d580 1
a580 1
set_distiller_type_generic(DistillerBuffer *mime_headers, const char *url,
d590 1
a590 2
  mimetype = (char *)get_header_value(DistillerBufferData(mime_headers),
                                      "content-type",
@


1.40.4.4
log
@*** empty log message ***
@
text
@d150 1
a150 1
    char content_type[MIME_TYPE_MAX+1];
d176 1
a176 2
      strncpy(content_type, char_tmp, MIN(content_type_len, MIME_TYPE_MAX));
      content_type[MIN(content_type_len,MIME_TYPE_MAX)] = '\0';
@


1.40.4.5
log
@a huge amount of frontend reengineering, plus added a Clone() method to
the DistillerBuffer.  basic operation of frontend seems stable.
things that haven't been tested yet:
- POST
- cache cut through behavior
- client timeout doesn't seem to work (never times out??)
- redispatch and similar support for aggregators
and some things still to be implemented:
- support for listening/dispatching on multiple ports
- documentation of what all the files do (and rename the http-specific
sourcefiles)
- eliminate redundant .h inclusions from various sourcefiles
- 'makedepend' for the Makefile.in
@
text
@a79 1
      abort();
d120 1
a120 1
   *  HTTP *operation* (eg GET) succeeded -- the HTTP status code tells that.
d143 1
a143 10
  /*
   *  Add a "Location:" header so distillers have a way to get the URL of
   *  this document, if they want. 
   */
  if (get_header_value(DistillerBufferData(&hp->svr_hdrs),
                       "location", NULL, NULL, NULL)
      == NULL) {
    insert_header(&hp->svr_hdrs, "Location", hp->url, 0);
  }

d145 1
d147 1
a147 8
  /*
   *  Make a **copy** of the server headers, because they may get
   *  overwritten when preparing headers to send to a distiller.
   *  BUG::this should be done by a Clone() method.
   */
  DistillerBufferClone(&din.metadata, &hp->svr_hdrs);
  DistillerBufferFreeMe(&din.metadata, gm_True);
  
d200 10
d233 1
d243 5
a247 3
       *  The redispatch strategy is as follows.  Since the
       * DistillerInput pointer starts out being  a *clone* of the
       * server headers, it's always safe to free it.  THen move the
d249 6
a254 1
       *  DistillerInput pointer of this pipestage.  
d257 4
a260 2
      DistillerBufferFree(&din.metadata);
      DistillerBufferFree(&din.data);
d323 4
a326 1
    DistillerBufferClone(&hp->pxy_hdrs, &hp->svr_hdrs);
d329 1
a329 1
    insert_header(&hp->pxy_hdrs, "Content-type", dout.mimeType, 0);
d331 1
a331 1
    insert_header(&hp->pxy_hdrs, "Content-length", __tmp, 0);
d333 1
d401 2
a402 1
    strncpy(dinp->mimeType, mime, MIN(mime_len,MAX_MIMETYPE-1));
d406 1
d415 2
d432 2
a433 2
 *     distiller for this MIME type, *unless* the routing header 
 *     indicated strict routing.
@


1.39
log
@fixed TACCutils bug that sometimes caused next_entity to enter infinite
loop.  beginning frontend cleanup to separate service-specific stuff
from core stuff.  ifdef'd out the instrumentation code in
httpsupport.c:parse_status_and_headers, which was likely causing
segfaults.  removed sbrk() monitoring from thr_mon.c because it was
bogus.  tested the Bypass feature for big pages (it works) and set
bypass threshold to about 1.5MB in clib.h.  monitor window is now
resizable though not all the fields resize intelligently.
@
text
@d92 2
a93 1
        sprintf(msg, "Client library error %d", (int)cl);
d143 1
a143 1
    char *char_tmp;
d171 6
a176 1
    strncpy(content_type, char_tmp, MIME_TYPE_MAX-1);
d178 4
a181 4
    if (char_tmp = strchr((const char *)content_type, ';')) 
      *char_tmp = '\0';
    if (char_tmp = strchr((const char *)content_type, ' ')) 
      *char_tmp = '\0';
@


1.38
log
@makefile fixes to have lib/ subdir now work on both.  anonymization added to frontend.  still a lurking stack-stomping bug in httpsupport.c
@
text
@d142 2
a143 1
    const char *content_type;
d157 1
a157 1
    content_type = get_header_value(dat.mime_headers, "content-length",
d159 2
a160 2
    if (content_type != NULL)
      lo->size_before = strtoul(content_type, NULL, 0);
d168 1
a168 1
    content_type = get_header_value(dat.mime_headers, "content-type",
d170 7
@


1.37
log
@debugging/monitoring function interface in frontend cleaned up.  change to xs/Makefile.PL.in to avoid spurious double initialization of stuff in libdist.a when clib.so was dynamically loaded.
@
text
@d82 1
d84 7
a90 2
      if ((cl = Clib_Fetch((char *)(hp->url), (char *) (hp->header), 
                           &dat)) != CLIB_OK) {
@


1.36
log
@various changes to makefiles to support auto-installation into sbin and bin directories.  perl HTML distiller no longer inserts UI in pages with frames.  PREFS_URL and similar strings are now static char* instead of #defines, but still need them to be initialized in PTM stub so distillers can get at them.  "run" targets are better now, they run stuff from the sbin and bin directories.
@
text
@d153 1
a153 1
      lo->size_before = strtoul(content_type, NULL, NULL);
@


1.35
log
@merged changes from head of transend-beta branch
@
text
@d81 1
a81 1
    if (strncasecmp(hp->url, AGG_STRING, strlen(AGG_STRING)) != 0) {
d188 1
a188 1
        && strcasecmp(GET_PREFS_URL, hp->url) != 0) {
d390 1
a390 1
  if (strcasecmp(hp->url, SET_PREFS_URL) == 0) {
d500 1
a500 1
    if (strncasecmp(url, AGG_STRING, strlen(AGG_STRING)) == 0) {
d504 1
a504 1
      for (i=0, j=strlen(AGG_STRING);
d508 1
a508 1
      strncpy(disttype_tmp, url+strlen(AGG_STRING), i);
@


1.34
log
@support for returning correct headers when aggregators called
@
text
@d188 1
a188 1
        && strcasecmp(SET_PREFS_URL, hp->url) != 0) {
@


1.33
log
@changes for dataflow stuff, chaining stuff, aggregators
@
text
@d60 2
a61 1

d73 23
a95 6
    if ((cl = Clib_Fetch((char *)(hp->url), (char *) (hp->header), 
		       &dat)) != CLIB_OK) {
      char msg[100];
      sprintf(msg, "Client library error %d", (int)cl);
      http_error_return(sock, hp->version, HTTP_ERR_CACHE, msg);
      goto DISPATCH_RETURN;
d114 3
a116 2
  server_response_ok = (sscanf(dat.mime_headers, "%*s %d", &tmp) >= 1
                        && (tmp == 200));
d174 2
a175 2
    if ((content_type == NULL)
        || ((strncmp(content_type, "text/html", content_type_len) != 0)
d442 12
a453 1
      strcpy(hp->header_data, dat->mime_headers);
d494 1
a494 1
  
d498 1
a498 1
    set_distiller_type_generic(mime_headers, url, user, dtype);
d500 16
@


1.32
log
@frontend and ptm changes for new distiller api
@
text
@d10 1
d21 4
a24 2
static void set_distiller_type(const char *mime_headers, const char *url,
                               C_DistillerType *dtype);
d29 1
a29 2
                                        ArgumentList *al,
                                        gm_Bool *freeOutputBuf);
a55 1
  gm_Bool freeOutput;           /* need to free output buf from this stage? */
a64 5
   *  If this is a redispatch of a request that already entered the system,
   *  DON'T attempt to read from a socket--instead, verify that the requests'
   *  "time to live" hasn't expired, and if all is well, use the 
   */
  /*
d113 2
a125 1
    freeOutput = gm_False;
d173 17
d204 3
d209 1
a209 1
      status = do_distillation(&dat, hp, &dout, &dtype, al, &freeOutput);
d220 1
a220 1
      lo->size_after = dout.data.length;
d222 5
a226 2
      correct_write(sock, hp->header_data, -1);
      correct_write(sock, (char *)(dout.data.data), (int)(dout.data.length));
d242 29
a270 5
       *  Note, it's necessary to free dat here, otherwise the storage it
       *  points to will become 'dangling' and will never be reclaimed.  Freeing
       *  here is ok, because status==distRedispatch means we'll be going thru
       *  the loop again.  Freeing in any other case clause is NOT ok because of
       *  the Clib_Free() call following DISPATCH_RETURN below.
d272 7
a278 6
      Clib_Free(&dat);
      dat.mime_headers = dout.metadata.data;
      dat.mime_size = dout.metadata.length;
      dat.data = dout.data.data;
      dat.data_size = dout.data.length;
      tsk->task_age++; /* "time to live" of this request */
d280 1
a280 1
      
d310 1
a310 1
  
a311 1

d352 1
a352 1
                ArgumentList *al, gm_Bool *freeOutputBuf)
d356 5
a365 2
  set_distiller_type((const char *)dat->mime_headers, (const char *)hp->url, 
                     dtype);
d367 24
a390 7
  proxy_debug_4(DBG_PTM, "Distilling %s type %s", hp->url,
                GET_DISTILLER_TYPE(*dtype) );
  din.data.data = (void *)(dat->data);
  din.data.length = dat->data_size;
  din.metadata.data = (void *)(dat->mime_headers);
  din.metadata.length = dat->mime_size;
  strcpy(din.mimeType, GET_DISTILLER_TYPE(*dtype));
d392 20
a411 10
  result = Distill(dtype, al->arg, al->nargs,
                   &din, doutp);
    
  if (result == distOk) {
    /*
     *  parse server headers.  Remove the "Content-length" and "Content-type"
     *  headers and replace them with the correct info.  Leave other headers
     *  alone. 
     */
    if (dat->mime_size > PERF_HTTP_TOTAL_HEADERLEN) {
d413 3
a415 2
              "HTTP/1.0 200 OK\r\nContent-type: %s\r\nContent-length: %lu\r\n\r\n",
              doutp->mimeType, doutp->data.length);
d417 5
d427 1
a427 1
      sprintf(__tmp, "%lu", doutp->data.length);
d434 14
a447 7
 *  Set the distiller type based on the HTTP MIME headers and/or the
 *  URL.
 *  For now,
 *  extract the Content-Type; if it can't be found, assume text/html.
 *  Set the distiller type according to the found MIME type; for now,
 *  just set the distiller type equal to the MIME type.  In the future
 *  this will somehow be used to implement "distiller composition".
a448 5
 *  ARGS:
 *     i: the returned server headers, verbatim, including the leading
 *  HTTP status line and the trailing blank line
 *     o*: pointer to C_DistillerType structure to be filled in to
 *  indicate what type of distiller will be required
d451 2
a452 1
 *  RETURNS: nothing
d456 49
d506 2
a507 2
set_distiller_type(const char *mime_headers, const char *url,
                   C_DistillerType *dtype)
d509 1
a509 1
  char *mimetype = NULL;
d511 7
a517 3
  
  mimetype = (char *)get_header_value(mime_headers, "content-type", &mimetype_len,
                              NULL, NULL);
d519 4
a522 3
    proxy_debug_3(DBG_MIME, "No Content-type header for %s, assuming text/html",
                  url);
    SET_DISTILLER_TYPE(*dtype, "text/html");
d524 5
a528 5
    /* ugh - temporarily save a char so we can overwrite it with '\0' EOS */
    char save = mimetype[mimetype_len];
    mimetype[mimetype_len] = '\0';
    SET_DISTILLER_TYPE(*dtype, (const char *)mimetype);
    mimetype[mimetype_len] = save;
d530 1
d532 1
@


1.32.2.1
log
@L0 works; sending and registering encrypted URLs works
@
text
@a45 1
#ifdef FRONTEND_LOGGING
a48 5
#else
void
proxy_dispatch(struct http_headers *hp, ArgumentList *al,
               task_t *tsk)
#endif
d58 1
a58 10
  int tmp = 500;
  static const char *tazerr =
"HTTP/1.0 404 Not found or other error\n"
"Content-type: text/html\n"
"\n"
"<HTML><HEAD><TITLE>404 Not Found or other error</TITLE></HEAD>\n"
"<BODY><H1>404 Not Found or other error</H1>\n"
"<P>The remote web server returned an error.  More specific information "
"is not available.\n"
"</BODY></HTML>\n" ;
a102 1
#ifdef FRONTEND_LOGGING
a103 1
#endif
d110 1
a110 5
    if (hp->secret) {
	correct_write(sock, tazerr, -1);
    } else {
	complete_bypass(sock, &dat);
    }
a135 1
#ifdef FRONTEND_LOGGING
d137 1
a137 1
      lo->size_before = strtoul(content_type, NULL, 0);
a139 1
#endif
a196 1
#ifdef FRONTEND_LOGGING
a197 1
#endif
a202 1
#ifdef FRONTEND_LOGGING
a203 1
#endif
@


1.32.2.2
log
@Type 1-style rewebber
@
text
@d182 1
a182 3
        || ( (strncmp(content_type, "text/html", content_type_len) != 0)
	  && (strncmp(content_type, "application/octet-stream",
		content_type_len) != 0)
@


1.32.2.3
log
@working copy (?)
@
text
@d29 1
a29 1
static void complete_bypass(struct http_headers *hp, int sock, clib_data *dat);
d130 1
a130 1
	complete_bypass(hp, sock, &dat);
d187 1
a187 1
      complete_bypass(hp, sock, &dat);
d198 1
a198 1
      complete_bypass(hp, sock, &dat);
d246 1
a246 1
      complete_bypass(hp, sock, &dat);
d307 1
a307 1
complete_bypass(struct http_headers *hp, int sock, clib_data *dat)
d309 1
a309 20
  if (hp->secret) {
    int mimetype_len;
    char contlen[20];
    char *mimetype = (char *)get_header_value(dat->mime_headers,
	"content-type", &mimetype_len, NULL, NULL);
    
    if (!mimetype) {
	mimetype = "text/html";
	mimetype_len = 9;
    }

    sprintf(contlen, "%lu", (unsigned long)dat->data_size);
    (void)correct_write(sock, "HTTP/1.0 200 OK\r\nContent-type: ", 31);
    (void)correct_write(sock, mimetype, mimetype_len);
    (void)correct_write(sock, "\r\nContent-length: ", 18);
    (void)correct_write(sock, contlen, strlen(contlen));
    (void)correct_write(sock, "\r\n\r\n", 4);
  } else {
    (void)correct_write(sock, dat->mime_headers, dat->mime_size);
  }
d364 1
a364 1
     *  alone.  (Unless this is secret, in which case strip them.)
d366 1
a366 1
    if (hp->secret || dat->mime_size > PERF_HTTP_TOTAL_HEADERLEN) {
@


1.31
log
@distiller chaining is alive sort of
@
text
@d28 1
a28 1

d203 1
a203 1
      lo->size_after = dout.length;
d206 1
a206 1
      correct_write(sock, (char *)(dout.data), (int)(dout.length));
d229 4
a232 4
      dat.mime_headers = dout.metadata;
      dat.mime_size = dout.metalength;
      dat.data = dout.data;
      dat.data_size = dout.length;
d257 6
a262 2
  if (freeOutput)
    FreeOutputBuffer(&dout);
d322 4
a325 4
  din.data = (void *)(dat->data);
  din.length = dat->data_size;
  din.metadata = (void *)(dat->mime_headers);
  din.metalength = dat->mime_size;
d329 1
a329 2
                   &din, doutp,
                   freeOutputBuf);
d340 1
a340 1
              doutp->mimeType, doutp->length);
d347 1
a347 1
      sprintf(__tmp, "%lu", doutp->length);
d406 8
@


1.30
log
@alternate redispatch mechanism: requeue to new thread
@
text
@d51 4
a54 2
  clib_data dat;
  int tmp;
d57 2
a58 1
  int sock = (int)TASK_DATA(tsk);
d72 1
d111 2
d114 4
a117 4
  } else {
    /*
     *  Server response indicates success
     */
a118 3
    DistillerStatus status;
    DistillerOutput dout;
    gm_Bool freeOutput = gm_False;
d124 7
a130 1
    
d154 3
a156 2
     *  If the content-type is NOT text/html, and the content-length is known
     *  and is <= the threshold value, then bypass.
d158 3
a160 3
    if ((content_type != NULL)
        && (strncmp(content_type, "text/html", content_type_len) != 0)
        && dat.data_size <= thresh) {
d221 8
d233 1
a233 1
      (UINT32)(tsk->task_result_ptr)++; /* "time to live" of this req */
a247 3
    if (freeOutput && (status != distRedispatch))
      FreeOutputBuffer(&dout);

d254 2
a255 2
  } /* server_response_ok */

d257 3
d262 2
a263 10
  if ((dat.mime_headers) && (dat.mime_size != 0)
      && (status != distRedispatch)) {
    FREE(dat.mime_headers);
    dat.mime_headers = NULL;
  }
  if ((dat.data) && (dat.data_size != 0)
      && (status != distRedispatch)) {
    FREE(dat.data);
    dat.data = NULL;
  }
a333 1
    char tmp[8];
d339 1
d344 2
a345 2
      sprintf(tmp, "%lu", doutp->length);
      insert_header(hp->header_data, "Content-length", tmp, 1);
@


1.29
log
@distBadInput no longer causes user-visible error
@
text
@d61 5
d188 3
a190 1
    if (status == distOk) {
d198 1
d200 4
a203 4
    } else if (status == distDistillerNotFound
               || status == distLaunchTimeout
               || status == distBadInput
               || status == distConnectionBroken) {
d208 1
d210 10
a219 3
    } else {     /* status == some other distiller/ptm error */

      /* report other distiller/ptm error  */
d226 1
d228 1
a228 1
    } /* status == distOk */
d230 1
a230 1
    if (freeOutput)
d244 2
a245 2
  
  if ((dat.mime_headers) && (dat.mime_size != 0)) {
d249 2
a250 1
  if ((dat.data) && (dat.data_size != 0)) {
d310 2
@


1.29.2.1
log
@fixed minor buglets in interaction of htmlmunger and java gui
@
text
@d157 1
a157 1
        && strcasecmp(PREFS_FORM_URL, hp->url) != 0) {
@


1.29.2.2
log
@fixed some errors that were cause the branch not to compile
@
text
@d157 1
a157 1
        && strcasecmp(SET_PREFS_URL, hp->url) != 0) {
@


1.28
log
@erros in the log show -status so they can be differentiated
@
text
@d194 1
d201 1
a201 1
    } else {     /* status != distOk  &&  status != distDistillerNotFound */
@


1.27
log
@*** empty log message ***
@
text
@d182 1
a182 1
    lo->size_after = -1;        /* pessimistically assume failure for log */
@


1.26
log
@added sbrk monitoring to frontend
@
text
@d69 3
a71 1
      http_error_return(sock, hp->version, HTTP_ERR_CACHE, (char *)cl);
@


1.25
log
@special case behavior: always distil user prefs URL, which comes from config.h
@
text
@d63 2
d70 1
a70 1
      return;
d78 1
a78 1
      return;
@


1.24
log
@added logging, which also resulted in shuffling around a lot of .h files and what goes into each
@
text
@d147 4
a150 1
    /* should we bypass the url because the FRONT_NO_DISTILL arg is set */
d152 2
a153 1
        && ARG_INT(*arg)) {
@


1.23
log
@moved POST logic into proxy_dispatch - just as steve said, much simpler this way
@
text
@d8 4
d38 2
d47 2
a48 1
proxy_dispatch(struct http_headers *hp, ArgumentList *al, int sock, task_t *tsk)
d55 2
a56 1
 
d90 2
d114 10
d174 1
d178 1
@


1.22
log
@POST works, though logic is ugly and should be moved mostly into proxy_dispatch
@
text
@d25 1
a25 1
/*static*/ void complete_bypass(int sock, clib_data *dat);
d52 6
a57 1
  if ((cl = Clib_Fetch((char *)(hp->url), (char *) (hp->header), 
d59 11
a69 2
    http_error_return(sock, hp->version, HTTP_ERR_CACHE, (char *)cl);
    return;
d82 11
a92 2
  if (server_response_ok) {
    
a190 8
  } else {     /* !(server_response_ok) */
    
    /* HTTP error: bypass result */
    inst_set_thread_state(thrindex, THR_WRITEBACK);
    proxy_debug_4(DBG_HTTP, "Bypassing non-OK status %d for %s", (char *)tmp,
                  hp->url);
    complete_bypass(sock, &dat);

d214 1
a214 1
/*static*/ void
@


1.21
log
@fixed poss segfault in set_distiller_type: wrong args being passed to strncpy?
@
text
@d24 2
a25 6
static void complete_bypass(int sock, clib_data *dat);
static int insert_header(char *hdrs, const char *str,
                      const char *value, int replace_p);
static int delete_header(char *hdrs, const char *str);
static const char *get_header_value(const char *str, const char *which, int *len,
                                    char **hdr, int *totallen);
d199 1
a199 1
static void
a313 148
}

/*
 *  Return the (string) value of the given MIME header, or NULL if it
 *  doesn't exist.
 *  ARGS:
 *    i: MIME headers verbatim from client
 *    i: header to look for
 *    o*: pointer to fill in: length of found value string, may be 0
 *       (if null, won't be filled in)
 *    o*: pointer to fill in: beginning of header line (if passed in as NULL,
 *      won't be filled in)
 *    o*: pointer to fill in: length of header line up to but not including
 *      first char of header value  (if NULL, won't be filled in)
 *  ASSUMPTIONS: none
 *  SIDE EFFECTS: none
 *  RETURNS: NULL (and sets length ptr to zero) if given header does not
 *  appear to be present; char pointer to header (and sets length
 *  pointer to length of value string) if found
 *  THREAD-SAFE: yes
 */

static const char *
get_header_value(const char *str, const char *which, int *len,
                 char **hdr, int *totallen)
{
  const char *tmp,*savetmp;
  size_t ndx;

  if (len) {  *len = 0; }
  if (totallen) { *totallen = 0; }
  
  tmp = strcasestr(str, which);
  if (tmp == NULL)
    return NULL;

  savetmp=tmp;
  if (hdr) { *hdr = (char *)tmp; }

  tmp += strlen(which);

  /* assume we found the header.  Parse forward past a colon and
     possible whitespace.  If we hit a CRLF, we've gone too far.  */

  if (*tmp++ != ':')
    return NULL;

  ndx = strspn(tmp, " \t");
  if (ndx >= strlen(tmp))
    return NULL;

  /* set length to indicate actual string length */
  tmp += ndx;                   /* beginning of string */
  if (totallen) { *totallen = tmp-savetmp; }
  if (len) { *len = strcspn(tmp,"\r\n"); } /* length of string without trailing
                                              \r\n   */
  return tmp;
}


/*
 *  Delete a header.
 *  ARGS:
 *    i/o: headers
 *    i: header to delete
 *  RETURNS:
 *    nonzero iff delete succeeded
 *  SIDE EFFECTS:
 *    Modifies headers in place
 *  BUGS:
 *    BUG::empty headers (with all-whitespace values) are not deleted properly,
 *  yet this function still reports success on those cases.  
 */
static int
delete_header(char *hdrs, const char *str)
{
  char *line;
  const char *dummy;
  int x;
  int len;
  int totallen;
  
  dummy = get_header_value(hdrs, str, &x, &line, &len);
  if (dummy == NULL) {          /* not found */
    return 0;
  } else {
    /* close up space from other headers */
    /* BUG::this assumes lines end with \r\n (hence "+2" below).  i believe it
     *  may be legal for lines to end with just one or the other.
     */
    totallen = len+x+2;
    memmove(line, line+totallen, (hdrs + strlen(hdrs)) - (line+totallen));
    *(hdrs+strlen(hdrs)-totallen) = '\0';
  }
  return 1;
}

/*
 *  Insert a new header.  If replace_p is nonzero, and this header already
 *  exists, delete the old one.
 *  ARGS:
 *    i/o: complete set of headers, verbatim
 *    i/o: current maximum buffer size of headers
 *    i: header to replace (string, case-insensitive)
 *    i: new value (string)
 *  RETURNS:
 *    Nonzero iff success.
 *  SIDE EFFECTS:
 *    Modifies the header structure passed in.
 *    If the headers had to be realloc'd to grow a header, the new buffer size
 *  is written over the 2nd argument.
 *  ASSUMPTIONS:
 *    If header is to be replaced, the header is unique (i.e. it can only
 *  appear once in the header list).
 */

static int
insert_header(char *hdrs, const char *str, const char *value, int replace_p)
{
  char tmpstr[200];
  int tmpstrlen;
  size_t hdrlen;
  size_t newhdrlen = strlen(str);
  size_t valuelen = strlen(value);
  
  /*
   *  BUG::assumes headers always end in "\r\n".  i believe it may be legal for
   *  them to end in one or the other; if so, the "+2"s below are wrong.
   */
  int grow = newhdrlen + valuelen + 2 + 2; /* "Header: Value\r\n" */
  /* that's +2 for colon and space, +2 for \r\n */

  if (replace_p) {
    delete_header(hdrs, str);
  }

  hdrlen = strlen(hdrs);
  if (hdrlen + grow > PERF_HTTP_TOTAL_HEADERLEN) {
    /* grow enough for about 10 operations of this type (10 headers seems to
       be typical for server return) */
    return 0;
  }
    
  sprintf(tmpstr, "%s: %s\r\n\r\n", str, value);
  tmpstrlen = strlen(tmpstr);
  strncpy(hdrs + hdrlen - 2, tmpstr, tmpstrlen);
  *(hdrs + hdrlen - 2 + tmpstrlen) = '\0';
  return 1;
@


1.20
log
@Server headers are now handled correctly.  the delete_header and insert_header
functions in dispatch.c do the right thing. (they should be moved to
httpsupport.c)
@
text
@d302 1
a302 1
  const char *mimetype = NULL;
d305 1
a305 1
  mimetype = get_header_value(mime_headers, "content-type", &mimetype_len,
d312 5
a316 4
    char thetype[MIME_TYPE_MAX];
    strncpy(thetype, mimetype, mimetype_len);
    thetype[mimetype_len] = '\0';
    SET_DISTILLER_TYPE(*dtype, thetype);
@


1.19
log
@Added "loadavg" instrumentation in thr_mon.c, though it doesn't really
work yet.  Broke out instrumentation into separate funcs for
readability.  minor bug fix (malloc -> alloca) in httpgo.c.  moved
monitor debugging macros from proxy.h into debug.h.  frontend now
bypasses original if size is below default threshold, or if distiller
cannot be launched.
@
text
@d25 5
a29 2
static const char *get_header_value(const char *str, const char *which,
                                    int *len);
d89 1
a89 1
                                    &content_type_len);
d228 2
d257 18
a274 3
    sprintf(hp->header_data,
            "HTTP/1.0 200 OK\r\nContent-type: %s\r\nContent-length: %lu\r\n\r\n",
            doutp->mimeType, doutp->length);
d305 2
a306 1
  mimetype = get_header_value(mime_headers, "content-type", &mimetype_len);
d325 6
a330 1
 *    o*: pointer to fill in: length of found value string (0 if not found)
d332 1
a332 1
 *  SIDE EFFECTS: non
a338 1

d340 2
a341 1
get_header_value(const char *str, const char *which, int *len)
d343 1
a343 1
  const char *tmp;
d346 2
a347 1
  *len = 0;
d353 3
d365 1
a365 3
  if (ndx >= strlen(tmp)
      || tmp[ndx] == '\r') {
    /* not found */
d367 1
a367 1
  }
d370 62
d433 32
a464 2
  *len = strcspn(tmp,"\r\n");
  return tmp;
@


1.18
log
@added stuff to do timestamp monitoring at various interesting points in
a worker thread's lifetime.  also split out monitoring stuff into its
own file thr_mon.c.
@
text
@d75 2
a76 2
    const char *content_length, *content_type;
    int content_length_len, content_type_len;
d79 1
a84 2
    content_length = get_header_value(dat.mime_headers,"content-length",
                                      &content_length_len);
d87 10
d99 1
a99 3
        && (content_length != NULL) 
        && ((arg = getArgumentFromIdInList(al, FRONT_MTU)) != NULL)
        && strtoul(content_length, NULL, 0) <= ARG_INT(*arg)) {
d141 1
d144 2
a145 1
      /* forward original if distiller not found for this type */
d163 6
d179 1
d181 1
@


1.17
log
@added frontend reqs/sec meter, retries for distConnectionBroken
@
text
@a48 2
  int dispatchP = 1;
  int i;
d50 3
a52 1
  set_thread_state(thrindex, THR_CACHE);
d59 2
d75 2
a76 1
    const char *content_length;
a77 1
    int content_length_len;
d81 2
a82 1
     *  Is this content small enough to just bypass?
d86 5
a90 1
    if ((content_length != NULL) 
d99 2
a100 5
    for (i = 0; i<al->nargs; i++) {
      if (ARG_ID(al->arg[i]) == FRONT_NO_DISTILL && ARG_INT(al->arg[i]))
	  dispatchP = 0;
    }
    if (!dispatchP) {
d117 1
d119 1
a119 1
      set_thread_state(thrindex, THR_DISTILLER);
d121 1
a121 1
      set_thread_state(thrindex, THR_WRITEBACK);
d128 1
d131 1
d150 1
a150 1
    
d157 1
a157 1
    set_thread_state(thrindex, THR_WRITEBACK);
@


1.16
log
@moved the FRONT_NO_DISTILL checking to proxy_dispatch in dispatch.c
from http_go_proc in httpgo.c
@
text
@d76 1
d102 6
a107 1
     *  Distillation is definitely needed, so go do it.
d110 9
a118 3
    set_thread_state(thrindex, THR_DISTILLER);
    status = do_distillation(&dat, hp, &dout, &dtype, al, &freeOutput);
    set_thread_state(thrindex, THR_WRITEBACK);
d126 2
a127 1
    } else if (status == distDistillerNotFound) {
d139 2
a140 1
      http_error_return(sock, hp->version, HTTP_ERR_DISTILLER, (char *)status);
@


1.15
log
@added functionality in dispatch.c to bypass too-small content. added new
function get_header_value which returns the value of a MIME header (or
NULL if the header doesn't exist), and (temporarily) duplicated the
getArgumentById code in order to search for the FRONT_MTU arg, which is
used as the cutoff for distillation.
Made larger default buffer in munge_magic.c "generic process tag"
routine to avoid stupid segfaults (thanks Purify!)
@
text
@d48 4
a51 2
  int server_response_ok;
  
d89 10
@


1.14
log
@now proxy_dispatch calls Clib_Fetch with the header field of hp, so
that headers are passed on through the proxy and to the server.
@
text
@d9 1
d24 3
d71 3
d75 17
d105 1
a105 2
      correct_write(sock, dat.mime_headers, (size_t)dat.mime_size);
      correct_write(sock, dat.data, (size_t)dat.data_size);
d110 4
d115 1
a115 1

d127 1
a127 2
    (void)correct_write(sock, dat.mime_headers, dat.mime_size);
    (void)correct_write(sock, dat.data, dat.data_size);
d130 2
d144 14
d220 1
a220 1
 *     o: pointer to C_DistillerType structure to be filled in to
d232 2
a233 1
  char *mimetype = NULL;
d235 2
a236 3
  if (((mimetype = strstr(mime_headers, "Content-type:")) == NULL)
      &&
      ((mimetype = strstr(mime_headers, "Content-Type:")) == NULL)) {
d242 3
a244 19
    /*
     *  parse out the MIME type from the headers.  the mime_type pointer
     *  is pointing at the beginning of the "Content-type:" string.
     *  Increment the pointer to point at the first whitespace following
     *  the colon, and use scanf to grab the MIME type string.
     *  PERF::Not the most efficient imaginable way to do it.
     */
    mimetype += 13;
    while (*mimetype == ' ')
      mimetype++;
    if (sscanf(mimetype, "%80s", thetype) == 1) {
      SET_DISTILLER_TYPE(*dtype, thetype);
    } else {
      /* couldn't scan MIME type from line: assume text/html  */
      proxy_debug_3(DBG_MIME,
                    "Couldn't scan MIME type for %s, assuming text/html",
                    url);
      SET_DISTILLER_TYPE(*dtype, "text/html");
    }
d248 23
d272 36
@


1.13
log
@fixed dispatch.c bugs, restructured code to make it more readable
@
text
@d47 2
a48 1
  if ((cl = Clib_Fetch((char *)(hp->url), &dat)) != CLIB_OK) {
@


1.12
log
@fixed bugs found by purify run
@
text
@d15 9
a39 2
  C_DistillerType dtype;
  DistillerStatus status;
a41 1
  char *mimetype;
d44 1
d49 1
a49 1
    goto DISPATCH_RETURN_NO_DISTILL;
d51 1
d53 2
a54 6
   *  Use the Content-type header to figure out what this was.  If this
   *  HTTP 0.9, we assume HTML - not necessarily a good idea.
   */
  
  /*
   *  BUG::need to check for HTTP 0.9
d57 30
a86 1
  proxy_debug_4(DBG_HTTP, "Len=%d hdr=%s", dat.data_size, dat.mime_headers);
d88 4
a91 4
  /*
   *  if there was an HTTP-level error (response is not "200"), bypass
   *  the remainder straight to client.
   */
d93 2
a94 2
  if ((sscanf(dat.mime_headers, "%*s %d", &tmp) < 1)
      || (tmp != 200)) {
d101 6
a106 1
    goto DISPATCH_RETURN_NO_DISTILL;
d108 39
d148 44
a191 2
  if (((mimetype = strstr((const char *)(dat.mime_headers), "Content-type:"))
       == NULL)
d193 1
a193 2
      ((mimetype = strstr((const char *)(dat.mime_headers), "Content-Type:"))
       == NULL)) {
d195 2
a196 2
                  hp->url);
    SET_DISTILLER_TYPE(dtype, "text/html");
d203 1
a203 1
     *  the colon, and use scanf to grab the number.
d210 1
a210 1
      SET_DISTILLER_TYPE(dtype, thetype);
d215 2
a216 30
                    hp->url);
      SET_DISTILLER_TYPE(dtype, "text/html");
    }
  }
  /*
   *  Got the distiller type, try to distill.
   */
  {
    DistillerInput din;
    DistillerOutput dout;
    gm_Bool freeOutputBuf;

    proxy_debug_4(DBG_PTM, "Distilling %s type %s", hp->url,
                  GET_DISTILLER_TYPE(dtype) );
    din.data = (void *)(dat.data);
    din.length = dat.data_size;
    strcpy(din.mimeType, GET_DISTILLER_TYPE(dtype));
    
    set_thread_state(thrindex, THR_DISTILLER);
    status = Distill(&dtype, al->arg, al->nargs,
                     &din, &dout, &freeOutputBuf);

    set_thread_state(thrindex, THR_DISTILLERDONE);

    if (status == distDistillerNotFound) {
      set_thread_state(thrindex, THR_WRITEBACK);
      (void)correct_write(sock, dat.mime_headers, (size_t)dat.mime_size);
      (void)correct_write(sock, dat.data, (size_t)dat.data_size);
      goto DISPATCH_RETURN;
      /* NOTREACHED */
a217 33
    /*
     *  If a distiller/PTM error happened, report it to the user (PTM
     *  reported it already to the monitor)
     */
    if (status != distOk) {
      http_error_return(sock, hp->version, HTTP_ERR_DISTILLER, (char *)status);
      goto DISPATCH_RETURN;
      /* NOTREACHED */
    }
  
    /*
     *  BUG::should send original server headers with modified
     *  content-length, instead of sending our own headers. Most of this
     *  stuff should NOT be hardcoded!
     */
    set_thread_state(thrindex, THR_WRITEBACK);
    sprintf(hp->header_data,
            "HTTP/1.0 200 OK\r\nContent-type: %s\r\nContent-length: %lu\r\n\r\n",
            dout.mimeType, dout.length);
    (void)correct_write(sock, hp->header_data, -1);
    (void)correct_write(sock, (char *)(dout.data), (int)(dout.length));
DISPATCH_RETURN:
    if (freeOutputBuf)
      FreeOutputBuffer(&dout);
  }
DISPATCH_RETURN_NO_DISTILL:
  if ((dat.mime_headers) && (dat.mime_size != 0)) {
    free(dat.mime_headers);
    dat.mime_headers = NULL;
  }
  if ((dat.data) && (dat.data_size != 0)) {
    free(dat.data);
    dat.data = NULL;
a219 1

@


1.11
log
@fixed purify bugs 1 and 2 as reported by yatin
@
text
@d42 1
a42 1
    goto DISPATCH_RETURN;
@


1.10
log
@Added the brown color to the thread monitor panel
@
text
@d68 1
a68 1
    goto DISPATCH_RETURN;
d113 1
d118 1
d120 1
a120 5
    /*
     *  PERF::if status is "no such distiller", should bypass result
     *  from the data we already have, rather than calling into Harvest a
     *  second time!!
     */
d150 4
a153 2
  if (freeOutputBuf)
    FreeOutputBuffer(&dout);
a160 1
  }
@


1.9
log
@Got rid of memory leak in frontend - the dispatch routine wasn't freeing
the buffers allocated and returned by Clib_Fetch.
@
text
@d117 1
@


1.8
log
@User prefs skeleton working
@
text
@d153 8
@


1.7
log
@thread state logging added to frontend
@
text
@d41 1
a41 1
    http_error_return(sock, hp->version, HTTP_CACHE_ERR, (char *)cl);
d118 14
a131 1
     *  BUG::if status is "no such distiller", should bypass result.
d134 1
a134 1
      http_error_return(sock, hp->version, HTTP_DISTILLER_ERR, (char *)status);
d136 1
d148 2
a149 2
    correct_write(sock, hp->header_data, -1);
    correct_write(sock, (char *)(dout.data), (int)(dout.length));
@


1.6
log
@Modified the ptm stub and distiller stub to use the new distiller API
@
text
@d29 1
a29 1
proxy_dispatch(struct http_headers *hp, ArgumentList *al, int sock)
d37 3
a39 1

d63 1
d114 1
d117 3
d130 1
@


1.5
log
@fixed dispatch to allow output of different mime type, fixed bug in test_http.c where monitor was being used before initialized
@
text
@a127 1
  }
d131 1
@


1.4
log
@changed distiller interface to use struct DistillerInput/DistillerOutput in frontend,gif_munge,html_munge
@
text
@a113 2
      if (freeOutputBuf)
        FreeOutputBuffer(&dout);
d125 1
a125 1
            GET_DISTILLER_TYPE(dtype), dout.length);
a127 2
    if (freeOutputBuf)
      FreeOutputBuffer(&dout);
d130 2
a131 1
  ;
@


1.3
log
@Added doc/distillers.txt, which explains how to write your own
distiller.  Gifmunger should now do the right thing even on extremely
large images.  Default args for gifmunger are more sane (16 colors,
scale 0.5 per axis), but output still looks sucky - not sure why the
quantize phase picks such crappy colors.  "test_http" program has been
officially renamed "frontend".  Fixed the "run" targets in toplevel
Makefile.  Added line to configure.in to create a Makefile from
Makefile.in for gui.
@
text
@a32 2
  void *distiller_output;
  UINT32 output_size;
d101 31
a131 10
  proxy_debug_4(DBG_PTM, "Distilling %s type %s", hp->url,
                GET_DISTILLER_TYPE(dtype) );
  status = Distill(&dtype, al->arg, al->nargs,
                   (void *)(dat.data), dat.data_size,
                   &distiller_output, &output_size);
  if (status != distOk) {
    /* BUG::should we free the output buffer if there was an error??? */
    FreeOutputBuffer(distiller_output);
    http_error_return(sock, hp->version, HTTP_DISTILLER_ERR, (char *)status);
    goto DISPATCH_RETURN;
a132 13
  
  /*
   *  BUG::should send original server headers with modified
   *  content-length, instead of sending our own headers. Most of this
   *  stuff should NOT be hardcoded!
   */
  sprintf(hp->header_data,
          "HTTP/1.0 200 OK\r\nContent-type: %s\r\nContent-length: %lu\r\n\r\n",
          GET_DISTILLER_TYPE(dtype), output_size);
  correct_write(sock, hp->header_data, -1);
  correct_write(sock, (char *)distiller_output, (int)output_size);
  FreeOutputBuffer(distiller_output);

@


1.2
log
@End to end path works via dispatch.c, some error reporting still broken and some things still hardcoded that shouldn't be
@
text
@a89 1
#define MAXSTRING(len) "% ## len ## s"
@


1.1
log
@all the stubs work; now adding the dispatching functionality in newly
added dispatch.c
@
text
@d9 5
a13 1
#include "proxyinterface.h"
d15 12
a26 1
static const char *guess_mime_type(struct http_headers *hp);
d29 1
a29 1
proxy_dispatch(struct http_headers *hp, ArgumentList *al)
d32 7
d40 90
d131 1
@
