head	1.53;
access;
symbols
	Yatin-final:1.48.2.3
	Yatin:1.48.0.2
	pre-yatin-merge:1.48
	transend-beta2:1.41
	fox-dev:1.41.4.5
	frontend-ng:1.37
	transend-beta-latest:1.37
	Aggregators:1.36
	NoAggregators:1.36
	iang:1.33.0.2
	transend-beta:1.31.0.2
	SOSP:1.24
	merged_preintegrate:1.8
	heisenbug:1.8
	PRE_INTEGRATION:1.8;
locks; strict;
comment	@ * @;


1.53
date	98.08.12.21.15.41;	author gribble;	state Exp;
branches;
next	1.52;

1.52
date	98.02.12.01.32.28;	author fox;	state Exp;
branches;
next	1.51;

1.51
date	98.02.12.01.11.19;	author fox;	state Exp;
branches;
next	1.50;

1.50
date	98.01.16.22.15.55;	author yatin;	state Exp;
branches;
next	1.49;

1.49
date	97.12.15.04.57.21;	author tkimball;	state Exp;
branches;
next	1.48;

1.48
date	97.10.26.00.29.34;	author fox;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	97.10.25.00.38.35;	author gribble;	state Exp;
branches;
next	1.46;

1.46
date	97.10.18.00.34.34;	author iang;	state Exp;
branches;
next	1.45;

1.45
date	97.10.18.00.33.45;	author iang;	state Exp;
branches;
next	1.44;

1.44
date	97.09.10.06.08.40;	author gribble;	state Exp;
branches;
next	1.43;

1.43
date	97.09.06.02.29.48;	author gribble;	state Exp;
branches;
next	1.42;

1.42
date	97.08.30.21.34.18;	author fox;	state Exp;
branches;
next	1.41;

1.41
date	97.07.29.00.32.00;	author fox;	state Exp;
branches
	1.41.4.1;
next	1.40;

1.40
date	97.07.25.03.37.38;	author fox;	state Exp;
branches;
next	1.39;

1.39
date	97.07.25.01.06.30;	author fox;	state Exp;
branches;
next	1.38;

1.38
date	97.07.24.18.50.03;	author fox;	state Exp;
branches;
next	1.37;

1.37
date	97.06.04.01.16.43;	author fox;	state Exp;
branches;
next	1.36;

1.36
date	97.05.11.11.23.33;	author fox;	state Exp;
branches;
next	1.35;

1.35
date	97.05.01.02.24.23;	author gribble;	state Exp;
branches;
next	1.34;

1.34
date	97.05.01.02.09.38;	author gribble;	state Exp;
branches;
next	1.33;

1.33
date	97.04.30.21.33.47;	author fox;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	97.04.28.19.03.48;	author fox;	state Exp;
branches;
next	1.31;

1.31
date	97.04.19.00.30.31;	author gribble;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	97.04.17.01.22.06;	author fox;	state Exp;
branches;
next	1.29;

1.29
date	97.04.12.02.53.07;	author gribble;	state Exp;
branches;
next	1.28;

1.28
date	97.04.11.03.26.52;	author gribble;	state Exp;
branches;
next	1.27;

1.27
date	97.04.09.01.31.22;	author fox;	state Exp;
branches;
next	1.26;

1.26
date	97.04.08.17.31.22;	author fox;	state Exp;
branches;
next	1.25;

1.25
date	97.04.08.02.44.39;	author fox;	state Exp;
branches;
next	1.24;

1.24
date	97.03.09.09.08.09;	author fox;	state Exp;
branches;
next	1.23;

1.23
date	97.03.05.00.30.58;	author fox;	state Exp;
branches;
next	1.22;

1.22
date	97.03.04.19.26.08;	author aspolito;	state Exp;
branches;
next	1.21;

1.21
date	97.03.03.22.38.49;	author fox;	state Exp;
branches;
next	1.20;

1.20
date	97.02.25.22.56.56;	author aspolito;	state Exp;
branches;
next	1.19;

1.19
date	97.02.25.09.50.36;	author aspolito;	state Exp;
branches;
next	1.18;

1.18
date	97.02.24.20.25.05;	author fox;	state Exp;
branches;
next	1.17;

1.17
date	97.02.24.20.12.32;	author fox;	state Exp;
branches;
next	1.16;

1.16
date	97.02.19.01.29.32;	author aspolito;	state Exp;
branches;
next	1.15;

1.15
date	97.02.15.00.51.31;	author fox;	state Exp;
branches;
next	1.14;

1.14
date	97.02.15.00.14.52;	author fox;	state Exp;
branches;
next	1.13;

1.13
date	97.02.14.06.35.02;	author fox;	state Exp;
branches;
next	1.12;

1.12
date	97.02.13.03.41.52;	author aspolito;	state Exp;
branches;
next	1.11;

1.11
date	97.02.13.03.12.31;	author aspolito;	state Exp;
branches;
next	1.10;

1.10
date	97.02.07.22.47.56;	author fox;	state Exp;
branches;
next	1.9;

1.9
date	97.02.04.05.37.23;	author fox;	state Exp;
branches;
next	1.8;

1.8
date	96.12.12.02.16.52;	author fox;	state Exp;
branches;
next	1.7;

1.7
date	96.12.11.05.25.52;	author fox;	state Exp;
branches;
next	1.6;

1.6
date	96.12.11.01.12.16;	author fox;	state Exp;
branches;
next	1.5;

1.5
date	96.12.09.04.53.50;	author fox;	state Exp;
branches;
next	1.4;

1.4
date	96.12.09.02.38.13;	author fox;	state Exp;
branches;
next	1.3;

1.3
date	96.11.22.21.40.07;	author gribble;	state Exp;
branches;
next	1.2;

1.2
date	96.11.15.00.47.47;	author fox;	state Exp;
branches;
next	1.1;

1.1
date	96.11.08.01.50.44;	author fox;	state Exp;
branches;
next	;

1.31.2.1
date	97.05.07.22.21.22;	author aspolito;	state Exp;
branches;
next	;

1.33.2.1
date	97.05.06.23.49.34;	author iang;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	97.05.08.23.29.08;	author iang;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	97.05.13.09.13.01;	author iang;	state Exp;
branches;
next	;

1.41.4.1
date	97.08.11.04.12.50;	author fox;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	97.08.14.16.40.20;	author fox;	state Exp;
branches;
next	1.41.4.3;

1.41.4.3
date	97.08.15.03.43.03;	author fox;	state Exp;
branches;
next	1.41.4.4;

1.41.4.4
date	97.08.15.07.02.55;	author fox;	state Exp;
branches;
next	1.41.4.5;

1.41.4.5
date	97.08.16.07.04.18;	author fox;	state Exp;
branches;
next	;

1.48.2.1
date	97.11.25.01.25.09;	author yatin;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	97.11.30.01.24.47;	author yatin;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	97.12.03.01.19.41;	author yatin;	state Exp;
branches;
next	;


desc
@@


1.53
log
@slight tweak
@
text
@/*
 *  httpgo.c
 *  This file contains the HTTP request handling code that defines the
 *  TranSend distillation web proxy.  It corresponds to the TranSend Service
 *  layer in the layered SNS model.
 */

#include "frontend.h"
#include "debug.h"
#include "comm_http.h"
#include "userpref.h"
#include "url_magic.h"
#include "ARGS.h"
#include "utils.h"
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#ifdef LOGGING
#include "md5.h"
static char magicKey[] = "aa883fd833ef";
#endif /* LOGGING */

static userkey userkey_from_sock_ipaddr(int sock);

#define TRANSEND_STATUS_HEADER  "X-Proxy-Status"
#define TRANSEND_ERROR_HEADER   "X-Proxy-Error"

/*
 *  Error codes are roughly:
 *  100-199  Informational
 *  200-299  OK
 *  300-399  Additional user action required
 *  400-499  Error on this transaction
 *  500-599  Fatal error (rare)
 */

/*
 *  http_go_proc: thread entry point to handle an incoming HTTP request 
 *  The request will be parsed, validated, and handed off to a remote
 *  distiller (or else rejected).  This is a long blocking operation.
 *
 *  ARGS:
 *  i/o: the task_t structure; its task_data field contains the file
 *      number of the socket on which the request is arriving.
 *  RETURNS: a void* which is ignored; errors are reported directly on
 *      socket using HTTP error protocol (500 Error, etc)
 *  REENTRANT: yes
 *  
 */

void *
http_go_proc(task_t *t)
{
  int index = TASK_THRINDEX(t);
  Request h;
  ArgumentList prefs;
  userkey k;
  HTTP_Status result;
  DistillerStatus dist_result;
  const char *content_type;
  Argument *arg;
  int thresh;
  gm_Bool no_distill = gm_False;
  gm_Bool is_text_html = gm_False;
#ifdef LOGGING
  struct loginfo lo;
  char logmsg[MAX_LOGMSG_LEN];
#endif /* LOGGING */
  
  /*
   *  New task data should be the request structure.
   */
  init_Request(&h);
  h.cli_fd = (int)TASK_DATA(t); /* socket FD of client */
  SET_TASK_DATA(t,&h);
  
  INST_begin_timestamp(index);
  INST_set_size(index,0);
  INST_set_thread_state(index, THR_ACCEPTED);
  INST_timestamp(index, m_arrival);
#ifdef LOGGING
  LOGGING_init_loginfo(&lo);
  h.lo = &lo;
#endif /* LOGGING */
  /*
   *  this should read all the headers.
   */
  if (TASK_METADATA(t) == NULL) {
    int result;
    
    assert( DistillerBufferAlloc(&h.cli_hdrs, PERF_HTTP_TOTAL_HEADERLEN)
            == gm_True);

    result = readline_or_timeout(&h, READ_ALL_HEADERS, NULL);

    INST_timestamp(index, m_headersdone);
    if (result == -1) { /* client request timed out, or error reading hdrs */
      /* TC::1 client timeout, or request doesn't sanity check */
      goto HTTPGO_FINISH;
      /* NOTREACHED */
    }
  } else {
#ifdef NEWFE
    /*
     *  This task is a child of a previous 
     */
    strncpy(h.cli_hdrs.mime_headers, TASK_METADATA(t),
            PERF_HTTP_TOTAL_HEADERLEN-1);
    FREE(TASK_METADATA(t));
#endif /* NEWFE */
  }

  /* parse the headers and request line, filling them in to the loginfo */
  result = parse_status_and_headers(&h);
  if (result != HTTP_NO_ERR) {
    /* BUG:: last arg of http_error_return should be a substitution arg */
    /* TC::2 parse_status_and_headers returns an error */
    http_error_return(&h, result);
    printf("Error occured here!\n");
    goto HTTPGO_FINISH;
  }
  
  /*
   *  We have a reasonable looking request.  Get prefs for this user.
   */

  k = userkey_from_sock_ipaddr(h.cli_fd);
#ifdef LOGGING
  lo.ipaddr = k;
#endif /* LOGGING */
  (void)get_userprefs(k, &prefs);
  /*
   *  Extract any arguments embedded in the URL itself, and add them
   *  to the arg list.
   *  TC::3 url is magic vs nonmagic
   */
  if (is_magic ((char *) h.url)) {
    /* demagifying a url will never lengthen it so this is a good 
     * upper bounds on the length of the non magical url
     */
    char *demagicURL = ALLOCA(strlen(h.url)+1);
    assert(demagicURL);
    strcpy(demagicURL, h.url);
    from_magic((char *) demagicURL, h.url, &prefs);
  }

  /* determine the threshold for bypassing */
  arg  = getArgumentFromIdInList(&prefs, FRONT_MTU);
  thresh = (arg == NULL ? PERF_FRONT_MTU : ARG_INT(*arg));

  /* determine if distillation is turned off for this
   * request. EXCEPTION: Force distillation for Prefs html form.
   */
  arg = getArgumentFromIdInList(&prefs, FRONT_NO_DISTILL);
  if (arg != NULL
      && ARG_INT(*arg)
      && strcasecmp(fe_get_prefs_url, h.url) != 0) {
    /* TC::4 no_distill is set */
    no_distill = gm_True;
  }  else {
    no_distill = gm_False;
  }
  
  /* Short-circuit the following special  URL's:
   *  - "set my prefs as follows" (e.g. form submission)
   */
  if (is_setpref_url(h.url)) {
    /* 
     * handle what send user prefs form sends back.
     * TC::5 is_setpref_url returns true
     */
    result = parse_and_change_prefs(h.url, k, h.errmsg);
    if (result == HTTP_NO_ERR) {
      /* TC::5.1 setpref url succeeds in setting prefs */
      correct_write(h.cli_fd, "HTTP/1.0 200\r\nContent-type: text/html\r\n\r\n",
                    -1);
      correct_write(h.cli_fd,
                    "<html><head><title>Preferences Set</title></head>"
                    "<body><center><h1>Preferences set</h1>"
                    "Your new preferences have been set.  Press the back "
                    "button twice to resume browsing."
                    "<p></center></body></html>", -1);
    } else {
      /* TC::5.2 setpref url fails in setting prefs */
      http_error_return(&h, result);
    }
  } else if (is_getpref_url(h.url)) {
    /* TC::6 gimme my prefs*/
    send_prefs(&prefs, h.cli_fd);
  } else if (is_server_url(h.url)==gm_False   && 
	     strcasecmp(h.method, "get") != 0 && 
	     strcasecmp(h.method, "post") != 0) {
    /*
     *  Doesn't appear to be an HTTP GET or POST request; so act as a
     *  "dumb tunnel" for passing the request to the server (actually, via
     *  the cache) and relaying the result to the client.
     */
    /* TC::7 tunnel */
    proxy_debug_3(DBG_HTTP, "Tunneling '%s'", 
		  DistillerBufferData(&h.cli_hdrs));
    INST_set_thread_state(index, THR_DISTILLERSEND);
    tunnel(&h);
  } else {
    /*
     *  It's not a special URL, and the request appears to be a GET/POST.
     * Add in the client's IP address as an INT32 argument so that
     *  the distiller driver can get at it.
     */
    SET_ARG_INT(prefs.arg[prefs.nargs], (INT32) k);
    SET_ARG_ID(prefs.arg[prefs.nargs], FRONT_CLIENT_IP);
    prefs.nargs++;
    result = server_dispatch(&prefs, t);
    /*
     *  If we get a transport-level error (i.e. fetch from cache failed
     *  due to an internal cache error), wrap the error in HTML (if
     *  needed) and return error to user.
     *  Otherwise, if the transaction succeeded but the server return
     *  code indicates failure (i.e. != 200),  **OR** if the server data
     *  is smaller than a threshold size, bypass the server data
     *  directly to the client.
     *  Otherwise, attempt to distill.
     */
    if (result != HTTP_NO_ERR) {
      /* transport level error: wrap in HTML for delivery to user */
      /* TC::8 server_dispatch returns transport level error */
      http_error_return(&h, result);
      goto HTTPGO_FINISH;
    }

    content_type = get_header_value(&h.svr_hdrs,
                                    "content-type", NULL, NULL, NULL);
    if (content_type == NULL) {
      /* TC::9 content-type can't be deduced */
      content_type = "application/octet-stream";
    }
    is_text_html = (  ((strncasecmp(content_type, "text/html", 9) == 0) ||
                       (strncasecmp(content_type, "text/plain", 10) == 0))
                    ? gm_True : gm_False);
    
    /*if ( (*h.url != '/' && strncasecmp(h.url, fe_agg_string, 
				       strlen(fe_agg_string)) != 0) &&*/

    /* bypass ONLY if it is not a server-type URL */
    /* TC::10.1 bypass because non-200s status */
    /* TC::10.2 bypass because not text/html and too small to distill */
    /* TC::4 bypass because no_distill is set */
    /* bypass server data directly to user */

    if ( is_server_url(h.url)==gm_False) {
      char *bypass_reason = NULL;
      if (h.svr_http_status != 200) {
        bypass_reason = "201 Non-OK server status";
      } else if (is_text_html == gm_False
                 && DistillerBufferLength(&h.svr_data) <= thresh) {
        bypass_reason = "202 content-type not text/html and content-length too short";
      } else if (no_distill == gm_True) {
        bypass_reason = "203 distillation not indicated";
      }
      if (bypass_reason) {
        INST_set_thread_state(index, THR_WRITEBACK);
        /*
         *  Set return headers to indicate why the bypass occurred.
         */
        insert_header(&h.svr_hdrs, TRANSEND_STATUS_HEADER, bypass_reason, 0);
        complete_bypass(&h);
        goto HTTPGO_FINISH;
      }
    }
    
    /* all is well: continue by dispatching to a worker for distillation */
    dist_result = proxy_dispatch(&prefs, t);
    switch(dist_result) {
    case distOk:
      /* TC::11 distillation succeeded */
      INST_timestamp(index, m_wbstart);
      insert_header(&h.pxy_hdrs, TRANSEND_STATUS_HEADER, "200 distillation OK", 0);
      correct_write(h.cli_fd, (char *)DistillerBufferData(&h.pxy_hdrs),
                    (int)DistillerBufferLength(&h.pxy_hdrs));
      /* -1 to avoid NULL term gunk */
      correct_write(h.cli_fd, (char *)DistillerBufferData(&h.pxy_data),
                    (int)DistillerBufferLength(&h.pxy_data));
      INST_timestamp(thrindex, m_wbdone);
      break;

    case distDistillerNotFound:
    case distLaunchTimeout:
    case distBadInput:
    case distConnectionBroken:

      /* forward original if distiller for this type not found, connection
         repeatedly broken, or couldn't be launched */
      /* TC::12 bypass because distillation failed */

      insert_header(&h.svr_hdrs,
                      (dist_result == distBadInput ? TRANSEND_STATUS_HEADER
                       : TRANSEND_ERROR_HEADER),
                      FE_getDistillerStatusString(dist_result), 0);
      if ((arg = getArgumentFromIdInList(&prefs, FRONT_DEVELOPER))
          && ARG_INT(*arg)) {
        /* return explicit error message */
        int tmp_len =
          snprintf(h.errmsg, HTTP_ERRMSG_MAX,
                   "<i>[set arg <tt>i%d</tt> to 0 to suppress "
                   "this diagnostic]</i><br>",
                   FRONT_DEVELOPER);
        strncat(h.errmsg, FE_getDistillerStatusString(dist_result),
                HTTP_ERRMSG_MAX - tmp_len - 1);
        http_error_return(&h, HTTP_ERR_UNSPECIFIED);
      } else {

        /*if (*h.url == '/' || 
	    strncasecmp(h.url, fe_agg_string, strlen(fe_agg_string)) == 0) {*/

        if (is_server_url(h.url)==gm_True) {
          /* this is a URL in the frontend's namespace, or an aggregator URL */

          strcpy(h.errmsg, h.url);
          http_error_return(&h, HTTP_ERR_AGGREGATOR_ERROR);
        } else {
          complete_bypass(&h);
        }
      }
    break;
        
    case distRedispatch:
      /*
       *  Redispatch count expired: too many redispatches (probably indicates
       * infinite loop in redispatch route.)
       */
      snprintf(h.errmsg, HTTP_ERRMSG_MAX, "%d", PERF_REQUEST_TTL);
      http_error_return(&h, HTTP_ERR_ROUTING_ERROR);
      break;
      
    default:
        
      /* TC::13 some other distillation error */
      insert_header(&h.svr_hdrs, TRANSEND_STATUS_HEADER,
                    FE_getDistillerStatusString(dist_result), 0);

      http_error_return(&h, HTTP_ERR_UNSPECIFIED);
      break;
    } /* switch(dist_result) */
  } /* if...else...else...endif */

  /* all cases exit through this single exit point */
HTTPGO_FINISH:
  free_Request(&h);
  INST_timestamp(index, m_wbdone);
  INST_end_timestamp(index);

  if (TASK_PARENT(t) == 0 && TASK_CHILD_INDEX(t) == 0) {
    /* this is a "root task" */
    close(h.cli_fd);
  }

#ifdef LOGGING
  /* log the request info */
  /* BUG::relies on formatting of the userkey */

  /* I compare the IP address to 127.0.0.1 so that I don't log connections
     from localhost, namely the fe_check script.  I also MD5 the IP address. */
  k = lo.ipaddr;
  if (((UINT32) k) != ((UINT32) htonl(0x7F000001))) {
/*    MD5_CTX   theHash;
    UINT32    res;

    MD5Init(&theHash);
    MD5Update(&theHash, magicKey, sizeof(magicKey));
    MD5Update(&theHash, &k, sizeof(UINT32));
    MD5Final(&theHash);

    memcpy(&res, theHash.digest, sizeof(UINT32));
    res = ntohl(res);

    snprintf(logmsg, MAX_LOGMSG_LEN-1,
             "(HTTP) %lu %lu \"%s\" %d %ld %ld\n",
             res, lo.date, lo.url,
             lo.http_response, lo.size_before, lo.size_after);*/
    snprintf(logmsg, MAX_LOGMSG_LEN-1,
             "(HTTP) %08x %08x \"%s\" %d %ld %ld\n",
             (UINT32) k, lo.date, lo.url,
             lo.http_response, lo.size_before, lo.size_after);
    gm_log(logmsg);
  }
#endif /* LOGGING */
  return (void *)0;
}


/*
 *  userkey_from_sock_ipaddr: make incoming IP address into a user prefs
 *  key, so we can look up user in prefs database
 *
 *  ARGS: socket (filehandle)
 *  REENTRANT: as safe as getpeername()
 *  RETURNS: userkey; the "null key" if conversion fails
 *
 */

static userkey
userkey_from_sock_ipaddr(int s)
{
  struct sockaddr_in a;
  int alen = sizeof(a);

  memset(&a, 0, alen);
  if (getpeername(s, (struct sockaddr *)&a, &alen) != 0) {
    proxy_errlog_2("userkey_from_sock_ipaddr: %s", strerror(errno));
    return USERKEY_NULL;
  }
  return ((userkey)(a.sin_addr.s_addr));
}

@


1.52
log
@modified distiller error messages to begin with HTTP-like 3-digit numeric status; made distBadInput be an informational rather than error message
@
text
@d237 2
a238 1
    is_text_html = (strncasecmp(content_type, "text/html", 9) == 0
@


1.51
log
@Added X-Proxy-Error and X-Proxy-Status headers to the HTTP frontend,
to relay internal error messages.
@
text
@d294 16
a309 16
      {
        char *errmsg = ALLOCA(6+strlen(FE_getDistillerStatusString(dist_result)));
        sprintf(errmsg, "401 %s", FE_getDistillerStatusString(dist_result));
        insert_header(&h.svr_hdrs, TRANSEND_ERROR_HEADER, errmsg, 0);
        if ((arg = getArgumentFromIdInList(&prefs, FRONT_DEVELOPER))
            && ARG_INT(*arg)) {
          /* return explicit error message */
          int tmp_len =
            snprintf(h.errmsg, HTTP_ERRMSG_MAX,
                     "<i>[set arg <tt>i%d</tt> to 0 to suppress "
                     "this diagnostic]</i><br>",
                     FRONT_DEVELOPER);
          strncat(h.errmsg, FE_getDistillerStatusString(dist_result),
                  HTTP_ERRMSG_MAX - tmp_len - 1);
          http_error_return(&h, HTTP_ERR_UNSPECIFIED);
        } else {
d311 1
a311 1
          /*if (*h.url == '/' || 
d314 2
a315 2
          if (is_server_url(h.url)==gm_True) {
            /* this is a URL in the frontend's namespace, or an aggregator URL */
d317 4
a320 5
            strcpy(h.errmsg, h.url);
            http_error_return(&h, HTTP_ERR_AGGREGATOR_ERROR);
          } else {
            complete_bypass(&h);
          }
d337 3
@


1.50
log
@- new wingman frontend
- new wingman aggregators mechanism
- DistillAsync

(merged from branch Yatin-final)
@
text
@d26 12
d243 25
a267 13
    if ( is_server_url(h.url)==gm_False &&
	 ( (h.svr_http_status != 200)
	   || (is_text_html == gm_False
	       && DistillerBufferLength(&h.svr_data) <= thresh)
	   || (no_distill == gm_True) ) ) {
      /* bypass ONLY if it is not a server-type URL */
      /* TC::10.1 bypass because non-200s status */
      /* TC::10.2 bypass because not text/html and too small to distill */
      /* TC::4 bypass because no_distill is set */
      /* bypass server data directly to user */
      INST_set_thread_state(index, THR_WRITEBACK);
      complete_bypass(&h);
      goto HTTPGO_FINISH;
d276 1
d294 16
a309 12
      if ((arg = getArgumentFromIdInList(&prefs, FRONT_DEVELOPER))
          && ARG_INT(*arg)) {
        /* return explicit error message */
        int tmp_len =
          snprintf(h.errmsg, HTTP_ERRMSG_MAX,
                   "<i>[set arg <tt>i%d</tt> to 0 to suppress "
                   "this diagnostic]</i><br>",
                   FRONT_DEVELOPER);
        strncat(h.errmsg, FE_getDistillerStatusString(dist_result),
                HTTP_ERRMSG_MAX - tmp_len - 1);
        http_error_return(&h, HTTP_ERR_UNSPECIFIED);
      } else {
d311 1
a311 1
	/*if (*h.url == '/' || 
d314 2
a315 2
	if (is_server_url(h.url)==gm_True) {
	  /* this is a URL in the frontend's namespace, or an aggregator URL */
d317 6
a322 5
	  strcpy(h.errmsg, h.url);
	  http_error_return(&h, HTTP_ERR_AGGREGATOR_ERROR);
	} else {
	  complete_bypass(&h);
	}
d324 1
a324 1
      break;
@


1.49
log
@Commiting any files that need commiting!
@
text
@d179 3
a181 2
  } else if (strcasecmp(h.method, "get") != 0
             && strcasecmp(h.method, "post") != 0) {
d228 9
a236 4
    if ((h.svr_http_status != 200)
        || (is_text_html == gm_False
            && DistillerBufferLength(&h.svr_data) <= thresh)
        || (no_distill == gm_True)) {
d281 12
a292 1
        complete_bypass(&h);
@


1.48
log
@changes to headers functions, ptm, and server_dispatch to maintain 2
invariants: (1) DistillerBuffer length field does NOT include
terminating null; (2) terminating null is always present for headers,
and is accoutned for by the maxLength field, so that maxLength >=
length+1.  Changed dispatch logic to allow for "X-static-route"
dispatcher worker.  Somewhat convoluted interaction with existing
X-Route mechanism, which i would remove entirely but for the fact that
it enables dynamic dispatch decisions after each pipestage.  New "guru"
argument i15 allows user to see all pipeline diagnostics that would
normally result in a bypass.
@
text
@d108 1
@


1.48.2.1
log
@- removed -ltcl check in configure.in. It was causing problems with tcl8.0 and
  wasn't being used anyway.
- frontend returns a sane error when transend/myurl/dispatch fails
- added more API functions to tcl_stub
- wingman gm_options aggregators work
- fixed bug in DistillerType::CanSatisfy
- removed debugging printf's from libdist
@
text
@d274 1
a274 9
	if (*h.url == '/' || 
	    strncasecmp(h.url, fe_agg_string, strlen(fe_agg_string)) == 0) {
	  /* this is a URL in the frontend's namespace, or an aggregator URL */

	  strcpy(h.errmsg, h.url);
	  http_error_return(&h, HTTP_ERR_AGGREGATOR_ERROR);
	} else {
	  complete_bypass(&h);
	}
@


1.48.2.2
log
@- Fixed POST bug for server-type URL's
- Fixed httpgo.c so it will never bypass if it is a server-type URL
  (that way I don't need a bogus "content-type: text/html" field in
   the server headers)
@
text
@d226 4
a229 7
    if ( (*h.url != '/' && strncasecmp(h.url, fe_agg_string, 
				       strlen(fe_agg_string)) != 0) &&
	 ( (h.svr_http_status != 200)
	   || (is_text_html == gm_False
	       && DistillerBufferLength(&h.svr_data) <= thresh)
	   || (no_distill == gm_True) ) ) {
      /* bypass ONLY if it is not a server-type URL */
@


1.48.2.3
log
@bug fix for non-get/post requests for web-server-like URL's
@
text
@d178 2
a179 3
  } else if (is_server_url(h.url)==gm_False   && 
	     strcasecmp(h.method, "get") != 0 && 
	     strcasecmp(h.method, "post") != 0) {
d226 2
a227 4
    /*if ( (*h.url != '/' && strncasecmp(h.url, fe_agg_string, 
				       strlen(fe_agg_string)) != 0) &&*/

    if ( is_server_url(h.url)==gm_False &&
d277 2
a278 5

	/*if (*h.url == '/' || 
	    strncasecmp(h.url, fe_agg_string, strlen(fe_agg_string)) == 0) {*/

	if (is_server_url(h.url)==gm_True) {
@


1.47
log
@Logging now works!  yaaay.
@
text
@d217 1
a217 1
    content_type = get_header_value(DistillerBufferData(&h.svr_hdrs),
d246 1
a246 1
                    (int)DistillerBufferLength(&h.pxy_hdrs) - 1);
d261 24
a284 1
      complete_bypass(&h);
d286 1
a286 1

@


1.46
log
@*** empty log message ***
@
text
@a63 1
  
d71 2
a72 1
  INST_init_loginfo(&lo);
d291 1
a291 1
    MD5_CTX   theHash;
d305 4
@


1.45
log
@.
@
text
@d326 1
a326 1
  struct sockaddr a;
@


1.44
log
@fixed much badness reported by purify
@
text
@a326 1
  struct sockaddr_in *ap = (struct sockaddr_in *)&a;
d334 1
a334 1
  return ((userkey)(ap->sin_addr.s_addr));
@


1.43
log
@Incorporated wingman protocol directly into the frontend.
@
text
@d246 2
a247 1
                    (int)DistillerBufferLength(&h.pxy_hdrs));
@


1.42
log
@reintegrated from branch fox-dev; bug remaining in dispatch.c which should always return a DistillerStatus and not an HTTP_Status
@
text
@d129 1
a129 1
    char *demagicURL = ALLOCA(strlen(h.url));
d186 2
a187 1
    proxy_debug_3(DBG_HTTP, "Tunneling '%s'", h.cli_hdrs.mime_headers);
d302 1
a302 1
             "%lu %lu \"%s\" %d %ld %ld\n",
@


1.41
log
@fixed TACCutils bug that sometimes caused next_entity to enter infinite
loop.  beginning frontend cleanup to separate service-specific stuff
from core stuff.  ifdef'd out the instrumentation code in
httpsupport.c:parse_status_and_headers, which was likely causing
segfaults.  removed sbrk() monitoring from thr_mon.c because it was
bogus.  tested the Bypass feature for big pages (it works) and set
bypass threshold to about 1.5MB in clib.h.  monitor window is now
resizable though not all the fields resize intelligently.
@
text
@d3 3
a5 3
 *  The code to handle and dispatch an incoming HTTP request is here.
 *  This file defines a function called http_go_proc that is called when
 *  a thread grabs a task off the queue.  The argument is the task structure.
d8 1
a8 2
#include "proxy.h"
#include "thr_cntl.h"
d10 2
a11 5
#include "httpreq.h"
#include "proxyinterface.h"
#include "clib.h"
#include "changepref.h"
#include "getprefs.h"
d14 1
d18 2
a19 1
#include "utils.h"
a20 2

#ifdef INST
d22 1
a22 5
#endif /* INST */

static int parse_status_and_headers(struct http_headers *hp, int sock,
                                    struct loginfo *l,
                                    ts_strtok_state *ts_st);
d24 1
a24 1
extern gm_Bool parse_and_change_prefs(struct http_headers *hp, int sock);
a42 1
  int sock = (int)(TASK_DATA(t));
d44 1
a44 4
  struct http_headers h;
  struct http_headers *hp = &h;
  size_t headerlen;
  char *demagicURL = NULL;
d47 8
a54 1
  ts_strtok_state *ts = NULL;
a55 1
#ifdef LOGGING
d60 1
a60 2
   *  setup a structure to  hold headers.
   *  PERF::this should not use malloc()
d62 4
a65 8

  /*  h = SAFEMALLOC(1, struct http_headers); */

  inst_begin_timestamp(index);
  INST_SET_SIZE(index,0);
  init_loginfo(&lo);
  assert(hp);
  headerlen = sizeof(HeaderData);
d67 7
a76 3
  inst_set_thread_state(index, THR_ACCEPTED);
  INST_TIMESTAMP(index, m_arrival);

d78 11
a88 6
    hp->len = readline_or_timeout(sock, hp->header_data, &headerlen,
                                  READ_ALL_HEADERS);
    INST_TIMESTAMP(index, m_headersdone);
    if (hp->len == -1) {
      /* client request timed out! */
      goto GOPROC_NOSTRTOK_RETURN;
d92 1
d96 2
a97 1
    strncpy(hp->header_data, TASK_METADATA(t), PERF_HTTP_TOTAL_HEADERLEN-1);
d99 1
a101 3

  ts = ts_strtok_init(hp->header_data);

d103 6
a108 3
  if (parse_status_and_headers(hp,sock,&lo,ts) == -1) {
    /* error parsing request */
    goto GOPROC_RETURN;
d112 1
a112 1
   *  We have a reasonable looking request.  Get prefs
d115 1
a115 1
  k = userkey_from_sock_ipaddr(sock);
d123 1
d125 8
a132 7
  if (is_magic ((char *) hp->url)) {
    /* demagicifing a url will never lengthen it so this is a good */
    /* upper bounds on the length of the non magical url           */
    demagicURL = ALLOCA(strlen(hp->url));
    from_magic((char *) hp->url, demagicURL, &prefs);
    /* ugh... */
    hp->url = demagicURL;
d135 17
d155 1
a155 1
  if (is_setpref_url(hp->url)) {
d158 1
d160 30
a189 6
    parse_and_change_prefs(hp, sock);
  } else if (is_getpref_url(hp->url)) {
    /* - gimme my prefs*/
    send_prefs(&prefs, sock);
  } else if (strcasecmp(hp->method, "get") == 0
             || strcasecmp(hp->method, "post") == 0) {
d195 2
a196 3
    int i;

    i = prefs.nargs;
d198 1
a198 4
    SET_ARG_INT(prefs.arg[i], (INT32) k);
    SET_ARG_ID(prefs.arg[i], FRONT_CLIENT_IP);
    proxy_dispatch(hp, &prefs, &lo, t);
  } else {
d200 8
a207 1
     *  bypass
d209 60
a268 4
    proxy_debug_3(DBG_HTTP, "Bypassing '%s'", hp->header_data);
    inst_set_thread_state(index, THR_DISTILLERSEND);
    bypass(hp->header_data, hp->len, sock);
  }
d271 4
a274 5
GOPROC_RETURN:
  ts_strtok_finish(ts);
GOPROC_NOSTRTOK_RETURN:
  INST_TIMESTAMP(index, m_wbdone);
  inst_end_timestamp(index);
d278 1
a278 1
    close(sock);
d310 1
d312 6
a317 8
 *  Given an http_headers structure returned as a result of reading a
 *  client request, parse out the status line and other interesting
 *  information from the request and perform minimal validation.
 *  If parse errors are encountered, report the error directly back to
 *  the user on the incoming socket.
 *  If successful, sets the hp->url and hp->header fields to be pointers
 *  into the hp->header_data field, and sets hp->version to one of a
 *  small number of "bins" of HTTP version (<=0.9, >=1.0 for now).
a318 11
 *  ARGS:
 *    i/o: http_headers structure; various fields get filled in
 *    i: socket on which request was received, in case error must be
 *      reported.
 *  RETURNS:
 *    -1 if error, any other value means success.
 *  ASSUMPTIONS:
 *    http_headers structure contains complete verbatim client request,
 *  including HTTP status line, all headers, and separator blank line
 *  (two CRLF's in a row) at end.
 *    sock is an open, writable filedescriptor back to client.
d320 3
a322 3
static int
parse_status_and_headers(struct http_headers *hp, int sock, struct loginfo *l,
                         ts_strtok_state *ts_st)
d324 8
a331 46
  char *vers;
  int result = -1;
#ifdef LOGGING
  int bytesremaining = sizeof(l->url) - 2;
#endif /* LOGGING */

  /*
   *  Point to the beginning of the actual headers (i.e. skipping past
   *  the HTTP status line and its terminating crlf).
   */
  hp->header = strchr((const char *)hp->header_data, '\n');
  if (hp->header)
    hp->header++;              /* skip to character after newline */

  /*
   *  Sanity check request line only, for HTTP/0.9 or HTTP/1.x
   *  compliance.  Collect version number, method, and URL.
   */

  if ((hp->method = ts_strtok(" ", ts_st)) == NULL) {
    /* zero tokens on line!    */
    http_error_return(sock, HTTP_VERSION_UNKNOWN,
                      HTTP_ERR_MALFORMED_REQUEST, hp->header_data);
    goto PARSE_DONE;
  }
  
#ifdef LOGGING
  if (bytesremaining > 2) {
    strncat(l->url, hp->method, bytesremaining-1);
    bytesremaining = sizeof(l->url) - strlen(l->url);
    if (bytesremaining > 0) {
      strcat(l->url, " ");
      bytesremaining--;
    }
  }
#endif /* LOGGING */

  /*
   *  Get URL
   */

  if ((hp->url = ts_strtok(" ", ts_st)) == NULL) {
    /* only one token on line!    */
    http_error_return(sock, HTTP_VERSION_UNKNOWN,
                      HTTP_ERR_MALFORMED_REQUEST, hp->header_data);
    goto PARSE_DONE;
d333 1
a333 48

  /*
   *  If URL begins with a slash, discard the slash.  This is to allow
   *  mechanisms like "http://foo.bar.com/http://real.page.com/" to work (for
   *  proxy chaining, etc.)
   */
  while (hp->url[0] == '/')
    hp->url++;

#ifdef LOGGING
  if (bytesremaining > 2) {
    strncat(l->url, hp->url, bytesremaining-1);
    bytesremaining = sizeof(l->url) - strlen(l->url);
    if (bytesremaining > 0) {
      strcat(l->url, " ");
      bytesremaining--;
    }
  }
#endif /* LOGGING */
  
  if ((vers = ts_strtok(" \r\n", ts_st)) == NULL) {
    /* must be HTTP 0.9 or earlier */
    hp->version = HTTP_VERSION_09_OR_EARLIER;
  } else if (strncasecmp(vers, "HTTP/", 5) != 0) {
    /* this token looks bogus... */
    http_error_return(sock, HTTP_VERSION_UNKNOWN,
                      HTTP_ERR_MALFORMED_REQUEST, hp->header_data);
    goto PARSE_DONE;
  } else {
    /* got a token, and it begins with "HTTP/".  Should really parse out
     * the version, but for now... what the hey.
     */
    hp->version = HTTP_VERSION_10_OR_LATER;
  }

#ifdef LOGGING
  if (bytesremaining > 2) {
    strncat(l->url, vers, bytesremaining-1);
  } else {
    l->url[strlen(l->url)-1] = '\0';
  }
#endif /* LOGGING */
  
  result = 0;
PARSE_DONE:
  /* DO NOT RELEASE the ts_st buffer - that's the callers job.*/
  /* looks OK. */
  return(result);
@


1.41.4.1
log
@armandos development version for rebuilding the frontend - do not use
@
text
@d3 3
a5 3
 *  This file contains the HTTP request handling code that defines the
 *  TranSend distillation web proxy.  It corresponds to the TranSend Service
 *  layer in the layered SNS model.
d8 4
d14 2
a15 4
#include "frontend.h"
#include "debug.h"
#include "comm_http.h"
#include "userpref.h"
a17 1
#include "utils.h"
d21 2
d24 1
a24 2
#ifdef LOGGING
#include "md5.h"
d26 5
a30 1
#endif /* LOGGING */
d32 1
a32 1
static userkey userkey_from_sock_ipaddr(int sock);
d51 1
d53 4
a56 1
  Request h;
d59 2
a60 1
  HTTP_Status result;
a61 1
  struct loginfo lo;
d66 2
a67 1
   *  New task data should be the request structure.
d69 8
a76 4
  init_Request(&h);
  h.cli_fd = (int)TASK_DATA(t); /* socket FD of client */
  
  SET_TASK_DATA(t,&h);
a77 7
  INST_begin_timestamp(index);
  INST_set_size(index,0);
  INST_set_thread_state(index, THR_ACCEPTED);
  INST_timestamp(index, m_arrival);
#ifdef LOGGING
  INST_init_loginfo(&lo);
#endif /* LOGGING */
d81 3
d85 6
a90 10
    int result;
    
    assert( DistillerBufferAlloc(&h.cli_hdrs, PERF_HTTP_TOTAL_HEADERLEN)
            == gm_True);

    result = readline_or_timeout(&h, READ_ALL_HEADERS, NULL);

    INST_timestamp(index, m_headersdone);
    if (result == -1) { /* client request timed out, or error reading hdrs */
      goto GOPROC_RETURN;
a93 1
#ifdef NEWFE
d97 1
a97 1
    strncpy(h.cli_hdrs.mime_headers, TASK_METADATA(t), PERF_HTTP_TOTAL_HEADERLEN-1);
a98 1
#endif /* NEWFE */
d101 3
d105 1
a105 4
  result = parse_status_and_headers(&h);
  if (result != HTTP_NO_ERR) {
    /* BUG:: last arg of http_error_return should be a substitution arg */
    http_error_return(&h, result);
d111 1
a111 1
   *  We have a reasonable looking request.  Get prefs for this user.
d114 1
a114 1
  k = userkey_from_sock_ipaddr(h.cli_fd);
d123 2
a124 2
  if (is_magic ((char *) h.url)) {
    /* demagifying a url will never lengthen it so this is a good */
d126 4
a129 4
    char *demagicURL = ALLOCA(strlen(h.url));
    assert(demagicURL);
    strcpy(demagicURL, h.url);
    from_magic((char *) demagicURL, h.url, &prefs);
d135 1
a135 1
  if (is_setpref_url(h.url)) {
d139 6
a144 6
    parse_and_change_prefs(&h);
  } else if (is_getpref_url(h.url)) {
    /* gimme my prefs*/
    send_prefs(&prefs, h.cli_fd);
  } else if (strcasecmp(h.method, "get") == 0
             || strcasecmp(h.method, "post") == 0) {
d150 3
a152 2
    SET_ARG_INT(prefs.arg[prefs.nargs], (INT32) k);
    SET_ARG_ID(prefs.arg[prefs.nargs], FRONT_CLIENT_IP);
d154 3
a156 5
    result = proxy_dispatch(&prefs, t);
    if (result != HTTP_NO_ERR) {
      http_error_return(&h, result);
    }
    free_Request(&h);
d161 3
a163 3
    proxy_debug_3(DBG_HTTP, "Bypassing '%s'", h.cli_hdrs.mime_headers);
    INST_set_thread_state(index, THR_DISTILLERSEND);
    bypass(&h);
d168 4
a171 2
  INST_timestamp(index, m_wbdone);
  INST_end_timestamp(index);
d175 1
a175 1
    close(h.cli_fd);
a177 2
  free_Request(&h);

a206 1

d208 8
a215 6
 *  userkey_from_sock_ipaddr: make incoming IP address into a user prefs
 *  key, so we can look up user in prefs database
 *
 *  ARGS: socket (filehandle)
 *  REENTRANT: as safe as getpeername()
 *  RETURNS: userkey; the "null key" if conversion fails
d217 11
d229 9
d239 81
a319 11
static userkey
userkey_from_sock_ipaddr(int s)
{
  struct sockaddr a;
  struct sockaddr_in *ap = (struct sockaddr_in *)&a;
  int alen = sizeof(a);

  memset(&a, 0, alen);
  if (getpeername(s, (struct sockaddr *)&a, &alen) != 0) {
    proxy_errlog_2("userkey_from_sock_ipaddr: %s", strerror(errno));
    return USERKEY_NULL;
d321 7
a327 1
  return ((userkey)(ap->sin_addr.s_addr));
@


1.41.4.2
log
@*** empty log message ***
@
text
@d148 1
a148 1
    result = server_dispatch(&prefs, t);
a149 1
      /* transport level error: wrap in HTML for delivery to user */
a150 8
    } else if (hp->svr_http != 200) {
      /* HTTP (application-level) error: bypass result to user */
      INST_set_thread_state(index, THR_WRITEBACK);
      complete_bypass(sock, &dat);
    } else {
      /* all is well: continue by dispatching to a worker for distillation */
      result = proxy_dispatch(&prefs, t);
      @@@@@@@@ switch on result here @@@@@@@@
@


1.41.4.3
log
@*** empty log message ***
@
text
@d8 2
a49 6
  DistillerStatus dist_result;
  const char *content_type;
  Argument *arg;
  int thresh;
  gm_Bool no_distill = gm_False;
  gm_Bool is_text_html = gm_False;
d83 1
a83 1
      goto HTTPGO_FINISH;
d102 1
a102 1
    goto HTTPGO_FINISH;
a126 14
  /* determine the threshold for bypassing */
  arg  = getArgumentFromIdInList(&prefs, FRONT_MTU);
  thresh = (arg == NULL ? PERF_FRONT_MTU : ARG_INT(*arg));

  /* determine if distillation is turned off for this
     request. EXCEPTION: Force distillation for Prefs html form. */
  arg = getArgumentFromIdInList(&prefs, FRONT_NO_DISTILL);
  if (arg != NULL
      && ARG_INT(*arg)
      && strcasecmp(fe_get_prefs_url, h.url) != 0)
    no_distill = gm_True;
  else
    no_distill = gm_False;
  
d134 1
a134 7
    result = parse_and_change_prefs(h.url, k, h.errmsg);
    if (result == HTTP_NO_ERR) {
      correct_write(h.cli_fd, "HTTP/1.0 200\r\nContent-type: text/html\r\n\r\n", -1);
      correct_write(h.cli_fd, "<html><head><title>Your preferences have been set</title></head><body><center><h1>Preferences set</h1><p>Your new preferences have been set.  Press the back button twice to resume browsing.</p></center></body></html>", -1);
    } else {
      http_error_return(&h, result);
    }
d138 2
a139 11
  } else if (strcasecmp(h.method, "get") != 0
             && strcasecmp(h.method, "post") != 0) {
    /*
     *  Doesn't appear to be an HTTP GET or POST request; so act as a
     *  "dumb tunnel" for passing the request to the server (actually, via
     *  the cache) and relaying the result to the client.
     */
    proxy_debug_3(DBG_HTTP, "Tunneling '%s'", h.cli_hdrs.mime_headers);
    INST_set_thread_state(index, THR_DISTILLERSEND);
    tunnel(&h);
  } else {
a148 10
    /*
     *  If we get a transport-level error (i.e. fetch from cache failed
     *  due to an internal cache error), wrap the error in HTML (if
     *  needed) and return error to user.
     *  Otherwise, if the transaction succeeded but the server return
     *  code indicates failure (i.e. != 200),  **OR** if the server data
     *  is smaller than a threshold size, bypass the server data
     *  directly to the client.
     *  Otherwise, attempt to distill.
     */
d152 2
a153 14
      goto HTTPGO_FINISH;
    }

    content_type = get_header_value(DistillerBufferData(&h.svr_hdrs),
                                    "content-type", NULL, NULL, NULL);
    if (content_type == NULL)
      content_type = "application/octet-stream";
    is_text_html = (strncasecmp(content_type, "text/html", 9) == 0);
    
    if ((h.svr_http_status != 200)
        || (is_text_html == gm_False
            && DistillerBufferLength(&h.svr_data) <= thresh)
        || (no_distill == gm_True)) {
      /* bypass server data directly to user */
d155 5
a159 2
      complete_bypass(&h);
      goto HTTPGO_FINISH;
d161 9
a169 29
    
    /* all is well: continue by dispatching to a worker for distillation */
    dist_result = proxy_dispatch(&prefs, t);
    switch(dist_result) {
    case distOk:
      INST_timestamp(index, m_wbstart);
      correct_write(h.cli_fd, (char *)DistillerBufferData(&h.pxy_hdrs),
                    (int)DistillerBufferLength(&h.pxy_hdrs));
      correct_write(h.cli_fd, (char *)DistillerBufferData(&h.pxy_data),
                    (int)DistillerBufferLength(&h.pxy_data));
      INST_timestamp(thrindex, m_wbdone);
      break;

    case distDistillerNotFound:
    case distLaunchTimeout:
    case distBadInput:
    case distConnectionBroken:

      /* forward original if distiller for this type not found, connection
         repeatedly broken, or couldn't be launched */
      complete_bypass(&h);
      break;

    default:
        
      http_error_return(&h, HTTP_ERR_UNSPECIFIED);
      break;
    } /* switch(dist_result) */
  } /* if...else...else...endif */
d172 1
a172 2
HTTPGO_FINISH:
  free_Request(&h);
d180 2
@


1.41.4.4
log
@*** empty log message ***
@
text
@d202 1
a202 2
    is_text_html = (strncasecmp(content_type, "text/html", 9) == 0
                    ? gm_True : gm_False);
@


1.41.4.5
log
@a huge amount of frontend reengineering, plus added a Clone() method to
the DistillerBuffer.  basic operation of frontend seems stable.
things that haven't been tested yet:
- POST
- cache cut through behavior
- client timeout doesn't seem to work (never times out??)
- redispatch and similar support for aggregators
and some things still to be implemented:
- support for listening/dispatching on multiple ports
- documentation of what all the files do (and rename the http-specific
sourcefiles)
- eliminate redundant .h inclusions from various sourcefiles
- 'makedepend' for the Makefile.in
@
text
@a86 1
      /* TC::1 client timeout, or request doesn't sanity check */
d95 1
a95 2
    strncpy(h.cli_hdrs.mime_headers, TASK_METADATA(t),
            PERF_HTTP_TOTAL_HEADERLEN-1);
a103 1
    /* TC::2 parse_status_and_headers returns an error */
d105 1
a120 1
   *  TC::3 url is magic vs nonmagic
d123 2
a124 3
    /* demagifying a url will never lengthen it so this is a good 
     * upper bounds on the length of the non magical url
     */
d136 1
a136 2
   * request. EXCEPTION: Force distillation for Prefs html form.
   */
d140 1
a140 2
      && strcasecmp(fe_get_prefs_url, h.url) != 0) {
    /* TC::4 no_distill is set */
d142 1
a142 1
  }  else {
a143 1
  }
a150 1
     * TC::5 is_setpref_url returns true
d154 2
a155 9
      /* TC::5.1 setpref url succeeds in setting prefs */
      correct_write(h.cli_fd, "HTTP/1.0 200\r\nContent-type: text/html\r\n\r\n",
                    -1);
      correct_write(h.cli_fd,
                    "<html><head><title>Preferences Set</title></head>"
                    "<body><center><h1>Preferences set</h1>"
                    "Your new preferences have been set.  Press the back "
                    "button twice to resume browsing."
                    "<p></center></body></html>", -1);
a156 1
      /* TC::5.2 setpref url fails in setting prefs */
d160 1
a160 1
    /* TC::6 gimme my prefs*/
a168 1
    /* TC::7 tunnel */
a193 1
      /* TC::8 server_dispatch returns transport level error */
d200 1
a200 2
    if (content_type == NULL) {
      /* TC::9 content-type can't be deduced */
a201 1
    }
a208 3
      /* TC::10.1 bypass because non-200s status */
      /* TC::10.2 bypass because not text/html and too small to distill */
      /* TC::4 bypass because no_distill is set */
a218 1
      /* TC::11 distillation succeeded */
a233 1
      /* TC::12 bypass because distillation failed */
a238 1
      /* TC::13 some other distillation error */
@


1.40
log
@evil bug in parse_status_and_headers was overwriting caller stack and
causing coredumps....we flushed it out of hiding by forcing everything
to bypass.  still need to test steve's changes and retrofit the new
mechanism for dealing with push.jpg.
@
text
@d24 1
d26 1
d61 1
a61 1
#ifdef INST
d63 1
a63 1
#endif /* INST */
d115 1
d117 1
d147 2
a149 3

    /* Add in the client's IP address as an INT32 argument so that
       the distiller driver can get at it. */
d162 1
d178 1
a178 1
#ifdef INST
d203 1
a203 1
#endif /* INST */
d235 1
d237 2
a238 1
  
d259 1
d268 1
d289 1
d298 2
a299 1

d315 1
d321 2
a322 1

@


1.39
log
@temporary commit so anthony can make; still tracking memory bug interaction frontend/clientlib
@
text
@d82 1
a82 1
  if (1||TASK_METADATA(t) == NULL) {
a131 1

a138 1

a153 1

d231 1
a231 1
  int bytesremaining = sizeof(l->url) - 1;
d255 1
a255 1
    bytesremaining -= strlen(hp->method);
d283 1
a283 1
    bytesremaining -= strlen(hp->url);
d306 1
a306 1
    strncat(l->url, vers, bytesremaining);
d308 1
a308 1
    l->url[strlen(l->url)] = '\0';
@


1.38
log
@debugging/monitoring function interface in frontend cleaned up.  change to xs/Makefile.PL.in to avoid spurious double initialization of stuff in libdist.a when clib.so was dynamically loaded.
@
text
@d30 2
d82 1
a82 1
  if (TASK_METADATA(t) == NULL) {
d140 1
d156 1
@


1.37
log
@merged changes from head of transend-beta branch
@
text
@a46 3
#ifdef FORBID
  extern gm_Bool check_forbidden(int socket, userkey k);
#endif /* FORBID */
d57 3
a125 11
#ifdef FORBID
  /*
   *  Check for access allowed
   */
  if (is_allowed(sock, k) != gm_True) {
    http_error_return(sock, HTTP_VERSION_10_OR_LATER,
                      HTTP_ERR_ACCESS_DENIED, hp->url);
    goto GOPROC_RETURN;
  }
#endif /* FORBID */

d172 2
d191 6
a196 4
    gm_log("%lu %lu \"%s\" %d %ld %ld\n",
	   res,
	   lo.date, lo.url,
	   lo.http_response, lo.size_before, lo.size_after);
d198 1
a198 1
  
@


1.36
log
@changes for dataflow stuff, chaining stuff, aggregators
@
text
@d15 1
a139 1

d146 3
a148 1
    
@


1.35
log
@a
@
text
@d46 3
d79 16
a94 2
  hp->len = readline_or_timeout(sock, hp->header_data, &headerlen,
                                READ_ALL_HEADERS);
a95 7
  INST_TIMESTAMP(index, m_headersdone);

  if (hp->len == -1) {
    /* client request timed out! */
    goto GOPROC_NOSTRTOK_RETURN;
    /* NOTREACHED */
  }
d125 11
d146 1
a146 1

d176 5
a180 1
  close(sock);
@


1.34
log
@Added IP address as a INT32 argument so that distiller queue can pull
it out.
@
text
@d139 1
@


1.33
log
@added ians hack to make chaining work
@
text
@d131 8
@


1.33.2.1
log
@L0 works; sending and registering encrypted URLs works
@
text
@a15 1
#include "crypt.h"
a24 1
#ifdef FRONTEND_LOGGING
a27 6
#else
static int parse_status_and_headers(struct http_headers *hp, int sock,
                                    ts_strtok_state *ts_st);
#endif

static int get_taz(struct http_headers *hp);
a54 2
  unsigned char *startcrypt;
#ifdef FRONTEND_LOGGING
a55 1
#endif
a65 1
#ifdef FRONTEND_LOGGING
a66 1
#endif
a88 1
#ifdef FRONTEND_LOGGING
a93 7
#else
  /* parse the headers and request line */
  if (parse_status_and_headers(hp,sock,ts) == -1) {
    /* error parsing request */
    goto GOPROC_RETURN;
  }
#endif
a94 25
  /* Here's where we may have to decrypt the URL */
  startcrypt = NULL;
  if (!strncasecmp(hp->url, "http://!/", 9)) {
    startcrypt = (unsigned char *)hp->url+9;
  } else if (!strncasecmp(hp->url, "!", 1)) {
    startcrypt = (unsigned char *)hp->url+1;
  }
  if (startcrypt) {
    UINT32 len = strlen((char *)startcrypt);
    UINT32 decryptlen;
    int res;
    unsigned char *decryptbuf;
    /* Allocate a buffer for the uudecode-like string */
    decryptlen = 2*len + 8;
    decryptbuf = ALLOCA(decryptlen);
    res = url_decrypt(startcrypt, decryptbuf, len);
    if (res < 0) {
	goto GOPROC_RETURN;
    }
    hp->url = (char *)decryptbuf;
    hp->secret = 1;
  }

  get_taz(hp);

d99 1
a99 2
  k = userkey_from_sock_ipaddr_and_headers(sock,hp);
#ifdef FRONTEND_LOGGING
a100 1
#endif
a101 2

#if 0
a113 1
#endif
d119 1
a119 1
  if (is_setpref_request(hp)) {
a130 20

    /* Here's where we change foo.taz into whatever */
    if (hp->tazhost && hp->taztrail) {
	/* Look for the MAPTAZ preference */
	int i;
	for(i=0; i<prefs.nargs; ++i) {
	    if (ARG_ID(prefs.arg[i]) == FRONT_MAPTAZ &&
		prefs.arg[i].type == typeString) {
		/* Construct the new URL */
		char *maptaz = ARG_STRING(prefs.arg[i]);
		hp->url = ALLOCA(7 + strlen(maptaz) + strlen(hp->taztrail) + 1);
		strcpy(hp->url, "http://");
		strcat(hp->url, maptaz);
		strcat(hp->url, hp->taztrail);
		break;
	    }
	}
    }

#ifdef FRONTEND_LOGGING
a131 3
#else
    proxy_dispatch(hp, &prefs, t);
#endif
a146 1
#ifdef FRONTEND_LOGGING
a168 1
#endif
a194 1
#ifdef FRONTEND_LOGGING
a197 5
#else
static int
parse_status_and_headers(struct http_headers *hp, int sock,
                         ts_strtok_state *ts_st)
#endif
a200 1
#ifdef FRONTEND_LOGGING
a201 1
#endif
a222 1
#ifdef FRONTEND_LOGGING
a230 1
#endif
a250 1
#ifdef FRONTEND_LOGGING
a258 1
#endif
a274 1
#ifdef FRONTEND_LOGGING
a279 6
#endif

  hp->tazhost = NULL;
  hp->tazhostlen = 0;
  hp->taztrail = NULL;
  hp->secret = 0;
a287 30
static int
get_taz(struct http_headers *hp) {
  /* Now see if the URL we got was one of our "special" ones */
  if (!strncasecmp(hp->url, "http://", 7)) {
    char *dottaz = strcasestr(hp->url+7, ".taz/");
    char *slash = strchr(hp->url+7, '/');
    int l = strlen(hp->url);

    /* Just in case the URL is like "http://foo.taz" (no trailing /) */
    if (!dottaz && !slash && l >= 4 && !strcasecmp(hp->url+l-4, ".taz")) {
	dottaz = hp->url+l-4;
	slash = hp->url+l;
    }

    if (dottaz && slash && dottaz < slash) {
	int i;
	hp->tazhost = hp->url+7;
	hp->tazhostlen = slash - hp->tazhost;
	hp->taztrail = slash;
	hp->secret = 1;
	for(i=0;i<hp->tazhostlen;++i) {
	    if (hp->tazhost[i] >= 'A' && hp->tazhost[i] <= 'Z') {
		hp->tazhost[i] += 'a'-'A';
	    }
	}
	return 1;
    }
  }
  return 0;
}
@


1.33.2.2
log
@Type 1-style rewebber
@
text
@d151 1
d160 1
a160 3
    if (!from_magic((char *) hp->url, demagicURL, &prefs)) {
	goto GOPROC_RETURN;
    }
d164 1
@


1.33.2.3
log
@working copy (?)
@
text
@d24 2
d139 1
a139 5
  if (get_taz(hp) < 0) {
    http_error_return(sock, hp->version,
	 HTTP_ERR_MALFORMED_REQUEST, "The requested URL was disallowed.\n");
    goto GOPROC_RETURN;
  }
a407 1
	if (strstr(hp->taztrail, "/..")) return -1;
@


1.32
log
@distiller chaining is alive sort of
@
text
@d232 4
d242 8
@


1.31
log
@More...
@
text
@d23 1
a23 2
char magicKey[] = "aa883fd833ef";
int  magicKeyLen = 12;
d158 1
a158 1
    MD5Update(&theHash, magicKey, magicKeyLen);
@


1.31.2.1
log
@added support for getprefs url
@
text
@a14 1
#include "getprefs.h"
d119 1
d126 1
a126 3
  } else if (is_getpref_url(hp->url)) {
    /* - gimme my prefs*/
    send_prefs(&prefs, sock);
@


1.30
log
@fixed byte-count bug in logging code
@
text
@d150 3
d154 1
a154 1
  if (((UINT32) k) != ((UINT32) 0x7F000001)) {
@


1.29
log
@Client anonymization now works.
@
text
@d199 1
d221 8
a228 2
  strncat(l->url, hp->method, sizeof(l->url)-2);
  strcat(l->url, " ");
d237 8
a244 2
  strncat(l->url, hp->url, sizeof(l->url)-strlen(l->url)-2);
  strcat(l->url, " ");
d261 5
a265 1
  strncat(l->url, vers, sizeof(l->url)-strlen(l->url)-1);
@


1.28
log
@More fixes - now won't log the fe_check.tcl accesses. (which appear
as 127.0.0.1)
@
text
@d21 4
a56 1
  unsigned long a, b, c, d;
d151 13
a163 7
  a = (UINT32) k >> 24;
  b = ((UINT32) k >> 16) & 0xff;
  c = ((UINT32) k >> 8) & 0xff;
  d = ((UINT32) k) & 0xff;
  if (!((a == 127) && (b == 0) && (c == 0) && (d == 1))) {
    gm_log("%lu.%lu.%lu.%lu %lu \"%s\" %d %ld %ld\n",
	   a, b, c, d,
@


1.27
log
@added logging, which also resulted in shuffling around a lot of .h files and what goes into each
@
text
@d53 1
d148 10
a157 5
  gm_log("%lu.%lu.%lu.%lu %lu \"%s\" %d %ld %ld\n",
         (UINT32)k>>24, ((UINT32)k>>16)&0xff,
         ((UINT32)k>>8)&0xff, (UINT32)k & 0xff,
         lo.date, lo.url,
         lo.http_response, lo.size_before, lo.size_after);
@


1.26
log
@moved POST logic into proxy_dispatch - just as steve said, much simpler this way
@
text
@d9 2
d23 1
d52 2
a53 1

d63 1
d86 2
a87 1
  if (parse_status_and_headers(hp,sock,ts) == -1) {
d97 1
d128 1
a128 1
    proxy_dispatch(hp, &prefs, sock, t);
d144 9
d179 1
a179 1
parse_status_and_headers(struct http_headers *hp, int sock,
d205 2
d215 4
a218 1
  if ((vers = ts_strtok(" ", ts_st)) == NULL) {
d232 2
@


1.25
log
@POST works, though logic is ugly and should be moved mostly into proxy_dispatch
@
text
@d116 2
a117 3
  } else if (strlen(hp->method) == 3
             &&  strncasecmp(hp->method, "get", 3) == 0) {
    
d119 1
a119 1
     *  It's not a special URL, and the request appears to be a GET.
a121 23
  } else if (strlen(hp->method) == 4
             &&  strncasecmp(hp->method, "post", 4) == 0) {
    /*
     *  Handle a POST request. This is a pain in the ass.  Note we still need
     *  to pass user prefs, in case (e.g.) anonymization is desired.
     */
    clib_data dat;
    HTTP_Status result;
    extern void complete_bypass(int, clib_data *);
    /*
     *  BUG::the POST stuff really should be inside proxy_dispatch, which would
     *  avoid this file having to see a lot of stuff that normally is static
     *  there. 
     */
    
    if ((result = do_post(hp, &prefs, sock, t, &dat)) == HTTP_NO_ERR) {
      /* post appears to succeed, so bypass results back to client */
      /*      bypass(hp->header_data, hp->len, sock); */
      complete_bypass(sock, &dat);
    } else  {
      /* post failed! report error to client */
      http_error_return(sock, hp->version, result, "??");
    }
@


1.24
log
@fixed memory leak due to strtok_finish not being called, and signal handling so frontend now dies gracefully
@
text
@d11 1
d49 1
a49 1
  
d68 2
a69 1
  hp->len = readline_or_timeout(sock, hp->header_data, &headerlen);
a105 1
   *  - "send me the prefs change page" URL
d109 1
a109 5
  if (is_changepref_url(hp->url)) {

    send_change_prefs_page(k, &prefs, sock);

  } else if (is_setpref_url(hp->url)) {
d123 23
@


1.23
log
@Added "loadavg" instrumentation in thr_mon.c, though it doesn't really
work yet.  Broke out instrumentation into separate funcs for
readability.  minor bug fix (malloc -> alloca) in httpgo.c.  moved
monitor debugging macros from proxy.h into debug.h.  frontend now
bypasses original if size is below default threshold, or if distiller
cannot be launched.
@
text
@d19 2
a20 1
static int parse_status_and_headers(struct http_headers *hp, int sock);
d47 1
d77 3
a79 1
  if (parse_status_and_headers(hp,sock) == -1) {
d81 1
a81 1
    goto GOPROC_NOSTRTOK_RETURN;
d135 2
d167 2
a168 1
parse_status_and_headers(struct http_headers *hp, int sock)
a169 1
  ts_strtok_state *ts_st;
d171 1
a185 2
  ts_st = ts_strtok_init(hp->header_data);

d190 1
a190 1
    return(-1);
d198 1
a198 1
    return(-1);
d208 1
a208 1
    return(-1);
d216 3
d220 1
a220 1
  return(0);
@


1.22
log
@there could have been a case where very long magic urls would have led
to string buffers being overwritten.  Now the bufferes are dynamically
allocated so this won't happen
@
text
@d55 1
d93 1
a93 1
    demagicURL = (char *) malloc (strlen(hp->url));
a134 1
  free(demagicURL);
@


1.21
log
@added stuff to do timestamp monitoring at various interesting points in
a worker thread's lifetime.  also split out monitoring stuff into its
own file thr_mon.c.
@
text
@d43 1
a43 1
  char demagicURL[MAX_URL_SIZE];
d90 3
d134 1
@


1.20
log
@moved the FRONT_NO_DISTILL checking to proxy_dispatch in dispatch.c
from http_go_proc in httpgo.c
@
text
@d39 1
d53 2
d57 1
d61 3
a63 2
  set_thread_state(TASK_THRINDEX(t), THR_ACCEPTED);
  proxy_debug_2(DBG_HTTP, "reading client headers");
d66 2
d128 2
@


1.19
log
@chages to httpgo to allow for FRONT_NO_DISTILL arg to work.
Changes to magic to put magic at the END of urls so it wirks with
reletive urls like those that would be found within a page.
@
text
@a108 1
     *  Check to see if you should distill the URL or not
d110 1
a110 11
    int dispatchP = 1;
    int i;
    for (i = 0; i<prefs.nargs; i++) {
      if (ARG_ID(prefs.arg[i]) == FRONT_NO_DISTILL && ARG_INT(prefs.arg[i]))
	  dispatchP = 0;
    }
    if (dispatchP) {
      proxy_dispatch(hp, &prefs, sock, t);
    } else {
      bypass(hp->header_data, hp->len, sock);     
    }
@


1.18
log
@restructured httpgo.c, added a new arg for MTU to frontend ARGS.h
@
text
@d13 1
d43 2
d73 16
a88 2
   *  We have a reasonable looking request.  Short-circuit the
   * following special  URL's:
a94 3
    ArgumentList prefs;
    userkey k = userkey_from_sock_ipaddr(sock);
    (void)get_userprefs(k, &prefs);
d109 1
d111 10
a120 11
    ArgumentList prefs;
    userkey k = userkey_from_sock_ipaddr(sock);
    (void)get_userprefs(k, &prefs);
    /*
     *  Extract any arguments embedded in the URL itself, and add them
     *  to the arg list.
     */
    if (is_magic ((char *) hp->url)) {
      from_magic((char *) hp->url, demagicURL, &prefs);
      /* ugh... */
      hp->url = demagicURL;
a121 1
    proxy_dispatch(hp, &prefs, sock, t);
@


1.17
log
@restructured httpgo.c, added a new arg for MTU to frontend ARGS.h
@
text
@a40 1
  char *method, *vers;
d90 3
a92 2
  } else if (strlen(method) == 3  &&  strncasecmp(method, "get", 3) == 0) {

d149 2
a150 1

d166 1
a166 1
  if ((method = ts_strtok(" ", ts_st)) == NULL) {
d172 1
@


1.16
log
@changes so that preferences are changed with an http://ChangePrefs
not by connecting to a seperate port
@
text
@d18 2
a41 1
  ts_strtok_state *ts_st;
d65 85
d169 1
a169 1
    goto GOPROC_RETURN;
d176 1
a176 1
    goto GOPROC_RETURN;
d186 1
a186 1
    goto GOPROC_RETURN;
d194 3
a196 37
  /*
   *  We have a reasonable looking line.  See if the URL is the
   *  designated "send user prefs form" URL.
   */

  if (is_changepref_url(hp->url)) {

    ArgumentList prefs;
    userkey k = userkey_from_sock_ipaddr(sock);
    (void)get_userprefs(k, &prefs);
    send_change_prefs_page(k, &prefs, sock);
  } else if (is_setpref_url(hp->url)) {
    
    /* 
     * handle what send user prefs form sends back.
     */

    parse_and_change_prefs(hp, sock);
  } else if (strlen(method) == 3  &&  strncasecmp(method, "get", 3) == 0) {
    /*
     *  handle "GET" request
     */
    ArgumentList prefs;
    userkey k = userkey_from_sock_ipaddr(sock);
    (void)get_userprefs(k, &prefs);
    if (is_magic ((char *) hp->url)) {
      from_magic((char *) hp->url, demagicURL, &prefs);
      hp->url = demagicURL;
    }
    proxy_dispatch(hp, &prefs, sock, t);
  } else {
    /*
     *  bypass
     */
    proxy_debug_3(DBG_HTTP, "Bypassing '%s'", hp->header_data);
    bypass(hp->header_data, hp->len, sock);
  }
a197 7
  /* all cases exit through this single exit point */
GOPROC_RETURN:
  ts_strtok_finish(ts_st);
GOPROC_NOSTRTOK_RETURN:
  close(sock);
  return (void *)0;
}
@


1.15
log
@now pass correct client headers to cache library
@
text
@d119 5
d125 1
@


1.14
log
@prefs.html has been moved from frontend/src/ to frontend/.  User prefs
form can now be obtained by visiting the URL "http://ChangePrefs".
doesn't matter if "No Proxy For" is set or not.  Mechanism works by
reading prefs.html file, so you can just change the file and reload and
you'll get the new form.  Added "changepref.h" and "changepref.c" to
contain the code that deals with receiving prefs change submissions and
serving the prefs change form.  Modified Makefile to include the new
files in the frontend make target.  Added function "send_content" (send
generic content using HTTP) to support this stuff, in httpsupport.c.
@
text
@d65 8
@


1.13
log
@fixed bugs found by purify run
@
text
@d11 1
d101 2
a102 2
   *  We have a reasonable looking line.  If the method is not GET,
   *  bypass the whole thing.
d105 8
a112 1
  if (strlen(method) == 3  &&  strncasecmp(method, "get", 3) == 0) {
@


1.12
log
@killed some warnings
@
text
@d88 1
d91 5
@


1.11
log
@demagicizes the magic urls and converts user arguments based on magic
@
text
@d105 2
a106 2
    if (is_magic (hp->url)) {
      from_magic(hp->url, demagicURL, &prefs);
@


1.10
log
@User prefs skeleton working
@
text
@d11 1
d40 1
d105 4
@


1.9
log
@thread state logging added to frontend
@
text
@d55 6
d70 2
a71 1
    http_error_return(sock, HTTP_UNKNOWN, HTTP_MALFORMED, hp->header_data);
d77 2
a78 1
    http_error_return(sock, HTTP_UNKNOWN, HTTP_MALFORMED, hp->header_data);
d84 1
a84 1
    hp->version = HTTP_09_OR_EARLIER;
d86 3
a88 2
    http_error_return(sock, HTTP_UNKNOWN, HTTP_MALFORMED, hp->header_data);
    hp->version = HTTP_10_OR_LATER;
d115 1
@


1.8
log
@End to end path works via dispatch.c, some error reporting still broken and some things still hardcoded that shouldn't be
@
text
@d51 1
d94 1
a94 1
    proxy_dispatch(hp, &prefs, sock);
@


1.7
log
@all the stubs work; now adding the dispatching functionality in newly
added dispatch.c
@
text
@d86 1
a86 1
  if (0 && strlen(method) == 3  &&  strncasecmp(method, "get", 3) == 0) {
d93 1
a93 1
    proxy_dispatch(hp, &prefs);
d99 1
a99 1
    bypass(hp, sock);
@


1.6
log
@*** empty log message ***
@
text
@d62 2
a63 2
    /* only one token on line!    */
    http_error_return(sock, hp->version, HTTP_MALFORMED, hp->header_data);
d69 1
a69 1
    http_error_return(sock, hp->version, HTTP_MALFORMED, hp->header_data);
d76 2
a77 1
  } else {
d90 4
a93 2
    fprintf(stderr, "Header len = %lu\nHeaders = '%s'", (UINT32)hp->len,
            hp->header_data);
d98 1
d102 1
d104 1
@


1.5
log
@http header parsing distinguishes http version and method. minor fixes to config files.
@
text
@a33 1
  int result;
d37 1
a37 1
  char *method, *url, *vers;
d52 1
a52 1
  result = readline_or_timeout(sock, hp->header_data, &headerlen);
d67 1
a67 1
  if ((url = ts_strtok(" ", ts_st)) == NULL) {
d85 1
a85 1
  if (strlen(method) == 3  &&  strncasecmp(method, "get", 3) == 0) {
d89 1
a89 1
    fprintf(stderr, "Header len = %d\nHeaders = '%s'", result,
d95 1
a95 1
    fprintf(stderr, "BYPASSING '%s'", hp->header_data);
@


1.4
log
@http parsing is breathing
@
text
@d13 2
d38 2
d55 35
a89 1
  if (result > 0) {
d92 5
d99 1
@


1.3
log
@Fixed so that Yatin's changes work.
@
text
@d8 3
a10 3
#include <proxy.h>
#include <httpreq.h>
#include <proxyinterface.h>
d19 2
a20 1
 *  ARGS: the task_t structure; its task_data field contains the file
d32 4
a35 13
  C_DistillerType type;
  Argument ar;
  userpref u;
  userkey uk;
  FILE *htmlfile;
  char filename[80];
  size_t inbufsize;
  UINT32 outbufsize;
  DistillerStatus status;
  ssize_t filenamelen;
  char inbuf[64000];
  char *outbuf;

d37 17
a53 30
  SET_DISTILLER_TYPE(type, "text/html");
  SET_ARG_ID(ar, 1);
  SET_ARG_STRING(ar, "foobar");

  /* read filename from the socket */
  filenamelen = 0;
  while (filenamelen < 80) {
    filenamelen += read(sock, (void *)(filename+filenamelen), 1);
    if ((filename[filenamelen-1] == '\n')
        || (filename[filenamelen-1] == '\r'))
      break;
  }
  filename[filenamelen-1] = '\0';
  proxy_debug_3(DBG_HTTP, "Filename is <%s>", filename);
  assert(htmlfile = fopen(filename, "r"));
  inbufsize = fread((void *)inbuf, sizeof(char), (size_t)64000, htmlfile);
  fclose(htmlfile);
  /* call html distiller */

  status = Distill(&type, &ar, 1, (void *)inbuf, (UINT32)inbufsize,
                   (void *)&outbuf, &outbufsize);

  proxy_debug_3(DBG_HTTP, "Distiller status = %d\n", (int)status);

  /* dump outbuf to a file */

  if (status == distOk) {
    assert(htmlfile = fopen("/tmp/foo", "w"));
    fwrite((void *)outbuf, sizeof(char), (size_t)outbufsize, htmlfile);
    fclose(htmlfile);
d56 1
a56 9
  /* get user preferences of this user, if possible. */

#if 0
  uk = userkey_from_sock_ipaddr(sock);
  u = get_userprefs(uk);

  fprintf(stderr, "User prefs bpp=%d\n", (int)(u->bpp));
#endif

@


1.2
log
@*** empty log message ***
@
text
@d64 1
a64 1
  status = Distill(type, &ar, 1, (void *)inbuf, (UINT32)inbufsize,
@


1.1
log
@configure script now generates include path automatically
@
text
@d10 3
d31 2
d35 9
d45 32
d85 1
@
