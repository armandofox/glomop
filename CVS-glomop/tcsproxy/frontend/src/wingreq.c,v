head	1.1;
access;
symbols
	Yatin-final:1.1
	Yatin:1.1.0.2
	pre-yatin-merge:1.1;
locks; strict;
comment	@ * @;


1.1
date	97.09.06.02.29.50;	author gribble;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Incorporated wingman protocol directly into the frontend.
@
text
@/*
 *  This is the front end that listens for wingman requests from the
 *  outside world.  It runs as a single thread.  When a request is
 *  received, it is placed on a work queue for other threads to grab.
 *  The queue length is periodically monitored to see if new threads
 *  should be spawned.
 */

#include "frontend.h"
#include "debug.h"
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include "utils.h"

/*
 *  Private declarations for this file
 */

static int wingSock;
static pthread_t thr_wing;

/*
 *  Forward declarations
 */

UINT32 n_wingreqs;
static ThrFunc wing_eventloop_proc;
ThrFunc wing_go_proc;

/*
 *  wingreq_init
 *  Initialize HTTPd-like front end by opening a socket for listening, and
 *  spawning a thread that will listen on that socket and farm out incoming
 *  requests by putting them on the thread work queue.
 *
 *  ARGS:
 *    i: port number to listen on
 *    i: amount by which to boost accept() thread's priority (0 = don't boost,
 *       -1=use default) 
 *  Returns: gm_True or gm_False
 *  Thread-safe: no
 */

gm_Bool
wingreq_init(int port, int boost_prio)
{
  char portnum[8];
  int i;
  pthread_attr_t att;
  struct sched_param sched;

  sprintf(portnum,"%d",port);
  wingSock = slisten(portnum);

  if (wingSock < 1) {
    /* failed to open listening socket */
    MON_SEND_2(MON_ERR,"Socket listen failed: %s\n", strerror(errno));
    return gm_False;
    /* NOTREACHED */
  }

  i = 1;
  if (setsockopt(wingSock, SOL_SOCKET, SO_REUSEADDR, 
		 (const char *)&i, sizeof(int))
      != 0) {
    MON_SEND_2(MON_ERR,"setsockopt SO_REUSEADDR: %s", strerror(errno));  
  }
  
  i = 0;
  if (setsockopt(wingSock, SOL_SOCKET, SO_KEEPALIVE, 
		 (const char *)&i, sizeof(int))
      != 0) {
    MON_SEND_2(MON_ERR,"setsockopt SO_KEEPALIVE: %s", strerror(errno));
  }

  MON_SEND_2(MON_LOGGING,"(Wingman): listening on port %d\n", port);

  n_wingreqs = 1;

  /* spawn a local worker thread  */

  THR_OP("Wing thread attrs init", pthread_attr_init(&att));
  THR_OP("Wing set global scope",
         pthread_attr_setscope(&att, PTHREAD_SCOPE_SYSTEM));
  THR_OP("Wing get sched params",
         pthread_attr_getschedparam(&att, &sched));

#ifdef _MIT_POSIX_THREADS
  sched.prio += boost_prio;
#else
  sched.sched_priority += boost_prio;
#endif

  THR_OP("Wing boost prio",
         pthread_attr_setschedparam(&att, &sched));
  MON_SEND_2(MON_LOGGING,"Boosting Wingman accept() thread prio by %d\n",
	     boost_prio);
  THR_OP("Thread create Wingman",
         pthread_create(&thr_wing, (pthread_attr_t *)&att,
                        wing_eventloop_proc, (void *)NULL));
  
  proxy_debug_2(DBG_HTTP, "Spawned Wingman worker thread\n");
  return gm_True;

}

/*
 *  wing_eventloop_proc
 *  This thread accepts connections (ostensibly from Wingman clients) and
 *  immediately puts the accepted connection on the work queue,specifying
 *  wing_go_proc as the "continuation" procedure.  
 *
 *  REENTRANT: no - only one thread assumed to be in this eventloop
 *  RETURNS: never returns
 *  ARGS: None
 *
 */

static int newconn = 0;

static void *
wing_eventloop_proc(void *arg)
{
  task_t *request;    
  
  proxy_debug_2(DBG_HTTP, "(Wingman): Accepting connections");

  while (1) {
    newconn = saccept(wingSock);
    if (newconn == -1) {
      MON_SEND_2(MON_ERR,"(Wingman): Accept connection: %s", strerror(errno));
      continue;
    }
    /* Put the connection on the queue. */

    proxy_debug_3(DBG_HTTP, "(Wingman): Queueing connection %d", n_wingreqs);
    new_task(&request);
    SET_TASK_ID(request, n_wingreqs);
    n_wingreqs++;
    SET_TASK_GO_PROC(request, wing_go_proc);
    /*
     *  Set parent, child_index, and metadata to null, to indicate this request
     *  is direct from client. 
     */
    SET_TASK_PARENT(request,0);
    SET_TASK_CHILD_INDEX(request,0);
    SET_TASK_METADATA(request,NULL);
    /*
     *  Set task_data to the file descriptor for this socket.  When a
     *  worker thread picks up this task, it will change task_data to a
     *  pointer to the Request struct describing this request.
     *  That structure includs a field for the file descriptor (among
     *  other things), but we can't fill in the structure here because
     *  the structure is managed per worker thread.
     */
    SET_TASK_DATA(request, newconn);
    assert(dispatch(request) == 0);
  }
}

@
