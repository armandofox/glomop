head	1.33;
access;
symbols
	Yatin-final:1.32.2.2
	Yatin:1.32.0.2
	pre-yatin-merge:1.32
	transend-beta2:1.32
	fox-dev:1.32
	transend-beta-latest:1.25
	Aggregators:1.25
	NoAggregators:1.25
	iang:1.24.0.4
	transend-beta:1.24.0.2
	SOSP:1.23
	merged_preintegrate:1.7
	heisenbug:1.4
	PRE_INTEGRATION:1.6;
locks; strict;
comment	@# @;


1.33
date	98.01.16.22.15.59;	author yatin;	state Exp;
branches;
next	1.32;

1.32
date	97.07.29.00.32.03;	author fox;	state Exp;
branches
	1.32.2.1
	1.32.4.1;
next	1.31;

1.31
date	97.07.21.21.30.16;	author yatin;	state Exp;
branches;
next	1.30;

1.30
date	97.07.21.17.15.28;	author fox;	state Exp;
branches;
next	1.29;

1.29
date	97.07.15.02.43.10;	author fox;	state Exp;
branches;
next	1.28;

1.28
date	97.07.08.02.05.08;	author fox;	state Exp;
branches;
next	1.27;

1.27
date	97.06.12.18.31.45;	author fox;	state Exp;
branches;
next	1.26;

1.26
date	97.06.06.00.07.58;	author fox;	state Exp;
branches;
next	1.25;

1.25
date	97.05.11.10.17.28;	author fox;	state Exp;
branches;
next	1.24;

1.24
date	97.04.25.01.57.58;	author fox;	state Exp;
branches;
next	1.23;

1.23
date	97.03.06.05.42.38;	author yatin;	state Exp;
branches;
next	1.22;

1.22
date	97.03.06.01.59.42;	author yatin;	state Exp;
branches;
next	1.21;

1.21
date	97.02.16.05.41.08;	author yatin;	state Exp;
branches;
next	1.20;

1.20
date	97.02.14.21.24.18;	author fox;	state Exp;
branches;
next	1.19;

1.19
date	97.02.07.22.58.23;	author fox;	state Exp;
branches;
next	1.18;

1.18
date	97.02.04.05.37.48;	author fox;	state Exp;
branches;
next	1.17;

1.17
date	97.01.29.23.50.57;	author yatin;	state Exp;
branches;
next	1.16;

1.16
date	97.01.29.23.26.09;	author yatin;	state Exp;
branches;
next	1.15;

1.15
date	97.01.29.22.15.04;	author yatin;	state Exp;
branches;
next	1.14;

1.14
date	97.01.29.01.42.03;	author fox;	state Exp;
branches;
next	1.13;

1.13
date	97.01.28.21.32.00;	author fox;	state Exp;
branches;
next	1.12;

1.12
date	97.01.28.03.55.22;	author fox;	state Exp;
branches;
next	1.11;

1.11
date	97.01.08.03.39.19;	author fox;	state Exp;
branches;
next	1.10;

1.10
date	97.01.06.06.39.04;	author fox;	state Exp;
branches;
next	1.9;

1.9
date	97.01.06.05.43.33;	author fox;	state Exp;
branches;
next	1.8;

1.8
date	96.12.16.21.25.52;	author gribble;	state Exp;
branches;
next	1.7;

1.7
date	96.12.15.23.23.38;	author fox;	state Exp;
branches;
next	1.6;

1.6
date	96.12.13.00.54.27;	author fox;	state Exp;
branches;
next	1.5;

1.5
date	96.12.13.00.18.37;	author fox;	state Exp;
branches;
next	1.4;

1.4
date	96.12.12.02.18.21;	author fox;	state Exp;
branches;
next	1.3;

1.3
date	96.11.28.01.24.51;	author yatin;	state Exp;
branches;
next	1.2;

1.2
date	96.11.28.00.01.02;	author yatin;	state Exp;
branches;
next	1.1;

1.1
date	96.11.22.08.19.32;	author yatin;	state Exp;
branches;
next	;

1.32.2.1
date	97.11.17.22.06.53;	author yatin;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	97.12.01.22.19.21;	author iang;	state Exp;
branches;
next	;

1.32.4.1
date	97.08.15.08.16.50;	author fox;	state Exp;
branches;
next	;


desc
@@


1.33
log
@- new wingman frontend
- new wingman aggregators mechanism
- DistillAsync

(merged from branch Yatin-final)
@
text
@#!/bin/sh
# I'm using this hack so that I can rely on the system using the PATH
# environment variable to locate wish
#
# the exec restarts using wish which in turn ignores
# the command because of this backslash: \
exec wish "$0" -name monitor "$@@"



# Debugging info consists of a unit name, field name, value and
# script.  The components are separated by \001 (or the value of the
# global $Sep, set in the init procedure).  The value can be
# any arbitrary string (it may not contain the character \001). Case and
# whitespace are significant!! Don't put any whitespace around
# \001's unless you want the whitespace to be seen as part of the strings!!
#
#  unit name:  string decribing who sent the info, e.g. PTM, FE, CACHE,
#   etc.  
#  field name: string describing what's being reported, e.g. "Threads
#       idle"
#  value: the actual data.  Can be any arbitrary string of characters
#
#  script: arbitrary Tcl script that is executed when the message is received
#       Typically, this script should be the name of one of the predefined
#       scripts. Currently only 3 types of scripts are defined:
#          the default script: used when no script is specified.
#               Displays the field name/value pair using label widgets,
#               along with the IP address of the last updater.
#          Log: this script is used to output log messages to a scrollable 
#               window
#          TimeChart: plot values continuously a la "xload"
#       In general the script should define all or some of the following 
#       procedures:
#          proc new_unit { toplevel unit } { ... }
#             this proc is invoked when the unit is encountered for the first
#             time. "toplevel" is the pathname of a new toplevel window
#             that the monitor automatically creates for this unit
#          proc new_field { frame unit field } { ... }
#             this proc is invoked when the field is encountered for the first
#             time. "frame" is the pathname of a new frame that the monitor
#             automatically creates for this field. The monitor does not
#             pack this frame. It is up to this procedure to do the packing
#          proc update_field { frame unit field value sender } { ... }
#             this proc is invoked to update the value of the field
#             sender refers to the network address of the entity that
#             sent this message
#
#  To define your own default scripts, use the definition of the Log script
#  towards the end of this file as a guide.
#


proc init {argv0 options_file} {
    global toplevel_counter frame_counter
    global Udp Sep

    set Sep "\001"              ;#separator for message components

    set toplevel_counter 0
    set frame_counter 0
    
    # display options
    
    option add *foreground black
    option add *background #d9d9d9
    if [catch {option readfile $options_file} msg] {
        puts stderr "Warning: problems reading $options_file: $msg"
    }

    # basic window
    frame  .frame -class Top -borderwidth 2 -relief ridge
    frame  .bar -class monitor
    label  .bar.label -text "   $argv0 v[version]   "
    button .bar.quit -text "Quit Monitor" -command "destroy ."
    button .bar.killall -text "Kill All" -command "killall"
    pack .bar.label -side left
    pack .bar.quit -side right -anchor w
    pack .bar.killall -side right
    pack .frame -side top -expand 1 -fill both
    pack .bar -side bottom -expand 1 -fill x
    catch "wm resizable . true true"

    # source other files

    source "make_new.tcl"

    # source procedures for built-in monitoring types

    foreach file [glob -nocomplain -- "./*_procs.tcl"] {
        catch {source $file}
    }

    # load UDP multicast listening support

    load "./tudp.so"

    set mlisten [option get . listen Monitor]
    if {$mlisten == ""} {
        puts stderr "No option Monitor.listen found in $options_file!"
        exit 1
    }
    #if [regexp "/.+/" $mlisten] {
        # multicast addr/port/ttl
        #set Udp [udp_listen -multicast $mlisten -callback callback]
    #} else {
        # unicast port number
        #set Udp [udp_listen -unicast $mlisten -callback callback]
    #}
    set Udp [udp_listen -address $mlisten -callback callback]
    .bar.label configure -text "   $argv0 v[version]   $mlisten"
}

#
#  Kill all entities
#

proc killall {} {
    foreach unit_frame [winfo children .frame] {
        $unit_frame.kill invoke
    }
}

#
#  This is the main entry point that gets called whenever a packet
#  arrives
#

proc callback {fromaddr fromport data} {
    global fields units
    global Sep
    
    set data [split $data $Sep]
    if { [llength $data] < 4 } { return }
    set hostName [lindex $data 0]
    set pid      [lindex $data 1]
    set unit     [lindex $data 2]
    set field    [lindex $data 3]
    set value    [lindex $data 4]
    set procs    [lindex $data 5]

    if { [string index $procs 0] != "!" } {
        catch {eval $procs}
        # $procs might contain definitions for new_unit, new_field, and
        # update_field procs
    }
    #
    #  If this is the echo of a "kill yourself" packet sent to a unit,
    #  ignore it.
    #
    if {[string compare $field "%KILL%"] == 0 \
            || [string compare $value "%KILL%"] == 0 } {
        return
    }
    
    #
    #  If this is a "death packet" from a unit....destroy unit's window.
    #
    if { [string compare $field "%DEATH%"] == 0 \
            || [string compare $value "%DEATH%"] == 0} {

	if { ! [info exists units($unit)] } { return }

        if { [option get .frame destroyondeath {}] == "yes" } {
	    catch {destroy $units($unit)}
	    return
	} else {
	    wm title $units($unit) "$unit (Dead)"

	    set unit_frame .frame.frame-[unitnumber $units($unit)]
	    foreach child [winfo children $unit_frame] {
		$child configure -background gray
	    }
	    #$unit_frame.kill configure -state disabled
	    $unit_frame.kill configure \
		-command "destroy_unit $units($unit) $units($unit) $unit_frame" 

	    Death
	}
    }

    #
    #  Otherwise process normal packet.
    #
    if { [info exists units($unit)] && (![winfo exists $units($unit)]) } { 
	unset units($unit)
    }
    if { [info exists fields($unit--$field)] && \
	    ![winfo exists $fields($unit--$field)] } { 
	unset fields($unit--$field)
    }

    if { ! [info exists units($unit)] } {
        make_newunit $unit $hostName $pid
    }

    if {! [info exists fields($unit--$field)]} {
        make_newfield $unit $field
    }

    # if a custom update-field proc was supplied, call it; otherwise
    #  call the default one.

    set frame $fields($unit--$field)
    if {[info procs update_field] != ""} {
	catch {update_field $frame $unit $field $value "$fromaddr/$fromport"}
    } else {
	catch {default_update_field $frame $unit $field $value \
                "$fromaddr/$fromport"} 
    } 

    # delete these procedures.
    # BUG::This is the wrong way to do it.  Should keep them around per
    # unit.  This way has too much overhead.
    
    foreach x {new_unit new_field update_field} {
        if {[info procs $x] != ""} { rename $x {} }
    }
}

# send a "kill yourself" packet to a given unit, to tell it to commit
# suicide.  When it dies, it should try to send a "last gasp" packet,
# which is a packet whose "field" value is "%DEATH%".

proc death_packet {unit} {
    global Udp Sep
    udp_send $Udp "${unit}${Sep}%KILL%"
}


proc kill_command {unit} {
    global hosts pids units
    global myhostname

    if {! [info exists myhostname]} {
        catch {set myhostname [exec hostname]}
    }

    # puts "*** killing $pids($unit) with $cmd ***"
    if {$myhostname != $hosts($unit)}  {
        set rsh [option get .frame rsh {}]
        if {$rsh == ""} { set rsh "rsh" }
	set cmd "kill -TERM $pids($unit); sleep 5; kill -KILL $pids($unit)"
	catch {exec $rsh -n $hosts($unit) $cmd > /dev/null 2> /dev/null &}

        #catch "exec $rsh $hosts($unit) kill -TERM $pids($unit)"
        #after 5000 "catch {exec $rsh $hosts($unit) kill -KILL $pids($unit)}"
    } else {
        catch "exec kill -TERM $pids($unit) 2>/dev/null  &"
        after 5000 "catch {exec kill -KILL $pids($unit) 2> /dev/null &}"
    }

    wm title $units($unit) "$unit (Killing)"
    
    set unit_frame .frame.frame-[unitnumber $units($unit)]
    foreach child [winfo children $unit_frame] {
	$child configure -background green
    }

    $unit_frame.kill configure \
            -command "destroy_unit $units($unit) $units($unit) $unit_frame" 
}


proc version {} {
    # DO NOT MODIFY THE FOLLOWING LINE -- it is generated by CVS
    set rev {$Revision: 1.32.2.2 $}
    if [regexp -- {([0-9.]+)} $rev revnumber] {
        return $revnumber
    } else {
        return "??"
    }
}

cd [file dirname $argv0]
set argv0 [file tail $argv0]
tk appname monitor
init $argv0 [lindex $argv 0]
@


1.32
log
@fixed TACCutils bug that sometimes caused next_entity to enter infinite
loop.  beginning frontend cleanup to separate service-specific stuff
from core stuff.  ifdef'd out the instrumentation code in
httpsupport.c:parse_status_and_headers, which was likely causing
segfaults.  removed sbrk() monitoring from thr_mon.c because it was
bogus.  tested the Bypass feature for big pages (it works) and set
bypass threshold to about 1.5MB in clib.h.  monitor window is now
resizable though not all the fields resize intelligently.
@
text
@d66 1
a66 1
    option add *background Gray
d174 3
a176 1
	    $unit_frame.kill configure -state disabled
d267 1
a267 1
    set rev {$Revision: 1.31 $}
@


1.32.2.1
log
@- Modularized the wingman frontend by splitting wing_go_proc into
  multiple smaller functions

- New aggregator mechanism for wingman proxies. The WingDispatch worker
  receives a request with a special content-type application/x-wingman-agg.
  The body of the request contains the full aggregator url

  The worker should return a valid HTTP response, which might be a
  pilot-ready document (i.e. an x-wingman/* document) or an HTTP
  redirect to a new URL, or whatever it chooses!)

- The WingDispatcher is now expected to weed out unintelligible content-types
  and return a content-type of x-wingman/<integer> to the frontend, where
  <integer> represents the integral content type returned to the pilot client.

- Agglist: this appears at the dispatcher as a special aggregator request
  with a url of agg://agglist/ (this URL is actually defined in the
  gm_options file, so the worker should check against the gm_options
  entry, rather than a hard-coded entry). The worker that handles this
  request *MUST* return a document with content type
  x-wingman/2 and the actual agglist as part of the data.

  For old browsers, the data part of this response is stuffed into an
  appropriate metadata field by the frontend before sending the reply to
  the client (i.e. it is backward compatible). For browsers with the new
  version number, the browser will no longer set any special flags in the
  metadata field of the client request. Instead it will explicitly request
  for the agg://agglist/ url. It'll check the ContentType field in the
  response for content type 2 to match up the correct response.

- Created a new version number for the agglist changes:
  #define CLIENT_VERSION_NEWAGG 0x01050200

- gm_options changes:
  Here are the three new gm_options entries for wingman: (the
  wingman.text.prefetch_href replaces the old prefetch.href entry)

  wingman.about_url: http://www.isaac.cs.berkeley.edu/pilot/wingman/about-
  wingman.agglist_url: agg://agglist/
  wingman.text.prefetch_href: 10

- PTM changes:
  - Background distillers work. Specify the -e flag before the -- in the
    gm_options line for the distiller. The PTM will IMMEDIATELY respawn the
    distiller if it crashes. This mechanism is still very simple and naive
  - Distillers can rename themselves: API function DistillerReregister.
@
text
@d66 1
a66 1
    option add *background #d9d9d9
d265 1
a265 1
    set rev {$Revision: 1.32 $}
@


1.32.2.2
log
@Added DistillAsync and friends
@
text
@d174 1
a174 3
	    #$unit_frame.kill configure -state disabled
	    $unit_frame.kill configure \
		-command "destroy_unit $units($unit) $units($unit) $unit_frame" 
d265 1
a265 1
    set rev {$Revision: 1.32.2.1 $}
@


1.32.4.1
log
@*** empty log message ***
@
text
@d96 1
a96 1
    load "../lib/tudp.so"
d265 1
a265 1
    set rev {$Revision: 1.32 $}
@


1.31
log
@Changes to monitor to do unicast and multicast listening properly
Modified distiller database so that everything after "--" is assumed to
be command line args to the distiller
@
text
@d82 1
a82 1
    catch "wm resizable . false false"
d265 1
a265 1
    set rev {$Revision: 1.30 $}
@


1.30
log
@minor changes to make monitor unicast-capable and allow compilation on other linuxes (need explicit link to libgcc?)
@
text
@d103 1
a103 1
    if [regexp "/.+/" $mlisten] {
d105 2
a106 2
        set Udp [udp_listen -multicast $mlisten -callback callback]
    } else {
d108 3
a110 2
        set Udp [udp_listen -unicast $mlisten -callback callback]
    }
d265 1
a265 1
    set rev {$Revision: 1.29 $}
@


1.29
log
@makefile changes to link pthreads only at end, which was causing severe bad behaviors under linux since different people were calling different signal()s.  SIGHUP is now used instead of SIGUSR1 to signal components to reinitialize themselves, and SIGTERM is used to kill them gracefully.  Layout stuff for Pilot works but is still inelegant.
@
text
@d103 1
a103 1
    if [regexp "/" $mlisten] {
d264 1
a264 1
    set rev {$Revision: 1.28 $}
@


1.28
log
@uses perl Config module to get perl installation paths and make a perl_stub and perl_dir/harness that configure themselves correctly for this installation
@
text
@d240 1
a240 1
	set cmd "kill -HUP $pids($unit); sleep 5; kill -KILL $pids($unit)"
d243 1
a243 1
        #catch "exec $rsh $hosts($unit) kill -HUP $pids($unit)"
d246 1
a246 1
        catch "exec kill -HUP $pids($unit) 2>/dev/null  &"
d264 1
a264 1
    set rev {$Revision: 1.27 $}
@


1.27
log
@various changes to makefiles to support auto-installation into sbin and bin directories.  perl HTML distiller no longer inserts UI in pages with frames.  PREFS_URL and similar strings are now static char* instead of #defines, but still need them to be initialized in PTM stub so distillers can get at them.  "run" targets are better now, they run stuff from the sbin and bin directories.
@
text
@d67 3
a69 1
    catch {option readfile $options_file}
d110 1
d264 1
a264 1
    set rev {$Revision: 1.26 $}
@


1.26
log
@Many changes to support SDK, including bin and sbin directories,
and modified make targets and names of some binary targets.  Calling
convention changed for perl distillers, so fixed html distiller and
added it as transend.text.html.  monitor.multicast property is now
Monitor.listen; all relevant code was changed.  Monitor can now parse
this from the options file.  Updated all UI changes from branch head.
@
text
@d97 4
d111 10
d243 1
a243 1
        catch "exec kill -HUP $pids($unit) &"
d261 1
a261 1
    set rev {$Revision: 1.25 $}
d269 3
@


1.25
log
@you can now kill the window belonging to a dead process
@
text
@d7 1
a7 1
exec wish "$0" "$@@"
d54 1
a54 1
proc init {argv0 options_file restargs} {
d71 1
a71 1
    frame  .bar
d73 2
a74 1
    button .bar.quit -text "Quit" -command "destroy ."
d77 1
d95 9
a103 3
    set arg0 [lindex $restargs 0]
    set arg1 [lindex $restargs 1]
    set Udp [udp_listen $arg0 $arg1  -callback callback]
d246 2
a247 1
    set rev {$Revision: 1.24 $}
d255 1
a255 1
init $argv0 [lindex $argv 0] [lrange $argv 1 end]
@


1.24
log
@made blinkenlights smaller and faster, need to fix up the visual interface now...
@
text
@d232 2
a233 1
    $unit_frame.kill configure -state disabled
d238 1
a238 1
    set rev {$Revision: 1.23 $}
@


1.23
log
@stupid fixes
@
text
@d222 1
a222 1
        after 5000 "catch {exec kill -KILL $pids($unit) &}"
d237 1
a237 1
    set rev {$Revision: 1.22 $}
@


1.22
log
@Changed the rsh mechanism to not stall for so long
@
text
@d216 1
a216 1
	catch {exec $rsh $hosts($unit) $cmd > /dev/null 2> /dev/null &}
d229 1
a229 1
	$child configure -background lightgreen
d237 1
a237 1
    set rev {$Revision: 1.21 $}
@


1.21
log
@Modified the monitor to allow iconified windows to be totally removed from
the display. Also created individual monitor.options files
@
text
@d215 5
a219 2
        catch "exec $rsh $hosts($unit) kill -HUP $pids($unit)"
        after 5000 "catch {exec $rsh $hosts($unit) kill -KILL $pids($unit)}"
d221 2
a222 2
        catch "exec kill -HUP $pids($unit)"
        after 5000 "catch {exec kill -KILL $pids($unit)}"
d229 1
a229 1
	$child configure -background gray
d237 1
a237 1
    set rev {$Revision: 1.20 $}
@


1.20
log
@fixed killbutton bug in monitor
@
text
@d54 1
a54 1
proc init {argv0 restargs} {
d67 1
a67 1
    catch {option readfile "monitor.options"}
d234 1
a234 1
    set rev {$Revision: 1.19 $}
d242 1
a242 1
init $argv0 $argv
@


1.19
log
@temporarily "catch"ed the error that causes the script to get into a bad state.  should really fix this bug instaed of masking it.  also local kill was added but doesnt quite work yet
@
text
@a210 3
    set cmd \
    "kill -HUP $pids($unit)\; sleep 5\; kill -KILL $pids($unit)  &"

d215 5
a219 1
        set cmd "$rsh $hosts($unit) $cmd"
a220 1
    catch {exec $cmd}
d234 1
a234 1
    set rev {$Revision: 1.18 $}
@


1.18
log
@array-of-indicators logging added to monitor
@
text
@d178 1
a178 1
	update_field $frame $unit $field $value "$fromaddr/$fromport"
d180 2
a181 1
	default_update_field $frame $unit $field $value "$fromaddr/$fromport"
d205 1
d207 3
a209 2
    set rsh [option get .frame rsh {}]
    if {$rsh == ""} { set rsh "rsh" }
d211 2
a212 1
    catch {exec $rsh $hosts($unit) kill -HUP $pids($unit)\; sleep 5\; kill -9 $pids($unit) &}
d214 7
d234 1
a234 1
    set rev {$Revision$}
@


1.17
log
@Still more changes to the monitor to make kill work
@
text
@d223 6
a228 1
    return 1.0a2
@


1.16
log
@More changes for killing processes via the monitor
@
text
@d142 1
a142 2
	    set title [wm title $units($unit)]
	    wm title $units($unit) "$title (Dead)"
d148 2
d210 9
a218 1
    destroy $units($unit)
@


1.15
log
@Changes to the monitor for killing
@
text
@d133 18
a150 5
    if {! [info exists env("DEBUGGING")]  \
            && ([string compare $field "%DEATH%"] == 0 \
            || [string compare $value "%DEATH%"]) == 0} {
        catch {destroy $units($unit)}
        return
d152 1
d201 9
a209 2
proc kill_command {unit kill} {
    puts [option get $kill rsh Top]
@


1.14
log
@env(DEBUGGING) now causes windows not to be destroyed when programs die
@
text
@d109 6
a114 4
    set unit  [lindex $data 0]
    set field [lindex $data 1]
    set value [lindex $data 2]
    set procs [lindex $data 3]
d151 1
a151 1
        make_newunit $unit
d185 6
@


1.13
log
@removed annoying debugging printf
@
text
@d131 3
a133 2
    if {[string compare $field "%DEATH%"] == 0 \
            || [string compare $value "%DEATH%"] == 0} {
@


1.12
log
@bug fix to tudp.so, usability fixes to libmon
@
text
@a113 2
    puts "value $value, procs <$procs>"

@


1.11
log
@Added "dying gasp" functionality to MonitorClient class: whenever a new
monitor is created, globals are set to record its socket id and unit
name, so that the program can respond to signals by jumping to a signal
handler that announces the program's death by sending a death packet.
New functions in monitor.cc: DyingGasp (class method), GaspOnSignals
(instance method), extern "C" void MonitorClientSigHandler (C signal
handler), CurrentMonitorSock and CurrentUnitId (static variables in
monitor.h).  If you can think of a better way to do this, please change
it.

Fixed bug in frontend HTTP request parsing that caused multi-packet
requests not to be read correctly.

Many changes to the monitor, mostly cosmetic, some functional, including
addition of "kill" button (there is now a "death protocol") and more
sane show/hide behavior that is integrated with iconifying.
@
text
@d114 2
d122 10
a131 1
    #  If this is a "death packet" from a unit....
@


1.10
log
@Broke up monitor functionality into various files for
maintainability. Made default state of new windows hidden rather than
exposed.  New procedures (for different logging types) can now be added
by simply adding a file whose name matches the glob "*_procs.tcl"; it
will be loaded automatically.
@
text
@d12 2
a13 1
# script.  The components are separated by \001.  The value can be
d54 1
a54 1
proc init {argv0 args} {
d56 3
d67 1
d70 1
a70 1
    frame  .frame -borderwidth 2 -relief ridge
d93 3
a95 55
    eval udp_listen $args -callback callback
}


# this is the procedure that is called if no new_unit procedure is defined
# in the script accompanying the body of the message
proc default_new_unit { toplevel unit } {
    frame $toplevel.bar
    set dismiss [button $toplevel.bar.button -text "Dismiss" -pady 0 \
	    -highlightthickness 0 -borderwidth 2 -command "destroy $toplevel"]
    pack $dismiss -side right
    pack $toplevel.bar -side bottom -expand 1 -fill x
}

# this is the procedure that is called if no new_field procedure is defined
# in the script accompanying the body of the message
proc default_new_field { frame unit field } {
    label $frame.id     -width 24 -text $field
    label $frame.sender -width 16
    label $frame.value  -width 15 -fg red

    $frame configure -borderwidth 2 -relief sunken

    pack $frame.id $frame.sender $frame.value \
            -side left -fill none -expand 1
    pack $frame -side bottom -fill x -expand 1
}

# this is the procedure that is called if no update_field procedure is defined
# in the script accompanying the body of the message
proc default_update_field { frame unit field value sender } {
    $frame.sender configure -text $sender
    $frame.value  configure -text $value
}

#
#  new_field, update_field, and script procedures for the
#  TimeChart function
#

proc withdraw_unit { toplevel button } {
    wm withdraw $toplevel
    $button configure -text "Show" -command "restore_unit $toplevel $button"
}


proc restore_unit { toplevel button } {
    wm deiconify $toplevel
    $button configure -text "Hide" \
	    -command "withdraw_unit $toplevel $button"
}


proc destroy_unit { toplevel widget unit_frame } {
    if { $widget == $toplevel } { destroy $unit_frame }
d105 1
d107 1
a107 1
    set data [split $data \001]
d119 11
d165 9
d178 1
a178 1
eval init $argv0 $argv
@


1.9
log
@Added doc/distillers.txt, which explains how to write your own
distiller.  Gifmunger should now do the right thing even on extremely
large images.  Default args for gifmunger are more sane (16 colors,
scale 0.5 per axis), but output still looks sucky - not sure why the
quantize phase picks such crappy colors.  "test_http" program has been
officially renamed "frontend".  Fixed the "run" targets in toplevel
Makefile.  Added line to configure.in to create a Makefile from
Makefile.in for gui.
@
text
@d53 34
a86 1
proc init {args} {
d123 4
a126 216



# new_field procedure for Log messages
proc Log_new_field { frame unit field width height maxLines} {
    label $frame.id -text $field
    set maxLinesVar $frame.text.maxLines
    global $maxLinesVar

    set arg {}
    if { $width != "" } { set arg "$arg -width $width" }
    if { $height!= "" } { set arg "$arg -height $height" }
    set $maxLinesVar $maxLines

    if { $arg != "" } {
	text $frame.text $arg -xscrollcommand "$frame.sx set" \
		-yscrollcommand "$frame.sy set" -wrap none -state disabled
    } else {
	text $frame.text -xscrollcommand "$frame.sx set" \
		-yscrollcommand "$frame.sy set" -wrap none -state disabled
    }

    bind $frame.text <Destroy> "catch \{ unset $maxLinesVar \}"
    scrollbar $frame.sx -orient horizontal -command "$frame.text xview"
    scrollbar $frame.sy -orient vertical   -command "$frame.text yview"

    pack $frame.id -side top -anchor w
    pack $frame.sx -side bottom -fill x
    pack $frame.sy -side right  -fill y
    pack $frame.text -side left -fill both -expand true
    pack $frame -expand true -fill both
}

# update_field procedure for Log messages
proc Log_update_field { frame unit field value sender } {
    set maxLinesVar $frame.text.maxLines
    global $maxLinesVar
    set maxLines [set $maxLinesVar]
    $frame.text configure -state normal
    $frame.text insert end $value

    set totalLines [lindex [split [$frame.text index end] .] 0]
    if { $totalLines > $maxLines } {
	$frame.text delete 1.0 [expr $totalLines - $maxLines].0
    }

    $frame.text configure -state disabled
}


# the procedure to be specified as the script for log messages
# i.e. a log message will have the format:
# <unit>\001<field>\001<value\001Log
#    or                          ^^^
# <unit>\001<field>\001<value\001Log <width> <height> <maxLines>
#                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
proc Log { args } {
    set width    "[lindex $args 0]"
    set height   "[lindex $args 1]"
    set maxLines "[lindex $args 2]"
    if { $maxLines == "" } { set maxLines 50 }

    set new_field_body "Log_new_field \$frame \$unit \$field \{$width\} \
	    \{$height\} \{$maxLines\}"
    proc new_field { frame unit field } $new_field_body

    proc update_field { frame unit field value sender } {
	Log_update_field $frame $unit $field $value $sender
    }
}


proc TimeChart_resize { frame } {
    global TimeChart_all
    upvar #0 $TimeChart_all($frame) struct

    update
    set width  [winfo width  $struct(frame).canvas]
    set height [expr [winfo height $struct(frame).canvas] - 10]
    set struct(xscale) [expr double($width)/$struct(numberOfIntervals)]

    if { $struct(maxYValue) == 0 } {
	set struct(yscale) 0
    } else {
	set struct(yscale) [expr double($height)/$struct(maxYValue)]
    }
}


proc TimeChart_done { frame } {
    global TimeChart_all
    upvar #0 $TimeChart_all($frame) struct
    unset TimeChart_all($frame)

    foreach plotStructName $struct(allPlots) {
	upvar #0 $plotStructName plotStruct
	unset plotStruct
    }
    if { $struct(afterID) != "" } { after cancel $struct(afterID) }
    unset struct
}


proc TimeChart_new_field { frame unit field } {
    global TimeChart_all
    set TimeChart_all($frame) TimeChart_struct_$frame
    upvar #0 $TimeChart_all($frame) struct

    set struct(updateInterval)    500
    set struct(numberOfIntervals) 120
    set struct(maxYValue)         0
    set struct(allPlots)          { }
    set struct(frame)             $frame

    canvas $struct(frame).canvas -relief sunken
    pack   $struct(frame).canvas -expand 1 -fill both
    bind   $struct(frame).canvas <Configure> "TimeChart_resize $frame"
    pack   $struct(frame) -expand 1 -fill both
    bind   $struct(frame) <Destroy> "TimeChart_done $frame"

    TimeChart_resize $struct(frame)
    set struct(afterID) ""
    TimeChart_periodic_update $frame
}


proc TimeChart_update_field { frame unit field value sender } {
    # value has the format
    # plot_name=value,color

    global TimeChart_all
    upvar #0 $TimeChart_all($frame) struct

    set plot  ""
    set val   ""
    set color ""
    if { ![regexp {([^=]*)=([^,]*),(.*)} $value dummy plot val color] } return

    set plotStructName TimeChart_plotStruct_${frame}_$plot
    upvar #0 $plotStructName plotStruct

    if { [lsearch -exact $struct(allPlots) $plotStructName] == -1 } {
	lappend struct(allPlots) $plotStructName
	set plotStruct(history) { }
	
	for {set idx 0} { $idx < $struct(numberOfIntervals) } { incr idx } {
	    lappend plotStruct(history) 0
	}
	
	$struct(frame).canvas create line 0 0 0 0 -tag TimeChart_line
    }

    set plotStruct(value)   $val
    set plotStruct(updated) 1
    set plotStruct(color)   $color

    if { $struct(maxYValue) < $val } {
	set struct(maxYValue) $val
	TimeChart_resize $frame
    }
}


proc TimeChart_periodic_update { frame } {
    global TimeChart_all
    upvar #0 $TimeChart_all($frame) struct

    if { ![info exist struct] } { return }
    $struct(frame).canvas delete TimeChart_line

    set newMax 0
    foreach plotStructName $struct(allPlots) {
	upvar #0 $plotStructName plotStruct
	set plotStruct(history) \
		"[lrange $plotStruct(history) 1 end] $plotStruct(value)"
	set plotStruct(updated) 0

	set points { }
	set x 0
	set height [expr [winfo height $struct(frame).canvas] - 5]
	foreach y $plotStruct(history) {
	    if { $newMax < $y } { set newMax $y }

	    set y [expr int($height - ($y * $struct(yscale)))]
	    set points "$points [expr int($x)] $y"
	    set x [expr $x + $struct(xscale)]
	}
	eval $struct(frame).canvas create line $points -tag TimeChart_line \
		-fill $plotStruct(color)
    }

    if { $newMax < $struct(maxYValue) } { 
	set struct(maxYValue) $newMax
	TimeChart_resize $frame 
    }

    set struct(afterID) [after $struct(updateInterval) \
	    "TimeChart_periodic_update $frame"]
}


proc TimeChart { } {
    # the format of the value field for this type of message is:
    #    plot-name=current-plot-value,plot-color
    # remember! no spaces allowed
    proc new_field { frame unit field } {
	TimeChart_new_field $frame $unit $field
    }

    proc update_field { frame unit field value sender } {
	TimeChart_update_field $frame $unit $field $value $sender
    }
}



d130 1
a130 1
    $button configure -text "Restore" -command "restore_unit $toplevel $button"
d136 1
a136 1
    $button configure -text "Withdraw" \
d160 4
a163 3
    if { [string index $procs 0] == "!" } {
	# we simply want to invoke this script
	# don't do anything 
a164 5

    if { $procs!={} } {catch {eval $procs}}
    # $procs might contain definitions for new_unit, new_field, and
    # update_field procs

d174 1
a174 26
	# this is a new unit
	global toplevel_counter

	if { ![info exists toplevel_counter] } { set toplevel_counter 0 }
	set toplevel [toplevel .top$toplevel_counter]
	wm title $toplevel $unit

	set unit_frame [frame .frame.frame$toplevel_counter]
	set label  [label  $unit_frame.label  -text $unit]
	set button [button $unit_frame.button -text "Withdraw" -width 8 \
		-pady 0]
	$button configure -command "withdraw_unit $toplevel $button"
	bind $toplevel <Destroy> "destroy_unit $toplevel %W $unit_frame"

	pack $label -side left -fill x -expand 1 -anchor w
	pack $button -side right -anchor e
	pack $unit_frame -fill x -expand 1

	set units($unit) $toplevel
	incr toplevel_counter
	
	if { [info procs new_unit]=="" } {
	    default_new_unit $toplevel $unit
	} else {
	    new_unit $toplevel $unit
	}
d178 2
a179 2
	# this is a new field
	global frame_counter
d181 2
a182 11
	if { ![info exists frame_counter] } { set frame_counter 0 }
	set frame [frame $units($unit).frame$frame_counter]
	set fields($unit--$field) $frame
	incr frame_counter
	
	if { [info procs new_field]=="" } {
	    default_new_field $frame $unit $field
	} else {
	    new_field $frame $unit $field
	}
    }	
d185 3
a187 1
    if { [info procs update_field]=="" } {
d189 1
a189 3
    } else {
	update_field $frame $unit $field $value "$fromaddr/$fromport"
    }
d191 6
a196 9

    if { [info procs new_unit]!="" } {
	rename new_unit {}
    }
    if { [info procs new_field]!="" } {
	rename new_field {}
    }
    if { [info procs update_field]!="" } {
	rename update_field {}
a199 1

d201 1
a201 1
    return 1.0a1
d204 1
a204 15

option add *foreground black
option add *background Gray

frame  .frame -borderwidth 2 -relief ridge
frame  .bar
label  .bar.label -text "   $argv0 v[version]   "
button .bar.quit -text "Quit" -command "destroy ."
pack .bar.label -side left
pack .bar.quit -side right -anchor w
pack .frame -side top -expand 1 -fill both
pack .bar -side bottom -expand 1 -fill x
catch "wm resizable . false false"

eval init $argv
@


1.8
log
@Trashed partial PID monitor.tcl - this version actually works.
@
text
@d324 4
@


1.7
log
@Cosmetic changes plus facility for encoding pid of senders
@
text
@a65 2
    set withdraw [button $toplevel.bar.button2 -text "Hide" -pady 0 \
	    -highlightthickness 0 -borderwidth 2 -command "wm withdraw $toplevel"]
d304 1
a304 4
proc kill_unit {toplevel button pid} {
    catch { exec "kill -KILL $pid" }
}
    
d309 1
a309 1
    $button configure -text "Show Log" -command "restore_unit $toplevel $button"
d315 1
a315 1
    $button configure -text "Hide Log" \
d329 5
a333 6
    if { [llength $data] < 5 } { return }
    set pid   [lindex $data 0]
    set unit  [lindex $data 1]
    set field [lindex $data 2]
    set value [lindex $data 3]
    set procs [lindex $data 4]
d362 1
a362 1
	set button [button $unit_frame.button -text "Hide Log" -width 8 \
d364 1
a364 4
        $button configure -command "withdraw_unit $toplevel $button"
        set killbutton [button $unit_frame.kill -text "Kill $pid" -width 9 \
                -pady 0]
        $killbutton configure -command "kill_unit $toplevel $button $pid"
d368 1
a368 2
        pack $killbutton -side right -anchor c
	pack $button -side right -anchor c
@


1.6
log
@*** empty log message ***
@
text
@d306 4
a309 1

d334 6
a339 5
    if { [llength $data] < 4 } { return }
    set unit  [lindex $data 0]
    set field [lindex $data 1]
    set value [lindex $data 2]
    set procs [lindex $data 3]
d370 4
a373 1
	$button configure -command "withdraw_unit $toplevel $button"
d377 2
a378 1
	pack $button -side right -anchor e
@


1.5
log
@Changed "int" argument type to be signed rather than unsigned.  Required
addition of INT32 type to config.h.in, and addition of overload
operators '<<', '>>' for type "long int" to IStream and OStream classes
in ptm (mods to packet.{cc,h}).  Added various "make run" targets at top
level.  Minor fixes to monitor's GUI.  Added simple argument parsing to
gif_munge in ARGS.h, which will be the standard filename where distiller
args are defined.  Added tags target to ptm makefile.
@
text
@d66 1
a66 1
    set withdraw [button $toplevel.bar.button -text "Hide" -pady 0 \
d364 1
a364 1
	set button [button $unit_frame.button -text "Withdraw" -width 8 \
@


1.4
log
@*** empty log message ***
@
text
@d66 2
d311 1
a311 1
    $button configure -text "Restore" -command "restore_unit $toplevel $button"
d317 1
a317 1
    $button configure -text "Withdraw" \
@


1.3
log
@Modified monitor.tcl to auto-scale the y-axis
Modified ptmnet.cc to send distiller-load information to the monitor agent
@
text
@d25 4
a28 2
#       scripts. Currently only two types of scripts are defined:
#          the default script: which is used when no script is specified
d31 1
@


1.2
log
@Doing a complete checking after adding TimeChart to the Monitor GUI
@
text
@d162 1
a162 1
   
d165 1
a165 2
    set height [expr [winfo height $struct(frame).canvas] - 5]
    puts stderr "Resizing $width $height"
d167 6
a172 1
    set struct(yscale) [expr double($height)/$struct(maxYValue)]
d176 13
d196 2
a197 2
    set struct(numberOfIntervals) 50
    set struct(maxYValue)         20
d205 1
d207 2
a208 5
    set width  [$struct(frame).canvas cget -width ]
    set height [expr [$struct(frame).canvas cget -height] - 2]
    set struct(xscale) [expr double($width)/$struct(numberOfIntervals)]
    set struct(yscale) [expr double($height)/$struct(maxYValue)]

d242 5
d254 1
d256 2
d268 2
d278 4
a281 3
    after $struct(updateInterval) "TimeChart_periodic_update $frame"
}

d283 2
a284 94
#proc TimeChart_resize { } {
#    global TimeChart_xscale TimeChart_yscale TimeChart_maxYValue \
#	    TimeChart_numberOfIntervals TimeChart_frame
#
#    update
#    set width  [winfo width  $TimeChart_frame.canvas]
#    set height [winfo height $TimeChart_frame.canvas]
#    puts stderr "Resizing $width $height"
#    set TimeChart_xscale [expr double($width)/$TimeChart_numberOfIntervals]
#    set TimeChart_yscale [expr double($height)/$TimeChart_maxYValue]
#}



#proc TimeChart_new_field { frame unit field } {
#    global TimeChart_updateInterval TimeChart_fields TimeChart_frame \
#	    TimeChart_xscale TimeChart_yscale TimeChart_allFrames \
#	    TimeChart_maxYValue TimeChart_numberOfIntervals
#
#    destroy $frame
#    if { ![info exists TimeChart_updateInterval] } {
#	set TimeChart_updateInterval    500
#	set TimeChart_numberOfIntervals 50
#	set TimeChart_maxYValue         20
#
#	set TimeChart_allFrames         { }
#	set TimeChart_frame $frame
#	frame $TimeChart_frame
#	pack $TimeChart_frame -expand 1 -fill both
#
#	canvas $TimeChart_frame.canvas
#	pack   $TimeChart_frame.canvas -expand 1 -fill both
#	bind   $TimeChart_frame.canvas <Configure> "TimeChart_resize"
#	set width  [$TimeChart_frame.canvas cget -width ]
#	set height [$TimeChart_frame.canvas cget -height]
#	set TimeChart_xscale [expr double($width)/$TimeChart_numberOfIntervals]
#	set TimeChart_yscale [expr double($height)/$TimeChart_maxYValue]
#    }
#
#    lappend TimeChart_allFrames $frame
#    set TimeChart_fields($frame,value) 0
#    set TimeChart_fields($frame,updated) 1
#    set TimeChart_fields($frame,history) { }
#    for {set idx 0} { $idx < $TimeChart_numberOfIntervals } { incr idx } {
#	lappend TimeChart_fields($frame,history) 0
#    }
#    set TimeChart_fields($frame,color) blue
#
#    $TimeChart_frame.canvas create line 0 0 0 0 -tag TimeChart_line
#    TimeChart_periodic_update
#}


#proc TimeChart_update_field { frame unit field value sender } {
#    global TimeChart_fields
#    set TimeChart_fields($frame,value) $value
#    set TimeChart_fields($frame,updated) 1
#}


#proc TimeChart_periodic_update { } {
#    global TimeChart_fields TimeChart_line TimeChart_frame \
#	    TimeChart_xscale TimeChart_yscale TimeChart_allFrames \
#	    TimeChart_updateInterval
#
#    $TimeChart_frame.canvas delete TimeChart_line
#
#    foreach frame $TimeChart_allFrames {
#	set TimeChart_fields($frame,history) \
#		"[lrange $TimeChart_fields($frame,history) 1 end] $TimeChart_fields($frame,value)"
#	set TimeChart_fields($frame,updated) 0
#
#	set points { }
#	set x 0
#	set height [$TimeChart_frame.canvas cget -height]
#	foreach y $TimeChart_fields($frame,history) {
#	    set y [expr int($height - ($y * $TimeChart_yscale))]
#	    set points "$points [expr int($x)] $y"
#	    set x [expr $x + $TimeChart_xscale]
#	}
#	eval $TimeChart_frame.canvas create line $points -tag TimeChart_line
#    }
#
#    after $TimeChart_updateInterval TimeChart_periodic_update
#}


proc TimeChart_recalibrate { data } {
    upvar $data data
    set max 0
    foreach idx [array names data __*] {
	if { $max < $data($idx)] } { set max $data($idx) }
    }
    return $max
a287 1

d289 3
@


1.1
log
@The Monitor GUI currently has the Log script predefined.
Need to add other scripts
@
text
@a58 2
    wm title $toplevel $unit

d91 1
a91 1
proc Log_new_field { frame unit field } {
d93 15
d109 1
a109 2
    text $frame.text -xscrollcommand "$frame.sx set" \
	    -yscrollcommand "$frame.sy set" -wrap none -state disabled
d122 3
d127 6
d140 216
a355 2
#                                ^^^
proc Log {} {
d357 1
a357 1
	Log_new_field $frame $unit $field
d359 1
d361 1
a361 1
	Log_update_field $frame $unit $field $value $sender
d366 20
a388 11
    #set unit {}
    #set field {}
    #set value {}
    #set procs {}

    #regexp {^([^\001]+)\001([^\001]+)\001([^\001]+)\001(.*)} \
	    #$data dummy unit field value procs
    #if {$field == {} || $unit == {} || $value == {}} {
        #return
    #}

d396 5
d419 13
d478 5
d486 10
a495 1
wm withdraw .
@
