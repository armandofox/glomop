head	1.63;
access;
symbols
	Yatin-final:1.61.2.2
	Yatin:1.61.0.2
	pre-yatin-merge:1.61
	transend-beta2:1.24
	fox-dev:1.24;
locks; strict;
comment	@# @;


1.63
date	98.01.16.22.16.03;	author yatin;	state Exp;
branches;
next	1.62;

1.62
date	98.01.16.21.58.43;	author iang;	state Exp;
branches;
next	1.61;

1.61
date	97.11.09.22.13.42;	author iang;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	97.10.30.17.03.22;	author iang;	state Exp;
branches;
next	1.59;

1.59
date	97.10.30.04.16.54;	author iang;	state Exp;
branches;
next	1.58;

1.58
date	97.10.30.02.26.26;	author iang;	state Exp;
branches;
next	1.57;

1.57
date	97.10.28.05.07.44;	author iang;	state Exp;
branches;
next	1.56;

1.56
date	97.10.28.02.30.14;	author fox;	state Exp;
branches;
next	1.55;

1.55
date	97.10.28.01.38.33;	author fox;	state Exp;
branches;
next	1.54;

1.54
date	97.10.27.22.09.44;	author iang;	state Exp;
branches;
next	1.53;

1.53
date	97.10.27.20.00.02;	author iang;	state Exp;
branches;
next	1.52;

1.52
date	97.10.26.00.33.08;	author fox;	state Exp;
branches;
next	1.51;

1.51
date	97.10.24.02.53.19;	author iang;	state Exp;
branches;
next	1.50;

1.50
date	97.10.23.18.34.24;	author iang;	state Exp;
branches;
next	1.49;

1.49
date	97.10.23.17.19.04;	author iang;	state Exp;
branches;
next	1.48;

1.48
date	97.10.18.18.30.07;	author iang;	state Exp;
branches;
next	1.47;

1.47
date	97.10.18.00.26.49;	author iang;	state Exp;
branches;
next	1.46;

1.46
date	97.10.16.02.58.16;	author iang;	state Exp;
branches;
next	1.45;

1.45
date	97.10.08.01.27.21;	author iang;	state Exp;
branches;
next	1.44;

1.44
date	97.10.07.21.00.08;	author iang;	state Exp;
branches;
next	1.43;

1.43
date	97.10.07.05.50.50;	author iang;	state Exp;
branches;
next	1.42;

1.42
date	97.10.06.04.59.02;	author iang;	state Exp;
branches;
next	1.41;

1.41
date	97.10.06.01.32.31;	author iang;	state Exp;
branches;
next	1.40;

1.40
date	97.10.05.19.26.51;	author iang;	state Exp;
branches;
next	1.39;

1.39
date	97.09.30.20.26.08;	author gribble;	state Exp;
branches;
next	1.38;

1.38
date	97.09.26.03.04.10;	author fox;	state Exp;
branches;
next	1.37;

1.37
date	97.09.26.01.43.51;	author fox;	state Exp;
branches;
next	1.36;

1.36
date	97.09.24.01.57.32;	author gribble;	state Exp;
branches;
next	1.35;

1.35
date	97.09.17.01.29.54;	author fox;	state Exp;
branches;
next	1.34;

1.34
date	97.09.13.00.51.00;	author fox;	state Exp;
branches;
next	1.33;

1.33
date	97.09.12.22.54.15;	author fox;	state Exp;
branches;
next	1.32;

1.32
date	97.09.12.03.13.48;	author fox;	state Exp;
branches;
next	1.31;

1.31
date	97.09.10.05.00.05;	author fox;	state Exp;
branches;
next	1.30;

1.30
date	97.09.10.02.26.24;	author fox;	state Exp;
branches;
next	1.29;

1.29
date	97.09.09.23.56.51;	author fox;	state Exp;
branches;
next	1.28;

1.28
date	97.09.06.01.37.03;	author fox;	state Exp;
branches;
next	1.27;

1.27
date	97.09.06.01.08.51;	author fox;	state Exp;
branches;
next	1.26;

1.26
date	97.09.04.03.43.41;	author fox;	state Exp;
branches;
next	1.25;

1.25
date	97.08.27.19.52.05;	author fox;	state Exp;
branches;
next	1.24;

1.24
date	97.07.31.05.38.24;	author fox;	state Exp;
branches;
next	1.23;

1.23
date	97.07.30.02.28.22;	author fox;	state Exp;
branches;
next	1.22;

1.22
date	97.07.25.18.36.23;	author fox;	state Exp;
branches;
next	1.21;

1.21
date	97.07.25.01.06.35;	author fox;	state Exp;
branches;
next	1.20;

1.20
date	97.07.24.03.19.01;	author fox;	state Exp;
branches;
next	1.19;

1.19
date	97.07.22.02.15.46;	author fox;	state Exp;
branches;
next	1.18;

1.18
date	97.07.16.03.59.52;	author fox;	state Exp;
branches;
next	1.17;

1.17
date	97.07.15.02.43.12;	author fox;	state Exp;
branches;
next	1.16;

1.16
date	97.07.11.22.15.04;	author fox;	state Exp;
branches;
next	1.15;

1.15
date	97.07.10.23.52.07;	author fox;	state Exp;
branches;
next	1.14;

1.14
date	97.07.10.21.21.07;	author fox;	state Exp;
branches;
next	1.13;

1.13
date	97.07.10.06.14.50;	author fox;	state Exp;
branches;
next	1.12;

1.12
date	97.07.09.03.59.44;	author fox;	state Exp;
branches;
next	1.11;

1.11
date	97.07.09.02.46.06;	author fox;	state Exp;
branches;
next	1.10;

1.10
date	97.07.08.03.14.24;	author fox;	state Exp;
branches;
next	1.9;

1.9
date	97.07.03.19.47.50;	author fox;	state Exp;
branches;
next	1.8;

1.8
date	97.07.03.03.32.36;	author fox;	state Exp;
branches;
next	1.7;

1.7
date	97.06.28.03.36.22;	author fox;	state Exp;
branches;
next	1.6;

1.6
date	97.06.25.02.46.59;	author fox;	state Exp;
branches;
next	1.5;

1.5
date	97.06.23.10.24.19;	author fox;	state Exp;
branches;
next	1.4;

1.4
date	97.06.23.08.48.44;	author fox;	state Exp;
branches;
next	1.3;

1.3
date	97.06.23.04.05.58;	author fox;	state Exp;
branches;
next	1.2;

1.2
date	97.06.22.18.31.39;	author fox;	state Exp;
branches;
next	1.1;

1.1
date	97.06.19.00.27.11;	author fox;	state Exp;
branches;
next	;

1.61.2.1
date	97.11.17.22.06.55;	author yatin;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	97.12.01.22.19.23;	author iang;	state Exp;
branches;
next	;


desc
@@


1.63
log
@- new wingman frontend
- new wingman aggregators mechanism
- DistillAsync

(merged from branch Yatin-final)
@
text
@#  Simple -*- perl -*- distiller for text/piml (Pilot markup language)
#

use TACCutils;
use clib;
use Para;
use PilotFonts;
use Layout;
use LWP;

sub message {
    my $err = shift;
    chomp $err;
    $err .= "\n";
    &MonitorClient_Send("WingMan Messages", $err, "Log");
}

sub makeTbmp {
    my ($w, $rs, $h, @@lines, $bits);
    @@lines = grep(tr/ \.:#//dc || 1, split(/\n/, $_[1]));
    $w = 0;
    grep($w = (length($_) > $w ? length($_) : $w), @@lines);
    $rs = int(($w+7)/8)*2;
    grep($_ = substr($_ . ' ' x ($rs*4), 0, ($rs*4)), @@lines);
    $bits = join('',@@lines);
    $bits =~ s/ /00/g;
    $bits =~ s/\./01/g;
    $bits =~ s/:/10/g;
    $bits =~ s/#/11/g;

    $h = $#lines + 1;

    $_[0] = new Para;
    $_[0]->otext(pack('nnnnNNB*', $w*2, $h, $rs, 0, 0, 0, $bits));
    $_[0]->width($w);
    $_[0]->height($h);
}

sub DistillerInit {
    $gProxyHome = &Options_Find("proxy.home");
    &PilotFonts::init_fonts("$gProxyHome/pilotFonts");
    $num_href_prefetches = &Options_Find("wingman.text.prefetch_href") || 0;

    &message("Waiting for PTM....");
    my $status = &InitializeDistillerCache;
    return $status if ($status != 1);
    &message("Got it");
    
    %Images = ();

    # useful constants

    $FRONT_NO_DISTILL = "i1";
    $FRONT_CLI_VERSION = "i14";
    $FRONT_SRCFLAG = "i16";
    $FRONT_NOCACHE = "i13";
    
    $CLI_VERSION_HORIZSCROLL = 0x01000300;
    $CLI_VERSION_ISMAP = 0x01050100;
    $CLI_VERSION_CURRENT_WARN = 0x01050200;

    $MAXSIZE = 32 * 1024;                   # max heap size on pilot
    $LISTBULLET = chr(149);                 # bullet char in pilot's stdFont
    $AREA_MIN = 30 * 20;                    # images smaller than this will be
                                            # not be shrunk

    ## Create the list of internally-known images
    %internalImgs = ();
    &makeTbmp($internalImgs{'broken'}, <<'EOB');
   :..:  #... $
 .: ..#:  #.. $
.: ....::  #. $
# ....#.:   # $
 ...:..# :  # $
.. ##..###    $
.. ####...#   $
....#..####:  $
.......::#.#  $
.......#### : $
........:##.: $
EOB

    &makeTbmp($internalImgs{'internal-gopher-menu'}, <<'EOB');
 ######       $
##::::##      $
#::::::#      $
############# $
#...........# $
#...........# $
#...........# $
#...........# $
#...........# $
#...........# $
############# $
EOB

    &makeTbmp($internalImgs{'internal-gopher-text'}, <<'EOB');
##########    $
#........:#   $
#.....#..::#  $
#....#.#.:::# $
#...#...#...# $
#...#####...# $
#...#...#...# $
#...#...#...# $
#...........# $
#...........# $
############# $
EOB

    &makeTbmp($internalImgs{'internal-gopher-binary'}, <<'EOB');
##########    $
#........:#   $
#..##....::#  $
#.#..#...:::# $
#.#..#......# $
#..##...#...# $
#......:#...# $
#.......#...# $
#......###..# $
#...........# $
############# $
EOB

    &makeTbmp($internalImgs{'internal-gopher-image'}, <<'EOB');
##########    $
#........:#   $
#...#....::#  $
#..#:#...:::# $
#.#####.....# $
#.......##..# $
#......#::#.# $
#.......##..# $
#...........# $
#...........# $
############# $
EOB

    &makeTbmp($internalImgs{'internal-gopher-unknown'}, <<'EOB');
##########    $
#........:#   $
#........::#  $
#........:::# $
#...........# $
#...........# $
#...........# $
#...........# $
#...........# $
#...........# $
############# $
EOB

    ## need icons for internal-gopher-{sound,movie,telnet}

    %flags_for = ('h1'    => $F_SIZE1,
                  'h2'    => $F_BOLD,
                  'h3'    => $F_BOLD,
                  'title' => $F_BOLD,
                  'b'     => $F_BOLD,
                  'i'     => $F_UNDERLINE,
                  );

    ($NO_CLOSE, $CLOSE_NO_NEWLINE, $CLOSE_SOFT_NEWLINE, $CLOSE_HARD_NEWLINE,
     $CLOSE_AND_CLEARBOTH)
        = (0..9);

    %clear_for = ('h1'    => $CLOSE_SOFT_NEWLINE,
                  'h2'    => $CLOSE_SOFT_NEWLINE,
                  'h3'    => $CLOSE_SOFT_NEWLINE,
                  'h4'    => $CLOSE_SOFT_NEWLINE,
                  'h5'    => $CLOSE_SOFT_NEWLINE,
                  'h6'    => $CLOSE_SOFT_NEWLINE,
                  '/h1'    => $CLOSE_HARD_NEWLINE,
                  '/h2'    => $CLOSE_HARD_NEWLINE,
                  '/h3'    => $CLOSE_HARD_NEWLINE,
                  '/h4'    => $CLOSE_HARD_NEWLINE,
                  '/h5'    => $CLOSE_HARD_NEWLINE,
                  '/h6'    => $CLOSE_HARD_NEWLINE,
                  'hr'     => $CLOSE_SOFT_NEWLINE,
                  '/title' =>$CLOSE_AND_CLEARBOTH, 
                  '/table' => $CLOSE_AND_CLEARBOTH,
                  'img'    => $CLOSE_NO_NEWLINE,
                  'a'     => $CLOSE_NO_NEWLINE,
                  '/a'    => $CLOSE_NO_NEWLINE,
                  'tr'    => $CLOSE_SOFT_NEWLINE,
                  'td'    => $CLOSE_SOFT_NEWLINE,
                  'ol'    => $CLOSE_SOFT_NEWLINE,
                  'ul'    => $CLOSE_SOFT_NEWLINE,
                  '/ol'    => $CLOSE_HARD_NEWLINE,
                  '/ul'    => $CLOSE_HARD_NEWLINE,
                  'li'    => $CLOSE_SOFT_NEWLINE,
                  'dd'    => $CLOSE_SOFT_NEWLINE,
                  'dt'    => $CLOSE_SOFT_NEWLINE,
                  'br'    => $CLOSE_HARD_NEWLINE,
                  'p'     => $CLOSE_SOFT_NEWLINE,
                  '/p'    => $CLOSE_SOFT_NEWLINE,
                  'b'     => $CLOSE_NO_NEWLINE,
                  '/b'    => $CLOSE_NO_NEWLINE,
                  'dummy' => $CLOSE_NO_NEWLINE,
                  );

    ##&clib::MonitorClient_Send("Distiller Log", "Wingman started", "Log");

    return 0;
}

sub flags_for {
    $_ = shift;
    s!^/!!;
    return $flags_for{lc $_};
}

sub clear_for {
    my ($tag) = shift;
    return 0 + $clear_for{lc $tag};
}

#
#  try_flow is a state machine that attempts to layout a chunk of paragraph by calling
#  pack_dynamic.  The logic is as follows:
#  S0: attempt to pack; if success, return the remaining (not yet packed)
#       portion and indicate success; otherwise go to state 1.
#  S1: clear to right margin, and try again.  if success, return remaining
#       portion.  otherwise go to state 2.
#  S2: clear to left margin, and try again.  if success, return remaining
#       portion.  otherwise go to state 3.
#  S3: if it's possible to pop a layout frame, do so and then try again.
#       return the result of doing this.

sub try_flow {
    my ($current_par,$ly) = @@_;
    my $retry = 0;
    my ($status,$leftover);
    while (1) {
        ($status,$leftover) = $ly->pack_dynamic
            ($current_par, -1, -1,
             $current_par->font->maxwidth,
             $current_par->font->height);
        # if retry count exceeded
        if ($status >= 0 || $retry >= 3) {  # success, or retry cnt exceeded 
            return ($status,$leftover);
        }
        $retry++;
        if ($retry == 1) {
            # out of horizontal room
            $ly->clearleft;
            next;
        } elsif ($retry == 2) {
            $ly->clearright;
            next;
        } else {                            # $retry==3
            $ly->spop;
            next;
        }
    }
}


#
#  Try to layout a Para.  In so doing, we may have to split it into multiple
#  Para's, since the Pilot requires the width of each Para to be at most the
#  screen width (it doesn't wrap text).
#  ARGS:
#    $par: Original Para
#    $ly: layout object (for laying out paragraphs on page)
#    $in_anchor:  the HREF URL of the link we are inside; if we're not inside a
#      <A ...> construction, the F_LINK field won't be set so $in_anchor will
#      be ignored.
#    $flags:  paragraph attributes.  (Redundant - we could just get this from
#       the $par object...)
#  RETURNS:
#    A list of new Para's that were laid out, if success.
#    An empty list, if the Para that was passed in contained no material to
#       layout.
#    -1, if there wasn't enough room to layout any of $par. 
#

sub layout_paragraph {
    my($par, $ly, $in_anchor, $flags) = @@_;
    my @@pars = ();
    
    $par->link($in_anchor) if $flags & $F_LINK;
    $par->font($PilotFonts::boldFont) if $flags & $F_BOLD;
    $par->font($PilotFonts::largeFont) if $flags & $F_SIZE1;
    $par->close();
    if ($par->otext =~ /\S/) {
        # layout paragraph
        my $status = 0;
        while ($status == 0) {          # more to do
            ($status,$leftover) = &try_flow($par, $ly);
            push(@@pars, $par);
            $par = $leftover if $leftover;
        }
        if ($status < 0) {
            #warn("Ran out of room near " . $par->otext);
            return (-1);
        }
    }
    return @@pars;
}
              
sub parse_main {
    my $FinalStatus = 0;
    my($data,$hdrs,$type,%args) = @@_;
    my $just_did_newline = 0;
    my $baseurl = &get_my_url($hdrs);
    my ($in_list) = 0;
    my ($success) = 0;
    my ($in_pre) = 0;
    my $leftmargin = 0;
    my ($do_close) = $NO_CLOSE;
    my @@pars = ();
    my ($what,$thing,$attrs);
    my ($status,$leftover);
    my ($in_anchor, $src);
    my $tmp;
    my $candolarge = ($args{$FRONT_CLI_VERSION} >= $CLI_VERSION_HORIZSCROLL);
    
    # start off with a blank paragraph and new layout
    
    my $par = new Para $PilotFonts::stdFont;
    ## Ian says: why are we gridding to the stdFont height?  It makes tall
    ## fonts (H1) end up with a lot of space between them...
    my $ly = new Layout (0, 0, $SCREEN_WIDTH, 50000, 1, $par->font->height);

    # if this is NOT a text/html, but rather image/*, "wrap" HTML around it.

    if ($type =~ m!^image/!io) {
	my $bestimage = !!$args{$FRONT_NO_DISTILL};
	my $output_size = ($args{$FRONT_CLI_VERSION} >= $CLI_VERSION_ISMAP);
	$bestimage *= 2 if $candolarge;
        $par->otext("[image $baseurl]");
        ($par,$success) = &process_image( { 'src' => $baseurl,
                                            '_data_' => $data,
                                            '_type_' => $type,
                                        }, $ly, $baseurl, $par, $bestimage,
					$candolarge, $output_size);
        if (!defined ($par)) {
            return('', '', 'text/plain', 8); # distBadInput
        }
        push(@@pars,$par);
        $FinalStatus = ($success ? 0 : 2);  # distFatalError
        goto FINISH;
    }

    ## Make things a little nicer
    $data =~ s/\0//gos;
    $data =~ s/\r\n/\n/gos;
    $data =~ s/\r/\n/gos;

    ## Watch out for text/plain
    if ($type =~ m!^text/plain\b!io || $args{$FRONT_SRCFLAG} == 1) {
	## Try to munge things right
	$data =~ s/\&/\&amp;/gos;
	$data =~ s/\</\&lt;/gos;
	$data =~ s/\>/\&gt;/gos;
	$data =~ s/\n/\<BR\>\n/gos;
    }
        
    if ($type =~ m!^text/!io &&
	$args{$FRONT_CLI_VERSION} < $CLI_VERSION_CURRENT_WARN) {
	## Prepend a warning
	$data = "Warning: this beta version of Top Gun Wingman is about " .
		"to expire.  Please upgrade to the " .
		"<A HREF=\"http://www.isaac.cs.berkeley.edu/pilot/wingman/\">latest version</A>.<P><HR>\n" .
		$data;
    }

    # maintain a "stack" of attributes.  whenever we enter a new tag construct,
    # push a copy of the existing attributes; when we leave a tag construct,
    # pop.  This allows things like <b>text<i>more text</i></b> to work
    # properly, i.e. "more text" will have both the bold and italic flags set.
    
    my @@sticky_attrs = ();
    
    # paragraphs are "closed" (added to the layout) when a tag of some kind is
    # seen.  To catch malformed pages that don't end with </html> (or some kind
    # of tag), add a "dummy" tag to the end of the text.

#open(A, ">>/tmp/clq"); print A "\n$data\n"; close(A);
    $data .= "<DUMMY>";
    
    while (length($data) > 0) {

        ($what,$thing,$attrs) = &next_entity($data);

        next if ($what == 0);               # ignore markup/comments

        if ($what == 2) {                   # text
	    if ($in_pre) {
		if ($thing =~ s/\s*\n(.*)$//s) {
		    substr($data,0,0) = "<BR>$1";
		}
	    } else {
		$thing =~ s/\s*\n\s*/ /sg;  # replace newlines with spaces
	    }
            $thing =~ s/\t/ /sg;            # replace tabs with spaces
            $thing =~ s/&([^;]+);/$TACCutils::entity{$1}/sg;
                                            # expand HTML entities like "&amp;"
            $par->add($thing),$just_did_newline = 0
                unless $thing =~ /^\s*$/;   # add text to current paragraph
            #
            #  don't return a single chunk that is larger than about 1/4 the
            #  maximum size ever returned.  if this is about to happen,
            #  introduce an arbitrary break (using a dummy tag).
            #
            substr($data,0,0) = "<DUMMY>"
                if length($par->otext) > ($MAXSIZE >> 2);
            next;
            
        }
        # tag: possibly close this paragraph, then process tag.

        #if ($thing =~ /^script$/i || $thing =~ /^head$/i) {
            #&zap_to_tag("</$thing>");
            #next;
        #}
        
	if ($thing =~ /^script$/io) {
	    $data =~ s/^.*?\<\s*\/\s*${thing}\s*\>//ios;
	    next;
	}

	if ($thing =~ /^select$/io) {
	    $data =~ s/^.*?\<\s*\/\s*${thing}\s*\>/\[menu\]/ios;
	    next;
	}

        $par->flags($flags = $sticky_attrs[0]);
        $par->link($in_anchor) if $flags & $F_LINK;
        if (&clear_for($thing) != $NO_CLOSE) {
            $next_par = $par->clone();
            $next_par->otext('');
            @@new_pars =  &layout_paragraph($par, $ly, $in_anchor, $flags);
            goto FINISH if $new_pars[0] == -1; # out of room!!
            push(@@pars, @@new_pars) if scalar @@new_pars;
            #$par = new Para $PilotFonts::stdFont;
            $par = $next_par;
        }
        
        #
        # now process the tag...
        #
        if ($thing eq 'base'  && defined($attrs->{href})) {
            $baseurl = $attrs->{href};
            next;
        }
        if ($thing eq 'meta'
            && $attrs->{"http-equiv"} =~ /^refresh$/i
            && $attrs->{"content"} =~ /^\s*(\d+)\s*;\s*url\s*=\s*([^\s;]+)/ ) {
            # insert a link to the new destination
            my $newlink = &canonicalize($2,$baseurl);
            $data = join('', "<h4>[<a href=\"$newlink\">Click ",
                         ($1 > 0 ? "in $1 seconds" : "now"),
                         "to refresh]</h4>",
                         $data);
            next;
        }
        #  do something for frames
        if ($thing eq 'frame' && defined($tmp = $attrs->{'src'})) {
            # insert a link to the frame
            $data = join('', '<h4>[Frame: <a href="',
                         &canonicalize($tmp,$baseurl), '">',
                         $tmp,
                         '</a>]</h4>',
                         $data);
            next;
        }

        if ($thing !~ /^img$/i && $thing !~ m!^/?a$!i) { # tag
            my $flags = &flags_for($thing);

            if (defined $flags) {
                # if this is a close-tag, shift off the corresponding flags.
                # if it's an open-tag, make a copy of the corresponding flags
                # for it.  thus we keep a mini-stack of flags.
                if ($thing =~ m!^/!) {
                    $par->flags(shift @@sticky_attrs);
                    $par->flags_clear($flags);
                } else {
                    unshift(@@sticky_attrs, $sticky_attrs[0] | $flags);
                    $par->flags($sticky_attrs[0]);
                }
            }
            $do_close = &clear_for($thing);
            if ($do_close == $CLOSE_HARD_NEWLINE
                || ((  $do_close == $CLOSE_SOFT_NEWLINE
                     || $do_close == $CLOSE_AND_CLEARBOTH)
                    && !$just_did_newline)) {
                $just_did_newline = 1;
                if ($attrs->{'clear'} =~ /left/i) {
                    $ly->clearleft();
                    $leftmargin = 0;
                } else {
                    $ly->cleartoleft($leftmargin,$par->font->height);
                }
            }
            $in_list++ if (&tag_matches_open($thing,qw(ol ul dl)));
            $in_list-- if ($in_list && &tag_matches_close($thing,qw(ol ul dl)));
            # BUG::should be resetting leftmargin in here somewhere
            $data=('  ' x $in_list).$LISTBULLET.$data
                if ($in_list && &tag_matches_open($thing,qw(li)));
	    $in_pre = 1 if (&tag_matches_open($thing,qw(pre)));
	    $in_pre = 0 if (&tag_matches_close($thing,qw(pre)));
        } elsif ($thing =~ /^a$/i && defined($in_anchor = $attrs->{'href'})) {
            # open href
	    $in_anchor = &canonicalize($in_anchor, $baseurl);
            unshift(@@sticky_attrs,
                    $sticky_attrs[0] | $F_LINK);
        } elsif ($thing =~ m!^/a$!i) {      # close anchor
            undef $in_anchor;
            shift @@sticky_attrs;
            # just in case....to avoid errors due to malformed nested anchors
            $sticky_attrs[0] &= (~ $F_LINK);
        } elsif ($thing =~ /^img$/i  && defined($src = $attrs->{'src'})) {
            # canonicalize the SRC url, unless it's an "internal" image
	    $src = &canonicalize($src, $baseurl)
		unless $src =~ /^internal-gopher-\w+$/o;
            $newpar = $par->clone();
            $newpar->otext("[image $src]");
            ($newpar,$success) =
		&process_image($attrs, $ly, $src, $newpar,
                               $args{$FRONT_NO_DISTILL}, $candolarge,
			       ($args{$FRONT_CLI_VERSION}
				    >= $CLI_VERSION_ISMAP));
            if ($newpar) {
                #  BUG::If the image was an imagemap, TURN OFF the Link field
                #  for this Para, since we don't yet handle imagemaps correctly.
                if (exists($attrs->{'ismap'})) {
		    if ($args{$FRONT_CLI_VERSION} >= $CLI_VERSION_ISMAP) {
			$newpar->flags_set($F_IMAGE_ISMAP); ## We can do 'ismap'
		    } else {
			$newpar->flags_clear($F_LINK); ## We can't do it
		    }
                } elsif (exists($attrs->{'usemap'})) {
                    &message("Clearing LINK flag for imagemap");
                    $newpar->flags_clear($F_LINK);
                    # BUG::should we also clear LINK_ALT flag???
                }
                push(@@pars, $newpar);
		$just_did_newline = 0;
                if ($attrs->{'align'} =~ /left/i) {
                    $leftmargin = $newpar->x + $newpar->width + 2;
                    $leftmargin = 0 if $leftmargin > $SCREEN_WIDTH-1;
                }
            }
        }  else {
            # warn "Nothing!";
            # image
        }
        
    }
    
  FINISH:
    return ($FinalStatus,@@pars);
}

#
#  Process an inline image by fetching it, passing it to the correct distiller
#  for scaling and format conversion, laying it out on the current page, and
#  packing the result (with its x/y coords, size, link field, and refinement
#  field) into a Para structure.
#  ARGS:
#    $attrs:  hash reference to the tag attributes for the <IMG> tag
#    $ly: the layout object, used for laying out the image on the page
#    $src:  the complete canonicalized source URL for the original image
#    $p: the Para structure into which the image is to be packed
#    $best: if 0, use the normal scaling rules.
#           if 1, clip to full pilot screen.
#           if 2, deliver "original size", to a limit of about 100Kpixels.
#    $candolarge: if true, browser can handle images larger than the screen
#  RETURNS:
#    The Para object $p modified to contain the new image data, if success.
#    Undef, if failure.  (Usually this means the image could not be fit onto
#       the current page; if this happens, the caller may want to force a
#       clear-to-left-margin operation on the page, and try again.)
#

sub process_image {
    my ($attrs,$ly,$src,$p,$best,$candolarge,$output_size) = @@_;
    my %attrs = %$attrs;
    my ($reqx,$reqy) = (0,0);
    my ($x,$y) = (0,0);
    my ($serv_x,$serv_y) = (0,0);
    my ($srcxy);
    my($stat,$hdrs,$data);
    my ($cmd,$q,$buf);
    my $success = 0;
    my $headers = '';
    my ($pinned, $shrank);

    $headers = "User-Agent: Top Gun Wingman (Pilot OS/2.0)\r\n";
    $headers .= "Accept: image/gif, image/jpeg\r\n\r\n";

    $reqx = $attrs{'width'} if defined $attrs{'width'};
    $reqy = $attrs{'height'} if defined $attrs{'height'};
    $srcxy = join(' ',$src,$reqx+0,$reqy+0);

    #  if we have a cached version of the data for this image from a previous
    #    instance of this SAME image on the SAME page, use it.  Otherwise fetch
    #    and distill, etc.
    
    if (defined ($q=$Images{$srcxy})) {
        &message("Postprocessed $src cached\n");
        $buf = $q->otext;
        $x = $q->width;
        $y = $q->height;
        $success = 1;
    } elsif (defined ($q=$internalImgs{$src})) {
        &message("Interal $src cached\n");
        $buf = $q->otext;
        $x = $q->width;
        $y = $q->height;
        $success = 1;
    } else {
        # start with fail fallback
        $buf = $internalImgs{'broken'}->otext;
        $x = $internalImgs{'broken'}->width;
        $y = $internalImgs{'broken'}->height;

        &message("Fetching image: $src");

        if (defined ($attrs->{'_data_'}) && defined ($attrs->{'_type_'})) {
            $data = $attrs->{'_data_'};
            $type = $attrs->{'_type_'};
        } else {
            ($stat,$hdrs,$data) = &Clib_Redir_Fetch($src, $headers, 5);
            if ($stat != 0 || $hdrs !~ /^(\S+\s+)?200/) {
                &message( "Image processing of $src failed: $hdrs");
                goto IMG_FINISH;
            }
            $type = $1 if $hdrs =~ /content-type:\s*(\S+)/i;
        }
        $type =~ tr/A-Z/a-z/;
        
        #  Set arguments: colors = 4, 2bit = 1

        #my($argSizeX,$argSizeY,$argColors,$arg2bit,$nbuf);
        my($argSizeX,$argSizeY,$nbuf);

        #$argColors = &make_argument('i', 1511, 4);
        #$arg2bit = &make_argument('i', 1501, 1);

        if ($type =~ m!^image/jpe?g$!io) {
            ($x,$y) = &jpeg_size(\$data);
            &message(sprintf("JPEG size is %dx%d",$x,$y));
        } elsif ($type =~ m!^image/gif$!io) {
            ($x,$y) = &gif_size(\$data);
            &message(sprintf("Gif size is %dx%d",$x,$y));
        } else {
            &message("Bad image type '$type' for $src");
            return undef;
        }
	## change x and y to match the requested width and height
	if ($reqx && $reqy) {
	    $x = $reqx;
	    $y = $reqy;
	} elsif ($reqx) {
	    $y *= $x ? ($reqx/$x) : 0;
	    $x = $reqx;
	} elsif ($reqy) {
	    $x *= $y ? ($reqy/$y) : 0;
	    $y = $reqy;
	}
        
	$x = 1 if $x < 1;
	$y = 1 if $y < 1;
	($serv_x, $serv_y) = ($x, $y);
	$pinned = 0; $shrank = 0;
        if (!$best) {
            #
            # not $best: normal image scaling rules apply
            #
	    my $ratio = 1.0;
	    if ($y > 44) {
		$ratio = 4.0;
		$shrank = 2;
	    } elsif ($y > 22) {
		$ratio = 2.0;
		$shrank = 1;
	    }
	    $x /= $ratio;
	    $y /= $ratio;
        }
	## But in any case, pin to fit
	if (($best != 2) && ($x > $SCREEN_WIDTH - 1)) {
            my $ratio = $x/($SCREEN_WIDTH - 1);
            $x /= $ratio;
            $y /= $ratio;
	    $pinned = 1 unless $candolarge;
	} elsif ($best == 2) {
	    my $size = $x * $y;
	    &message("very best size is $x by $y");
	    if ($size > 130000) { # Don't make this any bigger; any one
				  # piece can only be 32K large
		my $origx = $x;
		$ratio = sqrt($size/130000);
		$x /= $ratio;
		$x = 8 * int($x / 8);
		$x = 1 if $x == 0;
		$ratio = $origx/$x;
		$y /= $ratio;
		$pinned = 1;
	    }
	}
	if ($shrank && !$pinned) {
	    # insert LINK_ALT field for refinement
	    $_[3]->flags_set($F_LINK_ALT);
	    $_[3]->link_alt(&tomagic($src, "i1=1"));
	    &message("Refinement available: " . $_[3]->link_alt);
	}
	$x = (int($x) || 1);
	$y = (int($y) || 1);
        $argSizeX = &make_argument('i', 1601, $x);
        $argSizeY = &make_argument('i', 1602, $y);
	&message("transformed size is $x by $y");
        

	my $req;

        &message("Calling distiller for MIME type $type");
        ($exitstatus,$req) = &DistillAsync($type, "wingman.img2Tbmp",
                                            "", $data,
                                            $argSizeX, $argSizeY);

        &message("DistillAsync exitstatus = $exitstatus");
        if ($exitstatus == 0) {             # distOk
            $buf = [undef, $req];
            $success = 1;
        } else {
	    &DistillDestroy($req);
	}
    }

  IMG_FINISH:
    # We now have the image data and image dimensions, either from the cached
    # copy or from processing it on the fly (or from "broken image" icon).
    if ($output_size) {
	$_[3]->serv_x($serv_x);
	$_[3]->serv_y($serv_y);
	$_[3]->flags_set($F_IMAGE_HAS_SERV_SIZE);
    }
    $_[3]->otext($buf);
    $_[3]->flags_set($F_IMAGE_2BIT | $F_IMAGE);
    $_[3]->width($x);
    $_[3]->height($y);

    # cache for possible future use.  If distillation failed, we "negative
    # cache" the image to avoid trying distillation next time.  Note that since
    # this "cache" only lasts the lifetime of 1 page request, reloading the
    # page can clear an erroneous error condition here.
    $Images{$srcxy} = $_[3]->clone() unless defined ($Images{$srcxy});
    
    my $align = ($attrs->{align} =~ /right/i? 1 : -1);

    if ($best == 2) {
        # Grow the layout to the width of the selected image.
        #  ASSUMPTION: $best==2 will only be invoked on a page containing a
        # single image and nothing else.  If this assumption is violated,
        # growing the layout to the width of the selcted image might not be
        # enough (if there's already text etc. on this "row" of the page).  In
        # this case we'll just get the same behavior as we would get if the
        # image was too wide to fit ("out of room packing image").
        $ly->grow_frame_to_atleast($x+1);
    }

    my $result = $ly->pack_static($p, $align, -1);
    
    if ($result == -1) {        # out of room!!
        &message("Out of room, trying clearleft");
        $ly->clearleft();        
        $result = $ly->pack_static($p, $align, -1);
    }
    if ($result == -1) {
        &message( "Out of room packing image $src");
        return undef;
    } else {
        return (wantarray? ($p,$success) : $p);
    }
}



#
#  Given a bunch of "pieces", make them into a big glob which will be delivered
#  as a tSTR resource of size at most $MAXSIZE.  Return the resource and any
#  remaining pieces that didn't fit (ie that would have overflowed $MAXSIZE).
#

sub make_rsrc_from_pieces {
    my $maxsize = shift @@_;
    my @@pieces = @@_;
    my ($p, $lp);
    my $last_backptr = 0;
    my $rsrc = '';
    # optionally sort pieces by y-coord here, though it shouldn't be a problem
    # normally 
    while ($p = shift @@pieces) {
        $lp = length($p);
        # insure the piece has an even length.  (Warn if it doesn't since at
        # this point it should!)
        &message( "Zero length piece!  This is almost certainly wrong!"), next
            if $lp == 0;
        if ($lp & 1) {
            &message("Odd number of bytes ($lp) in $p");
            die;
        }
        #unshift(@@pieces,$p), last if (length($rsrc) + $lp > $MAXSIZE);
        # make back-pointer correct
        substr($p,0,2) = pack("n", - $last_backptr);
        $last_backptr = $lp + 14;
        $rsrc .= $p;
	last if length($rsrc) > $MAXSIZE;
    }
    # BUG::don't have length checking.
    $rsrc .= pack("n", 0xffff);
    return ($rsrc, @@pieces);
}

sub make_stringy_piece {
    my ($para) = shift;
    my $attrs = $para->flags;
    my $initx = $para->x;
    my $inity = $para->y;
    my $str = $para->otext;
    my $is_nullstr_only = 1;
    my $xextent = $para->width;
    my $yextent = $para->height;
    my $data = '';
    my $l;
    my $totallen = 0;

    # format of stringy piece is described in cvs:browser/wintext.c.
    # Not duplicated here because keeping the descriptions in sync is too
    # hard. 

    my $hdr = pack("n7", 
                   0, 0, $initx,$inity,
                   $xextent,$yextent,
                   $attrs);

    # Make sure we actually received the data
    if (ref($str) eq "ARRAY") {
	## This is an array reference, of the form [ $data, $request ].
	## Exactly one of the two entries should be defined.
	if (!defined $str->[0]) {
	    ## Wait until this data is present
	    ## This next call will clean up $str->[1] and set it to undef
	    my ($status, $body, $hdrs) = &DistillRendezvous($str->[1], undef);
	    if (!defined $str->[1]) {
		&message("Rendezvous successful");
		$str->[0] = $body;
	    } else {
		## Some kind of error occurred during Rendezvous
		&message("Rendezvous unsuccessful: status = $status");
		&DistillDestroy($str->[1]);
		$str->[0] = $internalImgs{'broken'}->otext;
	    }
	}
	$str = $str->[0];
    }

    # if we have to insert original x and y dims, do it now
    if (($attrs & $F_IMAGE) && ($attrs & $F_IMAGE_HAS_SERV_SIZE)) {
	$hdr .= pack('nn', $para->serv_x, $para->serv_y);
	$totallen += 4;
    }

    # if a link, insert the length byte and link data.

    if ($attrs & $F_LINK) {
        $para->link($para->link . chr(0));
        $l = length($para->link);
        $para->link($para->link .  '*')
            if $l & 1;
        my $link = pack("n A*", $l, $para->link);
        $hdr .= $link;
        $totallen += length($link);
    }

    # if there is a LINK_ALT field (alternate link to follow for refinement or
    #  drill-down), add that field too.

    if ($attrs & $F_LINK_ALT) {
        $para->link_alt($para->link_alt . chr(0));
        $l = length($para->link_alt);
        $para->link_alt($para->link_alt . '*')
            if $l & 1;
        my $link_alt = pack("n A*", $l, $para->link_alt);
        $hdr .= $link_alt;
        $totallen += length($link_alt);
    }

    #  If a bitmap, just return the "raw" content, which is already in
    #  pilot-bitmap format.
    #  BUG::the content should be in some generic format, and should be
    #  converted to pilot-specific format in this function.

    if ($attrs & $F_IMAGE) {
        ($str .= chr(0xaa))
            if length($str) & 1;
        $is_nullstr_only = 0;
        $data = $str;
        $totallen += length($str);
    } else {
        #  otherwise, it's text content.  it has already been split into
        #  lines.  the indices of the start char of each line are in the
        #  'lines' array.  Pack up these lines into (length,data).
        #  
        #  BUG::the @@lines array was created when the paragraph was initially
        #  line-split, but not re-created after the paragraph was broken into
        #  multple paragraphs!!
        #my @@lines = @@{$para->{'lines'}};
        my @@lines = $para->font->split_string($para->otext,$para->width," ");
        grep(s/\s+$//, @@lines);
        my $last = 0;
        my $li;
        foreach $x (@@lines) {
            next unless $x;
            # insure text is even length
            $x .= ' ' if (length($x) & 1);
            $data .= pack("n", length($x));
            $data .= $x;
            $is_nullstr_only=0 if length($x);
        }
        $data .= pack("n",0);
        $totallen += length($data);
    }
    # fix forward ptr in this piece.
    # in addition to the length of this data, add 14 to skip over
    #  the header bytes till the next forward_ptr.
    substr($hdr,2,2) = pack("n",10+4+$totallen);
    return ($is_nullstr_only? undef : $hdr . $data);
}

#
#  attempt to prefetch all the images.  this will get only most of them,
#  because (a) the regexp may not work for weird url's, (b) a "base href=" tag
#  in the body can override the url that's being used for canonicalization.
#  as long as we get most of them we should be fine.
#
sub prefetch_images {
    my ($data,$url,$nocache_arg) = @@_;
    my %urls = ();
    my (@@data, @@pages);
    my ($fetched, $href);
    my $headers = '';
    local($@@) = ',';

    $headers .= "User-Agent: Top Gun Wingman (Pilot OS/2.0)\r\n";
    $headers .= "Accept: image/gif, image/jpeg\r\n";
    if (defined($nocache_arg) && $nocache_arg==1) {
	$headers .= "Pragma: no-cache\r\n";
    }
    $headers .= "\r\n";
    @@data = split(/<\s*img/is, $data);
    for (@@data) {
        next unless m/src\s*=\s*\"?([^>\"\s]+)/is; #"
        $urls{$1}++, &Clib_Async_Fetch(&canonicalize($1,$url), $headers)
            unless $urls{$1};
    }
    if ($num_href_prefetches) {
	$fetched = 0;
	@@pages = split(/<\s*a\s*/is, $data);
	for (@@pages) {
	    next unless m/href\s*=\s*\"?([^>\"\s]+)/is; #"
	    $href = $1;
	    ++$fetched;
	    last if $fetched >= $num_href_prefetches;
	    $urls{$href}++, &Clib_Async_Fetch(&canonicalize($href,$url),
		$headers) unless $urls{$href};
	}
    }
    &message(sprintf("Prefetching: %s", join(',',(keys(%urls)))));
}

sub DistillerMain {
    my($data,$hdrs,$type,%args) = @@_;
    my $para;
    my @@rsrc = ();
    my @@pa;
    my $str = '';
    my $url = &get_my_url($hdrs);
    my $status = 0;                         # what eventually gets returned as
                                            # distiller status                       
    # pilot's screen width pixels
    $SCREEN_WIDTH = ($args{$FRONT_CLI_VERSION} >= $CLI_VERSION_HORIZSCROLL)
			? 156 : 160;
    
    &message("Request for $url");

    # clear out the array of cached converted images
    %Images = ();

    # strip out NULs from input data
    #$data =~ tr/\0//d;
    
    # start prefetching any inline images, etc. so they'll be ready later
    &prefetch_images($data,$url,$args{$FRONT_NOCACHE});

    # parse_main does all the work of "generic layout" and parsing
    ($status,@@pa) = &parse_main($data, $hdrs, $type, %args);

    &message("Collecting pieces");
    foreach $para (@@pa) {
        next unless ref($para) eq 'Para';
        $nextpiece = make_stringy_piece($para);
        push(@@rsrc, $nextpiece) if $nextpiece;
    }

    if (scalar @@rsrc == 0) {
        # no blocks successfully laid out, bummer
        &message("$url: No blocks could be laid out");
        return('', '', 'application/x-wingman', 8); # distBadInput
    }
    # pack as much as we have room for on the Pilot
    ($str,@@rsrc) = &make_rsrc_from_pieces($MAXSIZE, @@rsrc);
    if (@@rsrc) {
        &message( "Warning: page overflowed $MAXSIZE bytes");
        # BUG::should cache the remaining pages here, and add a link at the
        # bottom of the one we deliver.
    }
    &message("Wingman returns status $status");
    return ($str, "HTTP/1.0 200 Ok\r\nContent-Type: application/x-wingman\r\nLocation: $url\r\n", 'application/x-wingman', $status);
}

1;
@


1.62
log
@.
@
text
@d42 1
a42 1
    $num_href_prefetches = &Options_Find("prefetch.href") || 0;
d621 1
a621 1
        &message("Processing image: $src");
d710 1
d719 2
d722 1
a722 1
        ($exitstatus,$nbuf,$hdrs) = &Distill($type, "wingman.img2Tbmp",
d726 1
a726 1
        &message("Distill exitstatus = $exitstatus buflen = " . length($nbuf));
d728 1
a728 1
            $buf = $nbuf;
d730 3
a732 1
        }
d842 21
d1003 2
@


1.61
log
@Server side imagemaps and some code cleanup
@
text
@d60 1
d360 9
@


1.61.2.1
log
@- Modularized the wingman frontend by splitting wing_go_proc into
  multiple smaller functions

- New aggregator mechanism for wingman proxies. The WingDispatch worker
  receives a request with a special content-type application/x-wingman-agg.
  The body of the request contains the full aggregator url

  The worker should return a valid HTTP response, which might be a
  pilot-ready document (i.e. an x-wingman/* document) or an HTTP
  redirect to a new URL, or whatever it chooses!)

- The WingDispatcher is now expected to weed out unintelligible content-types
  and return a content-type of x-wingman/<integer> to the frontend, where
  <integer> represents the integral content type returned to the pilot client.

- Agglist: this appears at the dispatcher as a special aggregator request
  with a url of agg://agglist/ (this URL is actually defined in the
  gm_options file, so the worker should check against the gm_options
  entry, rather than a hard-coded entry). The worker that handles this
  request *MUST* return a document with content type
  x-wingman/2 and the actual agglist as part of the data.

  For old browsers, the data part of this response is stuffed into an
  appropriate metadata field by the frontend before sending the reply to
  the client (i.e. it is backward compatible). For browsers with the new
  version number, the browser will no longer set any special flags in the
  metadata field of the client request. Instead it will explicitly request
  for the agg://agglist/ url. It'll check the ContentType field in the
  response for content type 2 to match up the correct response.

- Created a new version number for the agglist changes:
  #define CLIENT_VERSION_NEWAGG 0x01050200

- gm_options changes:
  Here are the three new gm_options entries for wingman: (the
  wingman.text.prefetch_href replaces the old prefetch.href entry)

  wingman.about_url: http://www.isaac.cs.berkeley.edu/pilot/wingman/about-
  wingman.agglist_url: agg://agglist/
  wingman.text.prefetch_href: 10

- PTM changes:
  - Background distillers work. Specify the -e flag before the -- in the
    gm_options line for the distiller. The PTM will IMMEDIATELY respawn the
    distiller if it crashes. This mechanism is still very simple and naive
  - Distillers can rename themselves: API function DistillerReregister.
@
text
@d42 1
a42 1
    $num_href_prefetches = &Options_Find("wingman.text.prefetch_href") || 0;
@


1.61.2.2
log
@Added DistillAsync and friends
@
text
@d611 1
a611 1
        &message("Fetching image: $src");
a699 1
	    &message("Refinement available: " . $_[3]->link_alt);
a707 2
	my $req;

d709 1
a709 1
        ($exitstatus,$req) = &DistillAsync($type, "wingman.img2Tbmp",
d713 1
a713 1
        &message("DistillAsync exitstatus = $exitstatus");
d715 1
a715 1
            $buf = [undef, $req];
d717 1
a717 3
        } else {
	    &DistillDestroy($req);
	}
a826 21
    # Make sure we actually received the data
    if (ref($str) eq "ARRAY") {
	## This is an array reference, of the form [ $data, $request ].
	## Exactly one of the two entries should be defined.
	if (!defined $str->[0]) {
	    ## Wait until this data is present
	    ## This next call will clean up $str->[1] and set it to undef
	    my ($status, $body, $hdrs) = &DistillRendezvous($str->[1], undef);
	    if (!defined $str->[1]) {
		&message("Rendezvous successful");
		$str->[0] = $body;
	    } else {
		## Some kind of error occurred during Rendezvous
		&message("Rendezvous unsuccessful: status = $status");
		&DistillDestroy($str->[1]);
		$str->[0] = $internalImgs{'broken'}->otext;
	    }
	}
	$str = $str->[0];
    }

a966 2

    &message("Collecting pieces");
@


1.60
log
@o Preserve aspect ratio when pinning verybest images
o Enable clib debugging from env vars so you can do:
    CLIB_DEBUGGING=1 perl -cw -I ../xs/lib foo.pl
@
text
@d58 3
d316 1
a316 1
    my $candolarge = ($args{$FRONT_CLI_VERSION} >= 0x01000300);
d329 1
d336 1
a336 1
					$candolarge);
d513 3
a515 1
                               $args{$FRONT_NO_DISTILL}, $candolarge);
d519 7
a525 1
                if (exists($attrs->{'ismap'}) || exists($attrs->{'usemap'})) {
d570 1
a570 1
    my ($attrs,$ly,$src,$p,$best,$candolarge) = @@_;
d574 1
d658 1
d723 5
d729 1
a729 1
    $_[3]->flags_set($F_BOLD | $F_BITMAP);
d827 6
d863 1
a863 1
    if ($attrs & $F_BITMAP) {
d951 2
a952 1
    $SCREEN_WIDTH = ($args{$FRONT_CLI_VERSION} >= 0x01000300) ? 156 : 160;
@


1.59
log
@Rounding problem fixed
@
text
@d672 1
d676 2
@


1.58
log
@Added winman dispatcher.  .prc's in .zip's now works
@
text
@d674 1
d688 1
@


1.57
log
@Yay!  Big images work! :-)
@
text
@d621 1
a621 1
        if ($type eq 'image/jpeg') {
d623 2
a624 1
        } elsif ($type eq 'image/gif') {
d690 1
a690 1
        ($exitstatus,$nbuf,$hdrs) = &Distill($type, "img2Tbmp",
d921 1
a921 1
    $SCREEN_WIDTH = ($args{$FRONT_CLI_VERSION} >= 0x01000300) ? 157 : 160;
d955 1
a955 1
    return ($str, '', 'application/x-wingman', $status);
@


1.56
log
@*** empty log message ***
@
text
@d58 1
a58 1
    $MAXSIZE = 20 * 1024;                   # max heap size on pilot
d313 1
d326 1
a326 1
	$bestimage *= 2 if ($args{$FRONT_CLI_VERSION} >= 0x01000300);
d331 2
a332 1
                                        }, $ly, $baseurl, $par, $bestimage);
d509 1
a509 1
                               $args{$FRONT_NO_DISTILL});
d549 1
d558 1
a558 1
    my ($attrs,$ly,$src,$p,$best) = @@_;
d665 2
a666 2
            $pinned = 1;
	} else {                            # best==2
d668 4
a671 2
	    if ($size > 30000) { # XXX: fix this constant
		$ratio = sqrt($size/30000);
d768 1
a768 1
        unshift(@@pieces,$p), last if (length($rsrc) + $lp > $MAXSIZE);
d773 1
@


1.55
log
@added code to handle best==2:wide images cause layout to grow to image width
@
text
@d719 1
a719 1
        $ly->right($x+1);
@


1.54
log
@Fixed some memory bugs, added "view source"
@
text
@d51 7
d324 2
a325 2
	my $bestimage = $args{"i1"};
	$bestimage *= 2 if ($args{"i14"} >= 0x01000300);
d345 1
a345 1
    if ($type =~ m!^text/plain\b!io || $args{"i16"} == 1) {
d506 2
a507 1
		&process_image($attrs, $ly, $src, $newpar, $args{"i1"});
d544 3
a546 3
#    $best: if true, deliver the "best possible" representation for this image
#       (probably because it's a refinement), as opposed to delivering the
#       "default" representation for inline images.
d604 1
a604 1
                goto FINISH;
d658 6
a663 8
	if ($best != 2 || 1) {
	    if ($x > $SCREEN_WIDTH - 1) {
		my $ratio = $x/($SCREEN_WIDTH - 1);
		$x /= $ratio;
		$y /= $ratio;
		$pinned = 1;
	    }
	} else {
d695 1
a695 1
  FINISH:
d710 12
d914 1
a914 1
    $SCREEN_WIDTH = ($args{"i14"} >= 0x01000300) ? 157 : 160;
d925 1
a925 1
    &prefetch_images($data,$url,$args{"i13"});
@


1.53
log
@.
@
text
@d338 1
a338 1
    if ($type =~ m!^text/plain\b!io) {
@


1.52
log
@Dispatcher can be used as the "chain specification" worker for running
real TACC chains.  it uses the new X-static-route mechanism.
@
text
@d317 2
d323 1
a323 1
                                        }, $ly, $baseurl, $par, $args{"i1"});
d650 15
a664 5
	if ($x > $SCREEN_WIDTH - 1) {
	    my $ratio = $x/($SCREEN_WIDTH - 1);
	    $x /= $ratio;
	    $y /= $ratio;
	    $pinned = 1;
d896 1
a896 1
    $SCREEN_WIDTH = ($args{"i14"} >= 0x01000300) ? 156 : 160;
@


1.51
log
@o Pass client version to workers
o Make room for scrollbar
@
text
@d305 2
a306 1

d423 22
@


1.50
log
@.
@
text
@a54 1
    $SCREEN_WIDTH = 160;                    # pilot's screen width pixels
d860 2
@


1.49
log
@Handle .zip files
@
text
@d485 1
@


1.48
log
@Allowed illegal relative URLs that look like "http:/relative/path"
@
text
@d331 3
a333 3
    $data =~ s/\0//go;
    $data =~ s/\r\n/\n/go;
    $data =~ s/\r/\n/go;
d338 4
a341 4
	$data =~ s/\&/\&amp;/go;
	$data =~ s/\</\&lt;/go;
	$data =~ s/\>/\&gt;/go;
	$data =~ s/\n/\<BR\>\n/go;
@


1.47
log
@Added Clib_Redir_Fetch
@
text
@d460 1
a460 1
            $in_anchor = (new URI::URL $in_anchor)->abs($baseurl)->as_string;
d470 1
a470 1
            $src = (new URI::URL $src)->abs($baseurl)->as_string
@


1.46
log
@various bugfixes, etc.
@
text
@d568 1
a568 1
            ($stat,$hdrs,$data) = &Clib_Fetch($src, $headers);
@


1.45
log
@The clib harness now does something sensible (as opposed to refusing to run)
with inter-distiller calls.
Also, layout improvement
@
text
@d42 1
d310 2
d524 1
a524 1
    my ($ox,$oy) = (0,0);
d536 3
a538 3
    $ox = $attrs{'width'} if defined $attrs{'width'};
    $oy = $attrs{'height'} if defined $attrs{'height'};
    $srcxy = join(' ',$src,$ox+0,$oy+0);
d594 11
a604 2
	$x = $ox if $ox != 0;
	$y = $oy if $oy != 0;
d606 2
d819 2
d832 1
a832 1
        next unless m/src\s*=\s*\"?([^\"\s]+)/is; #"
d835 12
@


1.44
log
@more improvements to HTML distiller
@
text
@d528 1
d594 2
a595 13
        if ($best) {
            # this is a refinement, so bypass the scaling rules in favor of
            # delivering the largest possible version.
            &message(sprintf("Delivering refinement of a %dx%d image",$x,$y));
            if ($x > $SCREEN_WIDTH - 1) {
                my $ratio = $x/($SCREEN_WIDTH - 1);
                $x /= $ratio;
                $y /= $ratio;
            } else {
                # no shrink
                ;
            }
        } else {
d599 10
a608 14
            if ($x * $y < $AREA_MIN) {
                # no shrink
                ;
            } elsif ($x >> 2 > $SCREEN_WIDTH - 2) {
                my $ratio = $x/($SCREEN_WIDTH-2);
                $y /= $ratio;
                $x /= $ratio;
            } else {
                $x /= 4;
                $y /= 4;
		# insert LINK_ALT field for refinement
		$_[3]->flags_set($F_LINK_ALT);
		$_[3]->link_alt(&tomagic($src, "i1=1"));
            }
d610 16
a625 2
        $argSizeX = &make_argument('i', 1601, $x=int($x));
        $argSizeY = &make_argument('i', 1602, $y=int($y));
@


1.43
log
@Lots o' improvements...
@
text
@d334 5
a338 3
	## Pretend we saw <PRE>; note that this isn't quite right; if tags
	## appear in text/plain, they should be _displayed_, not _parsed_.
	$in_pre = 1;
d386 4
a389 4
        if ($thing =~ /^script$/i || $thing =~ /^head$/i) {
            &zap_to_tag("</$thing>");
            next;
        }
d391 10
@


1.42
log
@o Watch out for illegal chars in URLs
o Do something sort of right with text/plain
o Add some more icons for FTP/gopher
@
text
@d327 5
d350 1
d509 3
a511 1
    my ($x,$y);
d520 4
d528 1
a528 1
    if (defined ($q=$Images{$src})) {
d578 2
d640 1
a640 1
    $Images{$src} = $_[3]->clone() unless defined ($Images{$src});
@


1.41
log
@o Made newlines in <PRE> work
o FTP now works! (but we need to design some icons for text, image, etc.)
@
text
@d86 57
a142 1
    ## need icons for internal-gopher-{text,binary,sound,image,movie,unknown}
d327 6
d347 1
a347 1
    while ($data) {
@


1.40
log
@2-bit image distillation is now faster and better quality
@
text
@d18 21
d56 29
d86 1
a86 15
    $BrokenImageBytes = "001e000f00040000" .
        "0000000000000000" .
            "0008000000960d50" .
                "061783501855a0d0" .
                    "3157603c0565c80c" .
                        "14f5fc0010ee6600" .
                            "14ff570016fdff00" .
                                "1575ff801555adc0" .
                                    "1555ff2015556f60" .
                                        "00000008"
                                            ;
    $BrokenImage = new Para;
    $BrokenImage->otext(pack("H*", $BrokenImageBytes));
    $BrokenImage->width(15);
    $BrokenImage->height(15);
d241 2
d257 1
a257 2
    if ($type =~ m!image/!i) {
        my $success;
d292 7
a298 1
            $thing =~ s/\s*\n\s*/ /sg;      # replace newlines with spaces
d373 2
d386 3
a388 2
            # canonicalize the SRC url
            $src = (new URI::URL $src)->abs($baseurl)->as_string;
d391 2
a392 1
            $newpar = &process_image($attrs, $ly, $src, $newpar, $args{"i1"});
d448 1
a448 10
    $headers .= "Accept: image/gif, image/jpeg, image/pnm\r\n\r\n";

    # insert LINK_ALT field for refinement (unless this image IS the refinement
    # of something).
    # BUG::should only do this if we shrank the image significantly.

    unless ($best) {
        $_[3]->flags_set($F_LINK_ALT);
        $_[3]->link_alt(&tomagic($src, "i1=1"));
    }
d460 6
d468 3
a470 3
        $buf = $BrokenImage->otext;
        $x = $BrokenImage->width;
        $y = $BrokenImage->height;
d531 3
d721 1
a721 1
    $headers .= "Accept: image/gif, image/jpeg, image/pnm\r\n";
@


1.39
log
@Headers are now sent properly for fetching and prefetching inlined
images.
@
text
@d445 2
a446 1
        my($argSizeX,$argSizeY,$argColors,$arg2bit,$nbuf);
d448 2
a449 2
        $argColors = &make_argument('i', 1511, 4);
        $arg2bit = &make_argument('i', 1501, 1);
d453 1
a453 1
        } elsif ($type =~ 'image/gif') {
d489 2
a490 2
        $argSizeX = &make_argument('i', 1523, $x=int($x));
        $argSizeY = &make_argument('i', 1524, $y=int($y));
d494 1
a494 1
        ($exitstatus,$nbuf,$hdrs) = &Distill($type, "transend/image/tbmp",
d496 1
a496 2
                                            $argSizeX, $argSizeY,
                                            $argColors, $arg2bit);
@


1.38
log
@yucko - refinement now works.  someone had put a linein
transend.text.piml that deletes all NUL's from the input, but that's the
wrong thing for non-ascii data such as images.  also minor fix to
perl_stub to cover corner case of null input data or null input
metadata.  the debugging msgs in Tbmp_munger are now just that - not
spewage to stderr.
@
text
@d398 4
d434 1
a434 1
            ($stat,$hdrs,$data) = &Clib_Fetch($src,'');
d673 2
d676 1
a676 1
	$headers = "Pragma: no-cache\r\n";
d678 1
@


1.37
log
@inter distiller calling seems to work in context of pilot perl distiller
@
text
@d200 1
d220 1
d222 4
a225 4
        $par = &process_image( { 'src' => $baseurl,
                                 '_data_' => $data,
                                 '_type_' => $type,
                             }, $ly, $baseurl, $par, $args{"i1"});
d230 1
d368 1
a368 1
    return @@pars;
d397 1
d417 1
d437 2
a438 1

d441 1
a441 1
        my($argSizeX,$argSizeY,$argColors,$arg2bit,$nbuf,$mimeType);
d446 1
a446 2
        if ($type =~ m!image/jpeg!i) {
            $mimeType = 'image/jpeg';
d448 1
a448 2
        } elsif ($type =~ m!image/gif!i) {
            $mimeType = 'image/gif';
d450 1
d459 1
d488 2
a489 2
        &message("Calling Distill....");
        ($exitstatus,$nbuf,$hdrs) = &Distill($mimeType, "transend/image/tbmp",
d495 4
a498 1
        $buf = $nbuf if $exitstatus == 0;   # distOk
d527 1
a527 1
        return $p;
d688 3
a690 1

d697 1
a697 1
    $data =~ tr/\0//d;
d703 1
a703 1
    @@pa = &parse_main($data, $hdrs, $type, %args);
d722 2
a723 1
    return ($str, '', 'application/x-wingman', 0);
@


1.36
log
@Two changes:
  1) NULs are stripped from html
  2) distiller now obeys the FRONT_NOCACHE arg when fetching inlines.
@
text
@d22 5
d433 6
a438 2
        # convert jpeg or gif to ppm.
        # BUG::we should call TACCutils::ConvertToType here
a439 2
        my $file = &util::dump($data);
        my $file2 = &util::mktemp;
d441 1
a442 1
            $cmd ="| djpeg -pnm | pnmscale -xsize %d | ppmquant -fs 4 >$file2";
d444 1
a445 1
            $cmd = "| giftopnm | pnmscale -xsize %d | ppmquant -fs 4 >$file2";
d478 2
a479 2
        $x = int($x);
        $y = int($y);
a480 17
        $cmd = "cat $file " . $cmd;
        $cmd = sprintf($cmd, $x);
        if (system($cmd)) {
            &message("$cmd: exit " . ($? >> 8));
            return undef;
        }

        #warn "$src Width height = " . $_[3]->width . "," . $_[3]->height;
        # convert to a pilot bitmap
        my $pilot_bmp;

        my $file3 = &util::mktemp;
        $cmd = "$gProxyHome/bin/ppmtoTbmp -2bit $file2 > $file3";
        if (system($cmd)) {
            &message("$cmd: exit " . ($? >> 8));
            return undef;
        }
d482 5
a486 2
        $buf = &util::slurp($file3);
        unlink ($file,$file2,$file3);
d488 2
@


1.35
log
@undid the bugs introduced in moving from system() to open(PIPE), but retained the image-caching and broken-image changes
@
text
@d660 1
a660 1
    my ($data,$url) = @@_;
d662 1
d664 4
d670 2
a671 2
        next unless m/src\s*=\s*\"?([^\"\s]+)/is; #" 
        $urls{$1}++, &Clib_Async_Fetch(&canonicalize($1,$url), '')
d690 3
d694 1
a694 1
    &prefetch_images($data,$url);
@


1.34
log
@formatting and similar bug fixes to distiller
@
text
@d30 1
d74 1
a74 1
                  'img'   => $CLOSE_NO_NEWLINE,
d205 1
a205 2
    my $next_par;
    
d431 1
d435 1
a435 1
            $cmd ="| djpeg -pnm | pnmscale -xsize %d | ppmquant -fs 4 | ";
d438 1
a438 1
            $cmd = "| giftrans -b white | giftopnm | pnmscale -xsize %d | ppmquant -fs 4 | ";
d441 1
a441 1
            goto FINISH;
d462 1
a462 1
            } elsif (0 && $x >> 2 > $SCREEN_WIDTH - 2) {
d474 1
a474 1
        $cmd .= "$gProxyHome/bin/ppmtoTbmp -2bit > $file2 2>/dev/null";
d476 4
d481 13
a493 3
        &message("$cmd: $!") unless open(P, $cmd);
        print P $data;
        &message("$cmd: $!"),goto FINISH unless close(P);
a494 2
        $buf = &util::slurp($file2);
        unlink ($file2);
d499 1
a499 1
    # copy or from processing it on the fly (or from the "broken image" icon).
d505 5
a509 2
    # cache for possible future use.
    $Images{$src} = $_[3]->clone() unless defined $Images{$src};
a518 1

d522 2
a524 2
    unlink $file2;
    return $p;
@


1.33
log
@fixed bug: going directly to an image URL resulted in a screwed-up LINK_ALT url
@
text
@d30 16
d73 1
d204 2
a205 1

d273 2
d278 2
a279 1
            $par = new Para $PilotFonts::stdFont;
d409 5
d423 1
a423 1
                return undef;
a430 1
        my $file = &util::dump($data);
d434 1
a434 1
            $cmd ="| djpeg -pnm | pnmscale -xsize %d | ppmquant -fs 4 >$file2";
d437 1
a437 1
            $cmd = "| giftopnm | pnmscale -xsize %d | ppmquant -fs 4  >$file2";
d440 1
a440 1
            return undef;
d461 1
a461 1
            } elsif ($x >> 2 > $SCREEN_WIDTH - 2) {
d473 1
a473 1
        $cmd = "cat $file " . $cmd;
a474 4
        if (system($cmd)) {
            &message("$cmd: exit " . ($? >> 8));
            return undef;
        }
d476 3
a478 13
        #warn "$src Width height = " . $_[3]->width . "," . $_[3]->height;
        # convert to a pilot bitmap
        my $pilot_bmp;

        my $file3 = &util::mktemp;
        $cmd = "$gProxyHome/bin/ppmtoTbmp -2bit $file2 > $file3";
        if (system($cmd)) {
            &message("$cmd: exit " . ($? >> 8));
            return undef;
        }

        $buf = &util::slurp($file3);
        unlink ($file,$file2,$file3);
d480 2
d484 1
d486 1
a486 1
    # copy or from processing it on the fly.
d503 1
a506 2
    } else {
        return $p;
d508 2
@


1.32
log
@Optimizations to Pilot distiller:
- 'wx' and 'string_width' optimized, since profiler indicated a lot of
time was being spent there.
- postprocessed images are now cached during processing of the same
page, so addditional instances of an inline image are free.
- Clib_Async_Fetch is now used in the distiller to prefetch images, so
they'll be in the cache when we're ready to distill them.
Also: added 'canonicalize' routine (to TACCutils) for canonicalizing
relative urls, fixed some perl warnings in PilotFonts and SimpleFont.
@
text
@d200 1
a200 1
                             }, $ly, $src, $par, $args{"i1"});
@


1.31
log
@Fixes for bugs 44 & 61 in transend.text.piml.  Changes to layout.tcl to
improve fidelity (red and blue are now used to indicate <i> and links,
respectively) and unpack_tstr.pl.
@
text
@d22 2
a365 1
    #warn "Processing $src\n";
d367 1
a367 1
    my $cmd;
d369 3
a371 1
    &message("Processing image: $src");
d373 14
a386 3
    if (defined ($attrs->{'_data_'}) && defined ($attrs->{'_type_'})) {
        $data = $attrs->{'_data_'};
        $type = $attrs->{'_type_'};
d388 12
a399 4
        ($stat,$hdrs,$data) = &Clib_Fetch($src,'');
        if ($stat != 0 || $hdrs !~ /^(\S+\s+)?200/) {
            &message( "Image processing of $src failed: $hdrs");
            return undef;
a400 2
        $type = $1 if $hdrs =~ /content-type:\s*(\S+)/i;
    }
d402 2
a403 2
    # convert jpeg or gif to ppm.
    # BUG::we should call TACCutils::ConvertToType here
d405 8
a412 20
    my $file = &util::dump($data);
    my $file2 = &util::mktemp;
    if ($type =~ m!image/jpeg!i) {
        ($x,$y) = &jpeg_size(\$data);
        $cmd ="| djpeg -pnm | pnmscale -xsize %d | ppmquant -fs 4 >$file2";
    } elsif ($type =~ m!image/gif!i) {
        ($x,$y) = &gif_size(\$data);
        $cmd = "| giftopnm | pnmscale -xsize %d | ppmquant -fs 4  >$file2";
    } else {
        &message("Bad image type '$type' for $src");
        return undef;
    }

    if ($best) {
        # this is a refinement, so bypass the scaling rules in favor of
        # delivering the largest possible version.
        if ($x > $SCREEN_WIDTH - 1) {
            my $ratio = $x/($SCREEN_WIDTH - 1);
            $x /= $ratio;
            $y /= $ratio;
d414 2
a415 2
            # no shrink
            ;
d417 12
a428 11
    } else {
        #
        # not $best: normal image scaling rules apply
        #
        if ($x * $y < $AREA_MIN) {
            # no shrink
            ;
        } elsif ($x >> 2 > $SCREEN_WIDTH - 2) {
            my $ratio = $x/($SCREEN_WIDTH-2);
            $y /= $ratio;
            $x /= $ratio;
d430 34
a463 2
            $x /= 4;
            $y /= 4;
a464 7
    }
    $x = int($x);
    $y = int($y);
    
    # insert LINK_ALT field for refinement (unless this image IS the refinement
    # of something).
    # BUG::should only do this if we shrank the image significantly.
d466 3
a468 9
    unless ($best) {
        $_[3]->flags_set($F_LINK_ALT);
        $_[3]->link_alt(&tomagic($src, "i1=1"));
    }
    $cmd = "cat $file " . $cmd;
    $cmd = sprintf($cmd, $x);
    if (system($cmd)) {
        &message("$cmd: exit " . ($? >> 8));
        return undef;
d471 3
d478 3
a480 14
    #warn "$src Width height = " . $_[3]->width . "," . $_[3]->height;
    # convert to a pilot bitmap
    my $pilot_bmp;

    my $file3 = &util::mktemp;
    $cmd = "$gProxyHome/bin/ppmtoTbmp -2bit $file2 > $file3";
    if (system($cmd)) {
        &message("$cmd: exit " . ($? >> 8));
        return undef;
    }

    my $buf = &util::slurp($file3);
    unlink ($file,$file2,$file3);
    $_[3]->otext($buf);
d623 19
d649 1
d652 6
a658 1

@


1.30
log
@tims config file
@
text
@d270 10
a279 5
                $thing =~ m!^/!
                    ? shift @@sticky_attrs
                        : unshift(@@sticky_attrs, $sticky_attrs[0] | $flags)
                            ;
                $par->flags($sticky_attrs[0]);
@


1.29
log
@fixed relative-URL bug discovered by anthony and ian
@
text
@d492 2
@


1.28
log
@added robustness checking to various execs, which should aid error behavior
@
text
@d262 1
a262 1
        if ($thing eq 'base') {
@


1.27
log
@Removed compile time dependencies: proxy.home and proxy.perlmod are now
config file options, so perl_stub doesn't need to know them at compile
time (it constructs the -I path at runtime from the options file
values).  Options_Find() has been exported to Perl (in
clib.xs) and is emulated for the harness (in clib.pm).  pilotFonts
directory was added for wingman distiller.  PilotFonts module now has an
explicit init_fonts() call that supplies the dir name containing the
pilot fonts.  Added documentation to clib.pm, TACCutils.pm,
PilotFonts.pm and SimpleFont.pm.  removed all path-related dependencies
in existing distillers and unpack_tstr.pl, and added font path error
checking to layout.tcl
@
text
@d13 2
d363 1
a363 1
    &message("Processing $src\n");
d371 1
a371 1
            &message( "Image processing of $src failed: $hdrs\n");
d433 4
a436 1
    system($cmd) and &message("$cmd: exit " . ($? & 255));
d447 5
a451 1
    system("$gProxyHome/bin/ppmtoTbmp -2bit $file2 > $file3");
d493 1
a493 1
            &message("Odd number of bytes ($lp) in $p\n");
d602 2
a603 2

    &message("Request for " . &get_my_url($hdrs));
d614 6
d623 2
@


1.26
log
@fixes for bug 57
@
text
@d17 3
d442 1
a442 1
    system("/home/fox/tcsproxy/bin/ppmtoTbmp -2bit $file2 > $file3");
@


1.25
log
@Added refinement ("get original") functionality to transend.text.piml;
the ALT_LINK field is now filled in with a magic URL which, when
retrieved, should cause the refined image to be delivered at the maximum
screen width.  Also, the LINK flag is turned off for imagemaps so that
users can't click thru the imagemap, at least until we have imagemaps
working.  Flag definitions in Para.pm are now consistent with new LINE
and ALT_LINK fields; the NEWLINE flag (used internally by the distiller)
was redefined since it was colliding with a client-specific flag called
LINE.  Changed unpack_tstr.pl to understand ALT_LINK in the data
format.  Added the magic-URL-manipulation function to TACCutils.pm since
several distillers will be using it.
@
text
@d85 12
d106 6
a111 3
        return ($status,$leftover)
            if ($status >= 0 || $retry >= 2);
        if ($retry == 0) {
a113 1
            $retry++; 
d115 1
a115 1
        } else  {                           # $retry == 1 
d117 3
a119 1
            $retry++;
@


1.24
log
@*** empty log message ***
@
text
@d110 19
a128 1
# some constants
d147 1
a147 1
            return undef;
d161 1
a161 1
    my ($what,$thing,%attrs);
d177 1
a177 1
                             }, $ly, $src, $par);
d233 2
a234 2
            goto FINISH unless defined @@new_pars;
            push(@@pars, @@new_pars);
d242 1
a242 1
            $baseurl = $attribs{href};
d284 1
d288 1
a288 1
            $newpar = &process_image(\%attrs, $ly, $src, $newpar);
d290 7
d314 19
d335 1
a335 1
    my ($attrs,$ly,$src,$p) = @@_;
d372 11
a382 8
    if (($x * $y < $AREA_MIN)
        || ($x <= $SCREEN_WIDTH)) {
        # no shrink
        ;
    } elsif ($x >> 2 > $SCREEN_WIDTH - 2) {
        my $ratio = $x/($SCREEN_WIDTH-2);
        $y /= $ratio;
        $x /= $ratio;
d384 14
a397 2
        $x /= 4;
        $y /= 4;
a398 1
    
d402 8
a409 1

d513 13
a589 1
    warn "return\n";
@


1.23
log
@Toplevel Makefile slimmed down.  lib/ subdir and corresponding install
targets added, to prep for binary dist.  client_lib now has
strerror()-style error reporting.  Fixed bug in dispatch.c that caused
prefs call for an aggregator to coredump (strcpy called on null ptr).
text/html distiller more streamlined and correctly "munges" user prefs
form items.  GetOptions moved from clib to TaccUtils.  perl_stub now
passes arguments named "s11", "i2", etc. instead of "11", "2", etc.
@
text
@d183 1
a183 1
        ($what,$thing,%attrs) = &next_entity($data);
d243 1
a243 1
                if ($attrs{'clear'} =~ /left/i) {
d255 1
a255 1
        } elsif ($thing =~ /^a$/i && defined($in_anchor = $attrs{'href'})) {
d265 1
a265 1
        } elsif ($thing =~ /^img$/i  && defined($src = $attrs{'src'})) {
d272 1
a272 1
                if ($attrs{'align'} =~ /left/i) {
d299 3
a301 3
    if (defined ($attrs{'_data_'}) && defined ($attrs{'_type_'})) {
        $data = $attrs{'_data_'};
        $type = $attrs{'_type_'};
d362 1
a362 1
    my $align = ($attrs{align} =~ /right/i? 1 : -1);
@


1.22
log
@support for fetching standalone images
@
text
@d223 4
@


1.21
log
@temporary commit so anthony can make; still tracking memory bug interaction frontend/clientlib
@
text
@d150 1
a150 1
    my $ly = new Layout (0, 0, $SCREEN_WIDTH-1, 50000, 1, $par->font->height);
d152 16
d290 1
a290 1
    my($stat,$hdrs,$data) = &Clib_Fetch($src,'');
d292 13
a304 4
    
    if ($stat != 0 || $hdrs !~ /^(\S+\s+)?200/) {
        &message( "Image processing of $src failed: $hdrs\n");
        return undef;
d312 1
a312 1
    if ($hdrs =~ m!image/jpeg!i) {
d315 1
a315 1
    } elsif ($hdrs =~ m!image/gif!i) {
d319 1
a319 1
        &message("Bad image $src");
d323 2
a324 1
    if ($x * $y < $AREA_MIN) {
@


1.20
log
@Changed the enum in clib.h to a series of #defines, so that the perl
extension builder automatically makes the values available to perl.
Much work on the perl html munger (using the new lexer): <img> attribute
GMMAGIC is now converted to URL magic in the SRC attribute by the
munger.  MonitorClient_Send and GetOptions are now available to perl
distillers; this required changes to perl_stub and clib.xs.  Bug fix to
tag_from_attribs routine in TACCutils.pm.  Tcl/tk simulator now supports
"reload" and "open", and canvas is resized correctly.  Perl harness now
turns on  perl -w by default.
@
text
@a3 4
BEGIN {
    push(@@INC, qw(/home/fox/tcsproxy/xs/lib
                  ));
}
d11 4
d278 1
a278 1
        warn "Image processing of $src failed: $hdrs\n";
d285 2
a286 1
    unlink "/tmp/j$$";
d289 1
a289 1
        $cmd ="| djpeg -pnm | pnmscale -xsize %d | ppmquant -fs 4 2>/dev/null >/tmp/j$$";
d292 4
a295 1
        $cmd = "| giftopnm | pnmscale -xsize %d | ppmquant -fs 4 2>/dev/null >/tmp/j$$";
d312 1
a312 1
            
d314 3
a316 4
    open(PROG, sprintf($cmd,$x))
        or warn $!;
    print PROG $data;
    close PROG;
d326 5
a330 5
    open(PROG, "/home/fox/tcsproxy/bin/ppmtoTbmp -2bit /tmp/j$$ 2>/dev/null |");
    my $buf = '';
    $buf .= $_ while <PROG>;
    close PROG;
    unlink "/tmp/j$$";
d336 1
a336 1
        warn "Out of room, trying clearleft";
d341 1
a341 1
        warn "Out of room packing image $src";
d369 1
a369 1
            warn "Odd number of bytes ($lp) in $p\n";
a464 1
    my $file = shift @@ARGV || "tSTR07cf.bin";
d466 2
a467 4
    eval { &MonitorClient_Send("WingMan Messages", "Wingman started", "Log") };
    if ($@@) {
        warn "Bummer: $@@\n";
    }
d469 1
a469 1
    #@@pars = &parse_main($data,$hdrs,$type,%args);
a470 1

d479 1
a479 1
        warn "Warning: page overflowed $MAXSIZE bytes";
d481 1
a481 1

@


1.19
log
@fixed makefile bugs to compile under both linux and solaris
@
text
@d4 4
d68 3
a146 1
    
d152 5
d159 6
a164 1
    $data .= "<DUMMY>";                       # to make sure last par is closed
d172 2
a173 2
            $thing =~ s/\s*\n\s*/ /sg;
            $thing =~ s/\t/ /sg;
d175 1
d177 1
a177 1
                unless $thing =~ /^\s*$/;
d181 1
a181 1
            #  introduce an arbitrary break.
a186 5
#         } elsif ($thing =~ /^script$/i
#                  || $thing =~ /^head$/i) {
#             &zap_to_tag("</$thing>");
#             next;

d190 5
d464 4
@


1.18
log
@various fixes to layout.  still not perfect:  <BR> is always treated as <BR CLEAR=LEFT> but fixing this requires giving the layout engine some notion of the current left margin.  this could probably be done by detecting when the current packing region is split, as is done in Layout.pm line 209.
@
text
@a3 5
BEGIN {
    push(@@INC, qw(
                  /home/fox/tcsproxy/xs/lib
                  ));
}
d14 51
a64 50
    $LISTBULLET = chr(149);                 # in pilot's stdFont
    $AREA_MIN = 30 * 20;
    $SCREEN_WIDTH = 160;

%flags_for = ('h1'    => $F_BOLD,
              'h2'    => $F_BOLD,
              'h3'    => $F_BOLD,
              'title' => $F_BOLD,
              'b'     => $F_BOLD,
              'i'     => $F_UNDERLINE,
              );

($NO_CLOSE, $CLOSE_NO_NEWLINE, $CLOSE_SOFT_NEWLINE, $CLOSE_HARD_NEWLINE,
 $CLOSE_AND_CLEARBOTH)
    = (0..9);

%clear_for = ('h1'    => $CLOSE_AND_CLEARBOTH,
              'h2'    => $CLOSE_AND_CLEARBOTH,
              'h3'    => $CLOSE_AND_CLEARBOTH,
              'h4'    => $CLOSE_AND_CLEARBOTH,
              'h5'    => $CLOSE_AND_CLEARBOTH,
              'h6'    => $CLOSE_AND_CLEARBOTH,
              '/h1'    => $CLOSE_AND_CLEARBOTH,
              '/h2'    => $CLOSE_AND_CLEARBOTH,
              '/h3'    => $CLOSE_AND_CLEARBOTH,
              '/h4'    => $CLOSE_AND_CLEARBOTH,
              '/h5'    => $CLOSE_AND_CLEARBOTH,
              '/h6'    => $CLOSE_AND_CLEARBOTH,
              'hr'     => $CLOSE_AND_CLEARBOTH,
              '/title' =>$CLOSE_AND_CLEARBOTH, 
              '/table' => $CLOSE_AND_CLEARBOTH,
              'a'     => $CLOSE_NO_NEWLINE,
              '/a'    => $CLOSE_NO_NEWLINE,
              'tr'    => $CLOSE_SOFT_NEWLINE,
              'td'    => $CLOSE_SOFT_NEWLINE,
              'ol'    => $CLOSE_HARD_NEWLINE,
              'ul'    => $CLOSE_HARD_NEWLINE,
              '/ol'    => $CLOSE_HARD_NEWLINE,
              '/ul'    => $CLOSE_HARD_NEWLINE,
              'li'    => $CLOSE_SOFT_NEWLINE,
              'dd'    => $CLOSE_SOFT_NEWLINE,
              'dt'    => $CLOSE_SOFT_NEWLINE,
              'br'    => $CLOSE_HARD_NEWLINE,
              'p'     => $CLOSE_HARD_NEWLINE,
              '/p'    => $CLOSE_SOFT_NEWLINE,
              'b'     => $CLOSE_NO_NEWLINE,
              '/b'    => $CLOSE_NO_NEWLINE,
              'dummy' => $CLOSE_NO_NEWLINE,
              );
return 0;
d133 1
a134 1
    my $par = new Para $PilotFonts::stdFont;
d139 5
a147 4
    # eliminate newlines from the non-tag data
    # BUG::html_regsub is broken!!
    #$data = &html_regsub($data, 's/\s+/ /sg');

d153 1
a153 1
        next if ($what == 0);               # markup/comments
d159 1
a159 1
            $par->add($thing)
d201 11
a211 8

            if (($do_close == $CLOSE_HARD_NEWLINE)
                || $do_close == $CLOSE_AND_CLEARBOTH
                || ($do_close == $CLOSE_SOFT_NEWLINE)) {
                #&& !$just_did_newline)) {
                #$ly->skip($PilotFonts::stdFont->height);
                $ly->clearleft();
                #$just_did_newline = 1;
d215 2
a216 1
            $data=($LISTBULLET x $in_list).$data
d233 7
a239 1
            push(@@pars, $newpar) if ($newpar);
d273 1
a273 1
        ($x,$y) = unpack("v2", substr($data,6,4));
a327 32
sub jpeg_size {
    my $data = shift;
    my($M_SOF0) = 0xC0;
    my($M_SOF15) = 0xCF;
    my($M_SOI) = 0xD8;
    my($M_EOI) = 0xD9;
    my($M_SOS) = 0xDA;
    my($M_COM) = 0xFE;
    my ($c1,$l,$d,$w,$h);
    $data = $$data if ref($data) eq 'SCALAR';

    my ($x,$y) = (-1,-1);
    ($x,$y) = unpack("C2", $data);
    $data =~ s/^..//;
    return (0,0) unless ($x == 0xff && $y == $M_SOI); # 0xff, M_SOI
    while (1 && $data) {
        ($c1,$d1) = unpack("C2", $data);
        $data = substr($data,2);
        return (0,0) unless $c1 == 0xff;
        if ($d1 >= $M_SOF0 && $d1 <= $M_SOF15) {
            ($l,$d,$h,$w) = unpack("nCnn", $data);
            return ($w,$h);
        } elsif ($c1 == $M_SOS || $c1 == $M_EOI) {
            last;
        } else {
            $l = unpack("n", $data);
            $data = substr($data, $l);
        }
    }
    return (0,0);
}
        
a438 32
sub print_stringy_piece {
    my $r = shift;
    my ($len,$s);
    
    my ($bp,$fp,$x,$y,$xextent,$yextent,$flags) = unpack("n7",$r);
    $r = substr($r,14);

    $bp = 65536-$bp;
    print STDERR ("<$bp >$fp  geom=+$x+$y(${xextent}x$yextent)  Flags:");
    print STDERR ("F_BOLD ") if $flags & $F_BOLD;
    print STDERR ("F_ITALIC ") if $flags & $F_ITALIC;
    if ($flags & $F_BITMAP) {
        printf STDERR ("F_BITMAP\n");
        printf STDERR ($flags & $F_BOLD ? "[Bitmap 2bit]\n" : "[Bitmap 1bit]\n");
    } else {
        print STDERR ($flags & $F_SIZE2 & $F_SIZE1 ? "F_SIZE3 "
                      : $flags & $F_SIZE2 ? "F_SIZE2 "
                      : $flags & $F_SIZE1 ? "F_SIZE1 "
                      : "F_SIZE0 ");
        print STDERR "\n";
        while (($len = unpack("n",$r)) != 0) {
            $r = substr($r, 2);
            #printf ("Length: %d\n",$len);
            $s = unpack("A$len", $r);
            $len++ if $len & 1;                 # guarantee 2byte alignment
            $r = substr($r,$len);
            print STDERR  "$s // ";
        }
        print STDERR "\n";
    }
}

a451 1
        #printf("(%d,%d) `%s'\n", $para->x,$para->y,$para->otext);
@


1.17
log
@makefile changes to link pthreads only at end, which was causing severe bad behaviors under linux since different people were calling different signal()s.  SIGHUP is now used instead of SIGUSR1 to signal components to reinitialize themselves, and SIGTERM is used to kill them gracefully.  Layout stuff for Pilot works but is still inelegant.
@
text
@d31 3
a33 2
($NO_CLOSE, $CLOSE_NO_NEWLINE, $CLOSE_AND_NEWLINE, $CLOSE_AND_CLEARBOTH)
    = (0..3);
a36 1
              'h2'    => $CLOSE_AND_CLEARBOTH,
d47 2
a48 1
              '/title' => $CLOSE_AND_CLEARBOTH,
d52 12
a63 10
              'tr'    => $CLOSE_AND_NEWLINE,
              'td'    => $CLOSE_AND_NEWLINE,
              'ol'    => $CLOSE_AND_NEWLINE,
              'ul'    => $CLOSE_AND_NEWLINE,
              'li'    => $CLOSE_AND_NEWLINE,
              'dd'    => $CLOSE_AND_NEWLINE,
              'dt'    => $CLOSE_AND_NEWLINE,
              'br'    => $CLOSE_AND_NEWLINE,
              'p'     => $CLOSE_AND_NEWLINE,
              '/p'    => $CLOSE_AND_NEWLINE,
a70 113
# tag scanning state machine:
# state Initial: consume whitespace, tag name, optionally more whitespace
#    on ">" goto End
#    on other non-whitespace goto Attrib
# state Attrib: consume attrib name, optional whitespace
#    on "=" goto Value
#    on other non-whitespace goto Attrib
# state Value:
#    collect whitespace + (quotedstring OR  nonquote+nonquotedstring)
#        
# Possible return values:
#  (0,$markup,@@comments)
#  (1,$tag,%attribs)
#  (2,$text)
        
sub next_entity {
    my ($tag,%attribs);
    $_ = $_[0];                             # note, this is a REFERENCE!  we
                                            # modify $_[0] in place.
    if (/^<!/) {                            # markup: consume and discard
        my $in_comment = 0;
        my $m = '';                         # result
        my ($c,@@c) = ();                    # comments
        while (1) {
            if (!$in_comment) {
                # scan till single or double quotes, end of markup, or comment
                s/^[^->\"\']*//s;           #'" 
                $m .= $&;
                $m .= $&,last if s/^>//;    # end of markup = done
                $in_comment = 1, next if s/^--//; # start comment
                s/^([\"\'])[^\1]*?\1//s;     # '"else consume quoted string
                $m .= $&;
            } else {
                # BUG::to parse sgml-compliant comments, the code below
                # really should have been:
                #  $c .= $& while s/^[^-]+|^-[^-]//s;
                #  ...
                #  s/^--//;
                #  However, that fails because some cretin decided that both
                # "--" and ">" are legal javascript operators, so it's possible
                # to see the following string while ostensibly inside a
                # comment, which would close the comment in sgml:
                #   if ( a-- == foo) { ....
                # or even worse:
                #   if ( a--> foo) { ...
                # so instead we use a regexp that collects "netscape javascript
                # broken" style comments, which are presumed to always end
                #  in "-->".
                #  One way around this is for the caller of this function to
                # ignore everything until "/script" if "<script>" is seen.
                # collect comment
                $c .= $& while s/^[^-]+|^-(?!-\s*>)//s;
                push(@@c,$c);
                $c = '';
                s/^--\s*>//;
                $in_comment = 0;
                last;
            }
        }
        $_[0] = $_;
        return (0,$m,@@c);
    } elsif (/^</) {                        # looking at tag: return it
        # scan tag:
        s/^<\s*([^>\s]+)\s*//s;                 # consume tag name, whitespace
        $tag = $1;
        while( s{
            (^[^>\s=]+)                    # attrib name
                (\s*=\s*                    
                 ((\"[^\"]*\")             # quoted string...
                  |([^\">\s]*)))?             # or unquoted...both optional
                     \s*}{}sx ) {                # trailing whitespace "
            ($attribs{lc $1} = $3) =~ s!^"|"$!!g;
        }
        s/^>//s;
        $_[0] = $_;
        return (1,$tag,%attribs);
    } else {
        # snarf all text up to but not including start of next tag
        s/[^<]*(?=<)//s
            or s/[^<]*$//s         # catch untagged text at end of page
                or die;
        $_[0] = $_;
        return (2,$&);
    }
}
        
sub zap_to_tag {
    $_ = shift;
    my $str = shift;

    s!^.*?$str!!;
    $_[0] = $_;
    return $&;
}

sub tag_matches_open {
    my ($tag,@@list)=@@_;
    for (@@list) {
        return $_ if m!^\s*$tag$!i;
    }
    return undef;
}

sub tag_matches_close {
    my $tag = shift;
    return (($tag =~ s!^/!!
             && &tag_matches_open($tag,@@_)));
}

sub tag_matches {
    return (&tag_matches_open(@@_) || &tag_matches_close(@@_));
}

d125 1
a125 1
            warn("Ran out of room near " . $par->otext);
d134 1
d160 1
d162 2
a163 1
            $par->add($thing) unless $thing =~ /^\s*$/;
d182 1
d203 1
d205 5
a209 3
            $do_close = &clear_for($thing);
            if ($do_close == $CLOSE_AND_NEWLINE
                || $do_close == $CLOSE_AND_CLEARBOTH) {
d211 1
a216 1
            next;
a221 1
            next;
d225 2
a226 1
            next;
d229 4
a232 6
            $newpar = &process_image(\%attrs, $ly, $src);
            if (defined $newpar) {
                $newpar->flags_set($sticky_attrs[0]);
                push(@@pars,$newpar);
            }
            next;
d237 1
d246 1
a246 1
    my ($attrs,$ly,$src) = @@_;
d291 3
a293 4
    my $p = new Para $PilotFonts::stdFont;
    $p->flags_set($F_BOLD | $F_BITMAP);
    $p->width($x);
    $p->height($y);
d295 1
a295 1
    #warn "$src Width height = " . $p->width . "," . $p->height;
d304 1
a304 1
    $p->otext($buf);
@


1.16
log
@*** empty log message ***
@
text
@d6 1
a6 2
                  /home/fox/nfs-home/286proj/tcsproxy/xs/lib
                  /home/fox/nfs-home/286proj/tcsproxy/xs/lib/i586-linux/5.003
d16 3
a18 2
sub main::DistillerInit {
    $MAXSIZE = 10 * 1024;                   # max heap size on pilot
d20 2
a21 1
    0;
a22 1
}
d62 2
a63 1
              '/b'     => $CLOSE_NO_NEWLINE,
d65 2
a66 1

d98 1
a98 1
                s/^([\"\'])[^\1]*\1//s;     # '"else consume quoted string
d160 1
d252 1
a252 1
    my $ly = new Layout (0, 0, 159, 2000, 1, $par->font->height);
d260 1
a260 1
    # do entity substitution and comment stripping from html
d271 7
d279 6
a284 4
        } elsif ($thing =~ /^script$/i
                 || $thing =~ /^head$/i) {
            &zap_to_tag("</$thing>");
            next;
d339 1
a339 1
            warn "Nothing!";
a343 5
    if ($par->otext eq '') {
        # current par hasn't been closed yet
        $par->close();
        push(@@pars, $par);
    }
d352 2
a353 1

d355 3
a357 1
    if ($stat != 0 || $hdrs !~ /^200/) {
d367 2
a368 3
        open(PROG, "| djpeg -scale 1/4 -pnm | ppmquant -fs -map /home/fox/pilot/ppmtoTbmp/q4.map 2>/dev/null >/tmp/j$$") or warn $!;
        print PROG $data;
        close PROG;
d370 2
a371 3
        open(PROG, "| giftopnm | pnmscale -xscale .25 -yscale .25 | ppmquant -fs -map /home/fox/pilot/ppmtoTbmp/q4.map 2>/dev/null >/tmp/j$$") or warn $!;
        print PROG $data;
        close PROG;
d374 22
a395 6
    open(TMP,"/tmp/j$$");
    <TMP>;
    $_ = <TMP>;
    close TMP;
    my($x,$y) = split;
    my $p = new Para $stdFont;
d404 1
a404 1
    open(PROG, "/home/fox/nfs-home/286proj/tcsproxy/bin/ppmtoTbmp -2bit /tmp/j$$ 2>/dev/null |");
d426 34
d504 2
a505 1
    
d518 1
d520 1
a520 1
        $para->link($para->link .  ' ')
d522 3
a524 1
        $hdr .= pack("n A*", $l, $para->link);
d537 1
d560 1
d565 2
a566 2
    substr($hdr,2,2) = pack("n",10+4+length($data));
    return ($is_nullstr_only? undef : $hdr.$data);
a612 2
    warn (sprintf ("%d paragraphs\n", scalar @@pa));
        
d615 1
d617 1
a617 2
        push(@@rsrc, $nextpiece), &print_stringy_piece($nextpiece)
            if $nextpiece;
@


1.15
log
@*** empty log message ***
@
text
@d4 6
d11 1
a11 1
use clib_debug;
d17 1
a17 1
sub DistillerInit {
@


1.14
log
@transend.text.piml
@
text
@d43 2
d189 1
a189 1
            ($current_par, \&measuretext, -1, -1,
d209 23
a231 1

d242 1
a242 2
    my $in_anchor = '';
    my $insert_anchor = 0;
d260 1
d267 15
a281 2
        } elsif ($thing !~ /^img$/i
                 && $thing !~ m!^/?a$!i) {                   # tag
d289 1
a292 1

d300 3
a302 3
                if ($in_list && &tag_matches_open($thing,qw(li dt dd)));
            next if $do_close == $NO_CLOSE;
        } elsif ($thing =~ /^a$/i && defined($attrs{'href'})) {
d304 4
a307 3
            $in_anchor = $attrs{'href'};
            $insert_anchor = 0;
            $do_close = $CLOSE_NO_NEWLINE;
d309 10
a318 5
            $do_close = $CLOSE_NO_NEWLINE;
            $done_with_anchor = 1;          # after this paragraph, done
        } elsif ($thing =~ /^img$/i) {
            $newpar = &process_image(\%attrs, $ly, $baseurl);
            push(@@pars,$newpar) if defined $newpar;
a323 45
        # If a paragraph was closed, add it to the layout.
        # Paragraph with a F_NEWLINE flag means do a clear immediately after
        # laying it out.

        # font change?
        $flags = $par->flags;
        $par->font($PilotFonts::boldFont)
            if $flags & $F_BOLD;
        $par->font($PilotFonts::largeFont)
            if ($flags & $F_SIZE1);
        if ($in_anchor) {
            if ($insert_anchor) {
                $par->flags_set($F_LINK);
                $par->link($in_anchor);
                $insert_anchor = 0, undef $in_anchor
                    if $done_with_anchor;
            } else {
                $insert_anchor++;
            }
        }
        $par->close();
        if ($par->otext =~ /\S/) {
            # layout paragraph
            $status = 0;
            while ($status == 0) {          # more to do
                ($status,$leftover) = &try_flow($par, $ly);
                push(@@pars, $par);
                $par = $leftover if $leftover;
            }
            if ($status < 0) {
                warn("Ran out of room near " . $par->otext);
                goto FINISH;
            }
            $par = new Para $PilotFonts::stdFont;
            $par->font($PilotFonts::boldFont)
                if $flags & $F_BOLD;
            $par->font($PilotFonts::largeFont)
                if ($flags & $F_SIZE1);
            $par->flags($sticky_attrs[0]);
            $par->flags_set($F_NEWLINE), $ly->clearleft()
                if ($do_close == $CLOSE_AND_NEWLINE);
            $par->flags_set($F_NEWLINE), $ly->clearboth()
                if ($do_close == $CLOSE_AND_CLEARBOTH);
        }
        
d337 1
a337 1
    my ($attrs,$ly,$baseurl) = @@_;
a339 6
    warn("Couldn't extract src for image"), die
        unless defined ($src =  $attrs{src});

    $src = (new URI::URL $src)->abs($baseurl)->as_string;

    warn "Processing image $src\n";
d342 1
a395 28
sub measuretext {
    my $what = shift;
    my ($w,$h,$para,$text);
    if ($what eq 'height') {
        ($w,$para) = @@_;
    } else {
        ($w,$h,$para) = @@_;
    }
    $text = $para->otext;
    my ($lht) = $para->font->height;
    
    my @@lines = $para->font->split_string($para->otext, $w, " ");
    # grep(s/\s+$//, @@lines);
    $para->{'lines'} = \@@lines;
    if ($what eq 'height') {
        return (scalar @@lines) * $lht;
    } elsif ($what eq 'lastchar') {
        $h = $lht if ($h < $lht);
        my $nlines = int($h / $lht);
        $nlines = scalar @@lines if ($nlines >= scalar @@lines);
        return (join('', @@lines[0..$nlines-1]),
                join('', @@lines[$nlines..$#lines]),
                $nlines * $lht);
    } else {
        die "Bad call to measuretext: what=$what";
    }
}

a551 1
    open(R, "> $file") or die $!;
d556 2
a557 15
    print R $str;
    close R;
    die;
    system("build-prc foo1.prc 'TGwm' 'TGwm' tSTR07cf.bin")
        and warn $?;
    #print "Run buildprc\n"; <STDIN>;
    open(R, "foo1.prc") or die $!;
    undef $/;
    $r = <R>;
    #$r =~ s/cre1/TGwm/gs;
    $r =~ s/appl/PRpg/gs;
    close R;
    open(R, ">TGwm.prc") or die $!;
    print R $r;
    close R;
@


1.13
log
@*** empty log message ***
@
text
@d17 6
a22 6
%flags_for = ('/h1'    => $F_BOLD,
              '/h2'    => $F_BOLD,
              '/h3'    => $F_BOLD,
              '/title' => $F_BOLD,
              '/b'     => $F_BOLD,
              '/i'     => $F_ITALIC,
d43 2
d68 4
a71 1

d77 43
a119 1
    if (/^</) {                        # looking at tag: return it
d144 8
d171 3
a173 2
    my ($tag) = shift;
    return 0 + $flags_for{lc $tag};
d219 1
a219 1
    my $done_with_anchor = 0;
d222 2
d233 2
d236 1
a236 1
            $thing =~ s/\s*\n\s*//sg;
d239 4
d245 9
a253 1
            $par->flags_set(&flags_for($thing));
d255 1
d268 1
a268 1
            $done_with_anchor = 0;
d291 9
a299 5
        if (defined $in_anchor) {
            $par->flags_set($F_LINK);
            $par->{'link'} = $in_anchor;
            undef $in_anchor, $done_with_anchor = 0
                if $done_with_anchor;
d315 5
d485 9
d500 2
a501 3
        my $l = length($str);
        ($str .= chr(0xaa)), $l++
            if $l & 1;
@


1.12
log
@layout works, fixed bugs in transend.text.piml
@
text
@a3 12
#
# Split a string according to font metrics, by inserting newlines as
# needed.  Preserve existing newlines.  Returns an array of lines.
#

BEGIN {
    push(@@INC,
         qw(/disks/barad-dur/now/pythia/release/lib/perl-5.002
            /home/fox/nfs-home/286proj/tcsproxy/xs
            /home/fox/nfs-home/286proj/tcsproxy/xs/lib/i586-linux/5.003
            ));
}
a9 3
#
#  Main routine - match tags and handle them till done
#
d17 38
a114 27
%flags_for = ('/h1'    => $F_SIZE1,
              '/h2'    => $F_SIZE1,
              '/h3'    => $F_BOLD,
              '/title' => $F_BOLD,
              '/b'     => $F_BOLD,
              '/i'     => $F_ITALIC,
              );

($NO_CLOSE, $CLOSE_NO_NEWLINE, $CLOSE_AND_NEWLINE, $CLOSE_AND_CLEARBOTH)
    = (0..3);

%clear_for = ('h1'    => $CLOSE_AND_CLEARBOTH,
              'h2'    => $CLOSE_AND_CLEARBOTH,
              'h2'    => $CLOSE_AND_CLEARBOTH,
              'h3'    => $CLOSE_AND_CLEARBOTH,
              'h4'    => $CLOSE_AND_CLEARBOTH,
              'h5'    => $CLOSE_AND_CLEARBOTH,
              'h6'    => $CLOSE_AND_CLEARBOTH,
              'ol'    => $CLOSE_AND_NEWLINE,
              'ul'    => $CLOSE_AND_NEWLINE,
              'li'    => $CLOSE_AND_NEWLINE,
              'dd'    => $CLOSE_AND_NEWLINE,
              'dt'    => $CLOSE_AND_NEWLINE,
              'br'    => $CLOSE_AND_NEWLINE,
              'p'     => $CLOSE_AND_NEWLINE,
              );

d128 1
a128 1
    my $leftover;
d130 1
a130 1
        $leftover = $ly->pack_dynamic
d132 6
a137 3
             $current_par->font->maxwidth);
        last unless defined($leftover);
        if ($leftover == -1 && $retry == 0) {
d141 1
a141 1
        } elsif ($leftover == -1 && $retry == 1) {
a144 4
        } else {
            # either ($leftover == -1 && $retry == 2) 
            # (ie really out of room!), or success
            last;
a146 1
    return $leftover;
d161 4
a164 2
    
    my $ly = new Layout (0, 0, 159, 2000, );
d167 2
a168 1
    $data = &html_regsub($data, 's/\s+/ /sg');
d175 1
a175 1
        if ($what == 2) {
d179 2
a180 1
        } elsif ($what == 1 && $thing !~ /^img$/i) {                   # tag
d183 4
d192 8
d218 6
d227 5
a231 16
          FLOW_TEXT:
            while (1) {
                $leftover = &try_flow($par, $ly);
                if (!defined($leftover)) {
                    # done packing
                    push(@@pars, $par);
                    last FLOW_TEXT;
                } elsif (ref($leftover) eq 'Para') {
                    # leftover stuff. Go again.
                    push(@@pars, $par);
                    $par = $leftover;
                    next FLOW_TEXT;
                } else {
                    # out of room!
                    last FLOW_TEXT;
                }
d233 1
a233 1
            if (defined($leftover) && $leftover == -1) {
d239 1
a239 1
                if ($do_close eq $CLOSE_AND_NEWLINE);
d241 1
a241 1
                if ($do_close eq $CLOSE_AND_CLEARBOTH);
d243 1
a243 1

d333 1
a333 1
    grep(s/\s+$//, @@lines);
@


1.11
log
@minor changes to Layout to fix line break problems - still significant breakage in flowing text aroudn images.  HTML regexp is more robust now
@
text
@d95 1
a249 43
sub close_par {
    my ($current_par,$do_close,$layout) = @@_;
    my $flags;

    # font change?
    $flags = $current_par->flags;
    $current_par->font($PilotFonts::boldFont)
        if $flags & $F_BOLD;
    $current_par->font($PilotFonts::largeFont)
        if ($flags & $F_SIZE1 & $F_SIZE2);
    $current_par->add($pretext);
    $current_par->close();
    if ($current_par->otext =~ /\S/) {
        # layout paragraph
      FLOW_TEXT:
        while (1) {
            $leftover = &try_flow($current_par, $ly);
            if (!defined $leftover) {
                # done packing
                push(@@pars, $current_par);
                last FLOW_TEXT;
            } elsif (ref($leftover) eq 'Para') {
                # leftover stuff. Go again.
                push(@@pars, $current_par);
                $current_par = $leftover;
                next FLOW_TEXT;
            } else {
                # out of room!
                last FLOW_TEXT;
            }
        }
        if (defined($leftover) && $leftover == -1) {
            warn("Ran out of room near " . $current_par->otext);
            goto FINISH;
        }
        $current_par = new Para $PilotFonts::stdFont;
        $current_par->flags_set($F_NEWLINE), $ly->clearleft()
            if ($do_close eq $CLOSE_AND_NEWLINE);
        $current_par->flags_set($F_NEWLINE), $ly->clearboth()
            if ($do_close eq $CLOSE_AND_CLEARBOTH);
    }
}
    
d328 1
d336 3
a338 6
        my $i;
        my $lastch = 0;
        for ($i=0; $i<$nlines; $i++) {
            $lastch += length($lines[$i]);
        }
        return ($lastch-1, '', $nlines * $lht);
d414 6
a419 1
        my @@lines = @@{$para->{'lines'}};
@


1.10
log
@*** empty log message ***
@
text
@d29 1
a29 2
    $HTML_RE =
    q~^(([^<]*)(<\s*(\/?[-\w!]+)(?:(?:[^>"'])|(?:"(?:[^\\"]|(?:\\.))*")|(?:'(?:[^\\']|(?:\\.))*'))*[">']?)?)~; # "
d31 1
a31 1
                0;
d33 39
d73 1
a73 1

d92 24
a115 5
%flags_for = ('h1'    => $F_SIZE1 | $F_BOLD,
              'h2'    => $F_SIZE1,
              'h3'    => $F_BOLD,
              'b'     => $F_BOLD,
              'i'     => $F_ITALIC,
d117 1
a117 1
              
a119 1
    $tag =~ s!^/!!;
d123 5
a156 2
($NO_CLOSE, $CLOSE_NO_NEWLINE, $CLOSE_AND_NEWLINE, $CLOSE_AND_CLEARBOTH)
    = (0..3);
a160 1
    my ($tag,$pretext,$type,$all);
d163 1
a163 3
    my $current_par = new Para $PilotFonts::stdFont;
    my $par;
    my $image;
d165 2
a166 1

d173 3
a175 4
    $data = &striphtml($data,
                       1,                   # keep comments
                       1,                   # keep tags
                       0);                   # don't keep entities
d177 15
a191 46
    
	# this is an evil regexp.  EVIL...  what it does is match all
	# text before a tag and one tag.  That tag can have >'s inside of 
	# quotes or single quotes because of javascript type stuff
	# just right now I want to say that javascript sucks
    while ($data && $data =~ s/$HTML_RE//so) {
        $all = $1;
	$pretext = $2;
	$tag = $3;
	$type = $4;

        next if $type =~ m/^!/;             # ignore markup

        # Strategy: Collect text into "para" units, which are text fragments
        # that have particular characteristics associated with them.  When each
        # such fragment is closed, 

        if (&tag_matches_open($type,qw(ol ul))) {
            $do_close = $NO_CLOSE;
            $in_list++;
        } elsif ($in_list && &tag_matches_close($type,qw(ol ul))) {
            $in_list--;
            $do_close = $NO_CLOSE;
        } elsif (&tag_matches_open($type,qw(img))) {
            $current_par->add($pretext);
            $do_close = $CLOSE_NO_NEWLINE;
            $image = $tag;
        } elsif ($in_list && &tag_matches_open($type,qw(li))) {
            $do_close = $CLOSE_AND_NEWLINE;
            $data = ($LISTBULLET x $in_list) . $data;
        } elsif (&tag_matches_open($type,qw(h1 h2 h3 h4 h5 h6))) {
            $do_close = $CLOSE_AND_CLEARBOTH;
        } elsif (&tag_matches_close($type,qw(h1 h2 h3 h4 h5 h6))) {
            $current_par->flags_set(&flags_for($type));
            $do_close  = $CLOSE_AND_CLEARBOTH;
        #} elsif (&tag_matches_open($type,qw(b))) {
            #$do_close = $CLOSE_NO_NEWLINE;
        #} elsif (&tag_matches_close($type,qw(b))) {
            #$do_close = $CLOSE_NO_NEWLINE;
            #$current_par->flags_set(&flags_for($type));
        } elsif (&tag_matches($type,qw(br p))) {
            $do_close  = $CLOSE_AND_NEWLINE;
        } elsif ($type =~ m/!--/) {
            ;                               # ignore comment
        } else {
            $current_par->add($pretext);
d193 3
a196 1

d202 7
a208 7
        $flags = $current_par->flags;
        $current_par->font($boldFont) if $flags & $F_BOLD;
        $current_par->font($largeFont)
            if ($flags & $F_SIZE1 & $F_SIZE2);
        $current_par->add($pretext);
        $current_par->close();
        if ($current_par->otext =~ /\S/) {
d212 2
a213 2
                $leftover = &try_flow($current_par, $ly);
                if (!defined $leftover) {
d215 1
a215 1
                    push(@@pars, $current_par);
d219 2
a220 2
                    push(@@pars, $current_par);
                    $current_par = $leftover;
d228 1
a228 1
                warn("Ran out of room near " . $current_par->otext);
d231 2
a232 2
            $current_par = new Para $PilotFonts::stdFont;
            $current_par->flags_set($F_NEWLINE), $ly->clearleft()
d234 1
a234 1
            $current_par->flags_set($F_NEWLINE), $ly->clearboth()
a237 4
        if ($image && ($par = &process_image($image,$ly,$baseurl))) {
            push(@@pars, $par);
            $image = '';
        }
d240 1
a240 1
    if ($current_par->otext eq '') {
d242 2
a243 2
        $current_par->close();
        push(@@pars, $current_par);
d294 2
a295 2
    my ($tag,$ly,$baseurl) = @@_;
    my $src;
d297 2
a298 6
    if ($tag =~ /src\s*=\s*\"?([^\"\s]+)\"?/is) { # "
        $src = $1;
    } else {
        warn "Couldn't extract src from $tag";
        return undef;
    }
d300 1
a300 2
    $src = new URI::URL $src;
    $src = $src->abs($baseurl)->as_string;
d304 3
d342 1
a342 1
    my $align = ($tag =~ /align\s*=\s*"?right"?/i?  1 : -1);
d377 6
a382 1
        return ($lines[$nlines-1] - 1, '', $nlines * $lht);
d460 2
a461 3
        foreach $l (@@lines) {
            my $x = substr($str,$last,$l-$last);
            $last = $l;
@


1.9
log
@*** empty log message ***
@
text
@d107 1
a131 2
        $do_close = $NO_CLOSE;

d139 1
d145 3
a147 7
            $do_close = $NO_CLOSE;
            if ($par = &process_image($tag,$ly,$baseurl)) {
                push(@@pars, $par);
            } else {
                goto FINISH;    # out of room!
            }
            next;
d167 1
d174 24
a197 26
        if ($do_close ne $NO_CLOSE) {
            # font change?
            $flags = $current_par->flags;
            $current_par->font($boldFont) if $flags & $F_BOLD;
            $current_par->font($largeFont)
                if ($flags & $F_SIZE1 & $F_SIZE2);
            $current_par->add($pretext);
            $current_par->close();
            if ($current_par->otext =~ /\S/) {
                # layout paragraph
              FLOW_TEXT:
                while (1) {
                    $leftover = &try_flow($current_par, $ly);
                    if (!defined $leftover) {
                        # done packing
                        push(@@pars, $current_par);
                        last FLOW_TEXT;
                    } elsif (ref($leftover) eq 'Para') {
                        # leftover stuff. Go again.
                        push(@@pars, $current_par);
                        $current_par = $leftover;
                        next FLOW_TEXT;
                    } else {
                        # out of room!
                        last FLOW_TEXT;
                    }
a198 9
                if (defined($leftover) && $leftover == -1) {
                    warn("Ran out of room near " . $current_par->otext);
                    goto FINISH;
                }
                $current_par = new Para $PilotFonts::stdFont;
                $current_par->flags_set($F_NEWLINE), $ly->clearleft()
                    if ($do_close eq $CLOSE_AND_NEWLINE);
                $current_par->flags_set($F_NEWLINE), $ly->clearboth()
                    if ($do_close eq $CLOSE_AND_CLEARBOTH);
d200 14
d216 1
d226 44
d272 8
a279 1
    my ($src) = $1 if $tag =~ /src\s*=\s*\"?([^\"\s]+)\"?/is; #" 
d290 1
a290 1
    unlink "/tmp/j1";
d292 1
a292 1
        open(PROG, "| djpeg -scale 1/4 -pnm | ppmquant -fs -map /home/fox/pilot/ppmtoTbmp/q4.map 2>/dev/null >/tmp/j1") or warn $!;
d296 1
a296 1
        open(PROG, "| giftopnm | pnmscale -xscale .25 -yscale .25 | ppmquant -fs -map /home/fox/pilot/ppmtoTbmp/q4.map 2>/dev/null >/tmp/j1") or warn $!;
d301 1
a301 1
    open(TMP,"/tmp/j1");
d315 1
a315 1
    open(PROG, "/home/fox/nfs-home/286proj/tcsproxy/bin/ppmtoTbmp -2bit /tmp/j1 2>/dev/null |");
d319 1
d325 1
a332 2
        $ly->clearboth;
        #warn "AFTER Width height = " . $p->width . "," . $p->height;
@


1.8
log
@*** empty log message ***
@
text
@d27 1
d312 2
a313 4
#  as a tSTR resource of size at most $PILOT_MAX_STORE.
#  If the tSTR would exceed this size, add an HTML piece containing a link to
#  the next tSTR, which we put in the TranSend cache for later delivery if
#  desired.
d317 1
d319 1
a319 1
    my $p;
d321 1
d324 2
a325 1
    foreach $p (@@pieces) {
d328 2
a329 2
        if (length($p) & 1) {
            warn "Odd number of bytes in $p\n";
d332 1
d335 2
a336 1
        $last_backptr = length($p) + 14;
d339 2
a340 1
    return (join('', @@pieces) . pack("n", 0xffff));
d384 1
d439 2
a440 1
    
d454 5
a458 2
    open(R, "> tSTR07cf.bin") or die $!;
    $str = &make_rsrc_from_pieces(@@rsrc);
@


1.7
log
@layout works!
@
text
@a17 1
use LWP;  $UA = new LWP::UserAgent;
d21 1
a21 1

d74 1
d100 1
d115 2
a116 2
                       1,                   # don't keep comments
                       1,                   # do keep tags
d145 1
a145 1
            if ($par = &process_image($tag,$ly)) {
a191 6
                        print STDOUT (join(' ', $current_par->x, $current_par->y,
                                           $current_par->width,
                                           $current_par->height,
                                           $current_par->otext),
                                      #substr($current_par->otext,0,10)),
                                      "\n");
a195 6
                        print STDOUT (join(' ', $current_par->x, $current_par->y,
                                           $current_par->width,
                                           $current_par->height,
                                           $current_par->otext),
                                           #substr($current_par->otext,0,10)),
                                      "\n");
d203 1
a203 1
                if ($leftover == -1) {
d225 1
a225 2
    my $tag = shift;
    my $ly = shift;
d228 4
d258 1
a258 1
    warn "$src Width height = " . $p->width . "," . $p->height;
d279 1
a279 3
        warn "AFTER Width height = " . $p->width . "," . $p->height;
        print STDOUT join(' ', $p->x,$p->y,$p->width,$p->height,
                          substr($src, 1+rindex($src,"/"))),"\n";
d326 4
a329 3
        $p .= "\000" if (length($p) & 1);
        # make the forward-pointer correct
        substr($p,2,2) = pack("n", $last_backptr = length($p));
d332 1
d335 1
a335 1
    return (join(//, @@pieces) . pack("n", 0xffff));
d358 6
d365 22
a386 14
        my $l = length($para->otext);
        $l++ if $l & 1;
        return $hdr . $para->otext;
    }

    my @@lines = @@{$para->{'lines'}};
    $last = 0;
    foreach $l (@@lines) {
        my $x = substr($str,$last,$l);
        $last = $l;
        $x .= ' ' if (length($x) & 1);
        $data .= pack("n", length($x));
        $data .= $x;
        $is_nullstr_only=0 if length($x);
d388 4
a391 1
    $data .= pack("n",0);
d395 1
a395 1
sub print_stringy_rsrc {
d402 22
a423 17
    print("Back = $bp   Forw = $fp\n+$x+$y(${xextent}x$yextent)\nFlags:");
    print "F_BOLD " if $flags & $F_BOLD;
    print "F_ITALIC " if $flags & $F_ITALIC;
    print ($flags & $F_SIZE2 & $F_SIZE1 ? "F_SIZE3 "
           : $flags & $F_SIZE2 ? "F_SIZE2 "
           : $flags & $F_SIZE1 ? "F_SIZE1 "
           : "F_SIZE0 ");
    printf ("F_BITMAP\n"), return
        if $flags & $F_BITMAP;
    print "\n";

    while (($len = unpack("n",$r)) != 0) {
        printf ("Length: %d\n",$len);
        ($len,$s) = unpack("n a$len", $r);
        $len++ if $len & 1;                 # guarantee 2byte alignment
        $r = substr($r,2+$len);
        print  "Text:  `$s'\n";
d438 1
a438 2
    die;
    warn ("%d paragraphs\n", scalar @@pa);
d441 1
a441 1
        printf("(%d,%d) `%s'\n", $para->x,$para->y,$para->otext);
d443 2
a444 1
        push(@@rsrc, $nextpiece) if $nextpiece;
d448 1
a448 8

    foreach $r (@@rsrc) {
        $str .= $r;
        print "\n";
        &print_stringy_rsrc($r);
    }
    $str .= pack("n",0xffff);               # end piece
    $str .= chr(0);                         # end string resource
d451 1
@


1.6
log
@*** empty log message ***
@
text
@d17 1
a17 1
#use clib;
d67 26
d95 2
a96 1
($NO_CLOSE, $CLOSE_NO_NEWLINE, $CLOSE_AND_NEWLINE) = (0..2);
d107 1
a107 1
    my $ly = new Layout (0, 0, 159, 2000, 30);
d123 1
a123 1
    while ($data =~ s/$HTML_RE//so) {
d146 2
d154 1
a154 1
            $do_close = $CLOSE_AND_NEWLINE;
d157 1
a157 1
            $do_close  = $CLOSE_AND_NEWLINE;
d178 2
a179 2
            $current_par->font($PilotFonts::boldFont) if $flags & $F_BOLD;
            $current_par->font($PilotFonts::largeFont)
d185 33
a217 9
                @@new = ();
                do {
                    $leftover = $ly->pack_dynamic($current_par,
                                                  \&measuretext,
                                                  -1, -1,
                                                  $current_par->font->maxwidth);
                    push(@@new,$leftover) if $leftover;
                } while $leftover;
                push(@@pars,$current_par,@@new);
d221 2
d231 1
d240 1
a240 2
    warn "Won't process image in `$tag'", return undef
        unless $src;
d242 2
a243 8
    #my($stat,$hdrs,$data) = &Clib_Fetch($src,'');
    warn "Processing image in `$tag'";
    my $resp = $UA->request(new HTTP::Request "GET", $src);
    my $stat = $resp->status;
    warn ("Image fetch failed with status $stat"), return undef
        unless $resp->is_success;
    $hdrs = $resp->headers_as_string;
    $data = $resp->content;
d245 1
a245 1
    # convert jpeg or gif to ppm.
d247 1
a247 1
        open(PROG, "| djpeg -scale 1/4 -pnm | ppmquant -fs -map /home/fox/pilot/ppmtoTbmp/q4.map >/tmp/j1") or warn $!;
d251 1
a251 1
        open(PROG, "| giftopnm | pnmscale -xscale .25 -yscale .25 | ppmquant -fs -map /home/fox/pilot/ppmtoTbmp/q4.map >/tmp/j1") or warn $!;
d259 1
d265 6
a270 1
    <TMP>;
d272 2
a273 2
    $buf .= $_ while $_ = <TMP>;
    close TMP;
d275 17
a291 3
    my $align = ($tag =~ /align\s*=\s*right/i?  1 : -1);
    $ly->pack_static($p, $align, -1);
    return $p;
d424 1
d434 1
@


1.5
log
@*** empty log message ***
@
text
@d17 2
a18 1
use clib;
a91 1
    while (!($data =~ /^$/)) {
d96 1
a96 1
	$data =~ s/$HTML_RE//so;
d117 1
a117 1
            if ($par = &process_image($tag)) {
d181 1
a181 1

d187 8
a194 3
    my($stat,$hdrs,$data) = &Clib_Fetch($src,'');
    warn "Image fetch failed with status $stat", return undef
        if ($stat !~ /200/);
d198 1
a198 1
        open(PROG, "| djpeg -colors 4 -scale 1/4 -pnm >/tmp/j1") or warn $!;
d300 1
a300 1
        return $hdr . pack("n",$l) . $para->otext;
@


1.4
log
@*** empty log message ***
@
text
@d17 1
a21 6
&util::debug('layout');


$HEIGHT = 9;                                # height of a line in PIXELS
$WIDTH = 30;                                # width of a line in CHARACTERS

d27 1
a27 5
    $LINEBEGIN = '';
    #$PARBEGIN = chr (ord('>') & 0x80);
    #$LISTBULLET = chr(ord('*') & 0x80);
    $PARBEGIN = '>';
    $LISTBULLET = '*';
d29 1
a29 1
    q~^(([^<]*)(<\s*(\/?[\w!]*)(?:(?:[^>"'])|(?:"(?:[^\\"]|(?:\\.))*")|(?:'(?:[^\\']|(?:\\.))*'))*[">']?)?)~; # "
d76 1
d115 6
d179 41
d232 1
d279 5
a283 1
    my ($xextent,$yextent) = (0,0);
d292 11
a302 4
    my $data = '';
    $str .= "\n" unless $str =~ /\n$/;
    while (length($str) && $str =~ s/([^\n]*)\n//) {
        my $x = $1;
d306 1
a306 1
        $is_nullstr_only = 0 if length($x);
d314 1
a314 1
    my $len;
d316 2
a317 2
    my ($bp,$fp,$x,$y,$flags) = unpack("n5",$r);
    $r = substr($r,10);
d319 1
a319 1
    print("Back = $bp   Forw = $fp\n(x,y)=($x,$y)\nFlags:");
d321 1
a321 1
    print "F_ITAL " if $flags & $F_ITAL;
d326 2
d344 1
d348 1
a348 1
    @@pa = &parse_main($data, '', 'text/html', ());
a353 12
    }
    die;

    foreach $para (@@pa) {
        $text = $otext = $para->otext;
        if ($text =~ s/^$PARBEGIN\s*//o) {
            $text =~ s/\n(\S)/\n $1/sg ;
        } else {
            $text =~ s/^\s*/ /;
        }
        $para->otext($text);

a355 3
        $y += $HEIGHT * $para->numlines();
        #print $otext,"\n",$text,"\n";  #,"\n---\n";
        #print $text,"\n";  #,"\n---\n";
a379 1
    last;
@


1.3
log
@*** empty log message ***
@
text
@d21 2
d84 1
a84 1
    my $current_par = new Para 4,$WIDTH*4,0,0;
a88 2
    my($curX,$curY) = (0,0);

a117 3
        # is it a paragraph-ending tag?
        # (header, font change)

d125 4
a128 2
            $data = "\n" . ($LISTBULLET x $in_list) . $data;
        } elsif (&tag_matches($type,qw(h1 h2 h3 h4 h5 h6))) {
d131 5
a135 6
            $data = "\n" . $data;
        } elsif (&tag_matches_open($type,qw(b i))) {
            $do_close = $CLOSE_NO_NEWLINE;
        } elsif (&tag_matches_close($type,qw(b i))) {
            $do_close = $CLOSE_NO_NEWLINE;
            $current_par->flags_set(&flags_for($type));
a137 1
            $data = "\n" . $data;
a146 2
        
        
d148 6
a153 1
        if ($do_close) {
d156 14
a169 8
            $current_par->flags_set($F_NEWLINE)
                if ($do_close eq $CLOSE_AND_NEWLINE);
            push(@@pars,$current_par);
            if ($do_close == 2) {           # new line
                $curY += $HEIGHT;
                $curX = 0;
            } else {                        # continue on same line
                $curX += 4 * $current_par->lastlinewidth();
d171 1
a171 2
            $current_par = new Para 4,$WIDTH*4,$curX,$curY;
        }            
d173 1
a173 1
    if ($current_par->text eq '') {
d199 1
a199 5
        my $ndx = 0;
        for (0..$nlines-1) {
            $ndx += length($lines[$_]);
        }
        return $ndx;
d237 1
a237 1
    my $str = $para->text;
a285 2
&DistillerInit;

a291 3
    my $file = ($ARGV[0] || "/home/fox/nfs-home/public_html/index.html");
    $data = &util::slurp($file);

d299 6
a304 1
        $text = $otext = $para->text;
d310 1
a310 1
        $para->text($text);
@


1.2
log
@*** empty log message ***
@
text
@d10 5
a14 1
    push(@@INC, "/disks/barad-dur/now/pythia/release/lib/perl-5.002");
d73 3
a76 1

d80 2
a81 1
    my $out;
d85 2
a97 3
    my ($tag, $pretext, $type, $all);
    my ($in_list) = 0;
    my ($do_close) = 0;
d110 1
a110 1
        $do_close = 0;
d114 4
d125 1
a125 1
            $do_close = 0;
d127 2
a128 2
            $do_close = 2;
            $data = $PARBEGIN . ($LISTBULLET x $in_list) . $data;
d131 2
a132 2
            $do_close  = 2;
            $data = $PARBEGIN . $data;
d134 1
a134 1
            $do_close = 1;
d136 1
a136 1
            $do_close = 1;
d139 2
a140 2
            $do_close  = 2;
            $data = $PARBEGIN . $data;
d142 1
a142 1
            ;
d146 7
d156 2
d176 28
d221 1
a221 1
        p$ .= "\000" if length($p) & 1;
d270 1
a270 1
    print ($flags & $F_SIZE3 ? "F_SIZE3 "
a274 1
    printf ("Length: %d\n",unpack("n",$r));
d277 1
d342 2
@


1.1
log
@changes and additions to transend.text.piml (pilot markup language html
distiller).  commented the ARGS.h file for distillers.  distillers now
only observe Quality arg if it has a reasonable value.  Changes to main
prefs to make values of FRONT_SHOW_ICON arg agree with perl html distiller.
@
text
@a0 1
#
d14 6
d71 1
a71 1
sub DistillerMain {
d75 1
a75 1
    my $current_par = new Para 4,40*4;
d77 3
a79 1
    
d117 1
a117 1
            $do_close = 1;
d121 1
a121 1
            $do_close  = 1;
d129 1
a129 1
            $do_close  = 1;
d140 7
a146 1
            $current_par = new Para 4,40*4;
d157 29
a185 2
sub make_stringy_rsrc {
    my ($para,$initx,$inity) = @@_;
d187 2
d190 10
a199 19
    
    # format of stringy resource is:
    #  0 - BackPtr (SWord), an offset to the previous BackPtr
    #  2 - ForwardPtr (SWord), an offset to the next BackPtr
    #  4 - Xpos (SWord)
    #  6 - Ypos (SWord)
    #  8 - Attributes (SWord)
    #      bit 0  Bold
    #          1  italic
    #          2  underline
    #        3-4  size 0-3
    #       5-15  reserved
    #  then one or more instances of:
    # 10 - Length (SWord)
    # 12 thru 12+n - Text, must be word (16-bit) aligned
    #    odd text length is padded with an blank char (will be ignored)
    #    (this part can repeat starting with length, repeats indicated newlines)

    my $hdr = pack("n5", 0, 0, $initx,$inity,$attrs);
d207 1
d210 1
a210 3
    # finally, make the forward-pointer correct
    substr($hdr,2,2) = pack("n", length($data)+length($hdr)-2);
    return  $hdr . $data;
d228 1
d240 2
a241 4

$file = ($ARGV[0] || "/home/tomorrow/b/grad/fox/public_html/index.html");

for (;;) {
d243 4
a247 2
    @@rsrc = ();
    @@pa = &DistillerMain($data, '', 'text/html', ());
d249 6
a254 4
    printf ("%d paragraphs\n", scalar @@pa);
    $re1 = "^\\s*[^$PARBEGIN]";
    $re2 = "^$PARBEGIN\\s*";
    
d263 4
a266 1
        push(@@rsrc, make_stringy_rsrc($para,0,0));
d271 1
a271 1
    open(R, "> /home/tomorrow/b/grad/fox/tmp/tSTR1999.bin") or die $!;
d274 2
d277 2
a278 1
    $str .= chr(0);
d281 4
a284 4
    #system("build-prc foo1.prc 'Foo1' 'Foo1' tSTR1999.bin")
    #and warn $?;
    print "Run buildprc\n"; <STDIN>;
    open(R, "/home/tomorrow/b/grad/fox/tmp/foo1.prc") or die $!;
d287 2
a288 2
    $r =~ s/Foo1/TGwi/gs;
    $r =~ s/appl/TGwi/gs;
d290 1
a290 1
    open(R, ">/home/tomorrow/b/grad/fox/tmp/TGwi.prc") or die $!;
@
