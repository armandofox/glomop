head	1.28;
access;
symbols
	initial:1.1.1.1
	initial:1.1.1;
locks; strict;
comment	@% @;


1.28
date	99.09.24.20.22.44;	author daw;	state Exp;
branches;
next	1.27;

1.27
date	99.09.23.22.10.00;	author daw;	state Exp;
branches;
next	1.26;

1.26
date	99.09.23.20.48.33;	author daw;	state Exp;
branches;
next	1.25;

1.25
date	99.09.23.04.19.06;	author daw;	state Exp;
branches;
next	1.24;

1.24
date	99.09.22.19.28.59;	author daw;	state Exp;
branches;
next	1.23;

1.23
date	99.09.22.03.23.54;	author daw;	state Exp;
branches;
next	1.22;

1.22
date	99.09.21.23.44.12;	author daw;	state Exp;
branches;
next	1.21;

1.21
date	99.09.21.01.16.49;	author daw;	state Exp;
branches;
next	1.20;

1.20
date	99.09.21.00.48.10;	author daw;	state Exp;
branches;
next	1.19;

1.19
date	99.09.20.22.36.33;	author daw;	state Exp;
branches;
next	1.18;

1.18
date	99.09.14.16.55.07;	author daw;	state Exp;
branches;
next	1.17;

1.17
date	99.09.13.04.43.09;	author daw;	state Exp;
branches;
next	1.16;

1.16
date	99.06.11.18.45.28;	author daw;	state Exp;
branches;
next	1.15;

1.15
date	99.06.08.01.53.15;	author daw;	state Exp;
branches;
next	1.14;

1.14
date	99.06.07.20.58.22;	author daw;	state Exp;
branches;
next	1.13;

1.13
date	99.06.07.20.31.47;	author daw;	state Exp;
branches;
next	1.12;

1.12
date	99.06.07.16.55.50;	author daw;	state Exp;
branches;
next	1.11;

1.11
date	99.06.07.16.21.55;	author daw;	state Exp;
branches;
next	1.10;

1.10
date	99.06.07.06.51.49;	author daw;	state Exp;
branches;
next	1.9;

1.9
date	99.06.01.03.56.17;	author daw;	state Exp;
branches;
next	1.8;

1.8
date	99.06.01.01.29.02;	author daw;	state Exp;
branches;
next	1.7;

1.7
date	99.05.28.02.20.48;	author daw;	state Exp;
branches;
next	1.6;

1.6
date	99.05.28.00.23.35;	author daw;	state Exp;
branches;
next	1.5;

1.5
date	99.05.27.21.37.28;	author daw;	state Exp;
branches;
next	1.4;

1.4
date	99.03.31.22.33.34;	author daw;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.02.49;	author daw;	state Exp;
branches;
next	1.2;

1.2
date	98.11.08.11.38.37;	author daw;	state Exp;
branches;
next	1.1;

1.1
date	98.11.08.11.35.49;	author daw;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.08.11.35.49;	author daw;	state Exp;
branches;
next	;


desc
@@


1.28
log
@*** empty log message ***
@
text
@\documentclass{llncs2e}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{comment}
\newcommand{\K}{{\cal K}}
\newcommand{\X}{{\cal X}}
\newcommand{\Y}{{\cal Y}}
\newcommand{\Z}{{\mathbb Z}}
\renewcommand{\H}{{\cal H}}
\newcommand{\Adv}{\textrm{Adv}\,}
\newcommand{\des}{\textrm{DES}}
\newcommand{\topic}[1]{\vskip 0.05in \noindent {\sc #1.}}
\title{Proofs of security for the Unix password hashing algorithm\\
\fbox{------ DRAFT ------}}
\author{David Wagner \and Ian Goldberg \\
{\em University of California, Berkeley} \\
{\tt \{daw,iang\}@@cs.berkeley.edu}}
\institute{}
\begin{document}
\maketitle
\begin{abstract}
We give the first explicit, quantitative analysis of the security
of the Unix password hashing algorithm, showing concrete lower bounds
on its strength.
Our results show that it is very good at extracting
almost all of the available strength from the underlying cryptographic
primitive and provide good reason for confidence in the Unix construction.
\end{abstract}

\section{Introduction}

This paper examines the security of the Unix password hashing algorithm,
the core of the Unix password authentication protocol.
Although the algorithm has been conjectured cryptographically secure,
after two decades of analysis and
deployment in millions of systems worldwide it still has not been
proven to resist attack.
In this paper, we provide the first practical proof of security
(under some reasonable cryptographic assumptions) for the Unix algorithm.

The hashing algorithm is a fairly simple application of DES,
perhaps the best-known block cipher available to the public.
Since DES has seen many man-years of analysis, in an ideal world
we might hope for a proof (via some reduction)
that the Unix password hash is secure if DES is.
However, so far no such proof has appeared in the literature.

In earlier work,
Luby and Rackoff presented strong theoretical evidence that the basic
approach found in the Unix algorithm is likely to be sound \cite{LR87,LR89}.
However, their proofs have three serious limitations:
the abstract model they analyze omits some important features of
the real algorithm; they assume a uniform distribution on passwords;
and their proofs of security are asymptotic, and so do not directly apply
to real (necessarily finite) instantiations of the construction.
Therefore, we feel that, from a practical point of view,
the security of the real Unix password hash remains an open question.

In this paper, we take a further step towards justifying the
design of the Unix password hash.
Our primary contributions are twofold:
\begin{itemize}
\item First, we show how to analyze the {\em real} Unix construction,
removing the need to abstract away features of the algorithm.
This removes the gap between what has been analyzed and
what is currently in use.
\item Second, we provide explicit, {\em quantitative} security measures,
instead of asymptotic estimates.
As a result, our proofs can be directly applied to the real
(finite) Unix algorithm, rather than an idealized asymptotic model.
\end{itemize}
As a result, we are able to show surprisingly good lower
bounds on the security of the Unix password hash construction.

More generally, we are able to show that a simple construction
of one-way functions from block ciphers can be simultaneously very
efficient and strongly security-preserving.
This result may be of independent interest.

The main practical shortcoming of our aforementioned proof techniques is that,
for best results,
we---like Luby and Rackoff---must assume that the passwords
are uniformly distributed.  However, we---unlike Luby and Rackoff---have
also developed alternative techniques that yield poorer results
but do generalize to the non-uniform case.

In general, the security issues associated
with non-uniformly distributed keying
material appear to be under-represented in the literature.
In Section~\ref{sec:nonuniform},
we make some initial progress on this problem,
presenting a formal model that we hope may serve as a foundation
for future exploration in this area.
Using this model, we are able to show relatively good lower bounds
on the security of the Unix algorithm when used with non-uniformly
distributed passwords; this is already a useful result, but our
results here are not as strong as we would like, and so we leave this
as an open question for further research.

%Using this model and some alternative techniques,
%we are able to show that the Unix algorithm
%is relatively good at hashing even non-uniformly distributed passwords, if
%we are willing to assume that DES does not have any serious weaknesses
%when used with uniformly-distributed keys. 
%This is already a useful result.
%However, our proof methods are not powerful enough to rule out
%the possibility that weaknesses in DES might be magnified by
%the Unix construction (a possibility practitioners seem to consider
%unlikely), so there remains some room for improvement in this area.

This paper is structured as follows.
We recall the definition of the Unix password hash in
Section~\ref{sec:descr} and then summarize the results of our analysis in
Section~\ref{sec:results}.
The remainder of the paper is dedicated to the theoretical analysis:
Section~\ref{sec:ideas} outlines the main ideas from a high level,
Section~\ref{sec:defn} gives some important definitions, and
Section~\ref{sec:analysis} dives into the details of the proofs.
Also, Section~\ref{sec:nonuniform} gives an formal model for security
with non-uniformly distributed passwords and presents some initial results in
this area.
Finally, in Section~\ref{sec:conc} we conclude the paper.



\section{The Unix algorithm}
\label{sec:descr}

We briefly recount the definition of the Unix password hashing
function.
The function---let us call it $H$---is built out of a 25-fold
iterated version of DES, in the following way.
Let $\des_k(x)$ denote the DES encryption of plaintext $x$
under key $k$ and $\des_k^n(x) = \des_k(\des_k^{n-1}(x))$
denote the $n$-fold iteration of $\des_k$.
Then the hash $H(k)$ of the 8-character password $k$ may be defined as
\[ H(k) = \des_k^{25}(0). \]

When a new user account is created, the hash $H(k)$ of
the user's initial password is stored with
the user's id in the (world-readable)
system password file {\tt /etc/passwd}.
When the user attempts to log on with password $k'$, 
the system computes $H(k')$ and compares the result
to the value stored in the password file, allowing the user
to log on only if $H(k') = H(k)$.

Until now our description of the Unix password scheme has omitted one
important feature of the construction: the salt.
In fact, when the user register his password $k$ for the first time,
a random 12-bit salt $s$ is generated, and the system computes
the salted hash $H_s(k)$ from $k$ and $s$.
The salted hash is defined as $H_s(k) = \des_{k,s}^{25}(0)$,
where $\des_{k,s}(x)$ refers to the DES encryption of plaintext $x$
under key $k$ and salt $s$.
Internally, the salt affects the DES encryption by modifying the
DES round function.

Salting was added to deter dictionary attacks, and to ensure that
if two users have the same password this will not be apparent from
their hashed passwords.
For simplicity of exposition, we will ignore the salt for most of
this paper, and analyze the unsalted construction.
This simplification does not come at any loss of generality;
we show later how to add the effects of the salt back in
and thereby analyze the salted algorithm.

\section{Results}
\label{sec:results}

The main result of our analysis is the following theorem.
\begin{theorem}\label{th:main}
If DES is a $(t,25,e)$-secure block cipher, then the Unix password
hashing function $H$ is a
$(t',p)$-secure password hashing function,
where $t' \approx t$ and $p \approx (1+1/255) e$.
\end{theorem}

Some interpretation of this analytical result is clearly in order.
Formal definitions of $(t,q,e)$-security for block ciphers and
$(t',p)$-security for hash functions will be provided later in
Section~\ref{sec:defn}, but for now we just sketch the intuition.
Roughly speaking, the theorem says
that if DES is secure against all attacks
using at most 25 chosen plaintexts, and if the password is chosen
uniformly at random, then the Unix construction is secure
against password guessing attacks.

In fact, the result is even better than this, because it gives
us {\em concrete} security measures.
In other words, it allows us to quantify the resources an adversary
would need to break the Unix password algorithm.

Of course, nothing comes for free.
Since the hashing algorithm is built out of DES, we must make some
cryptographic assumptions on the security of DES
to prove anything about the Unix scheme.
In the words of other workers on provable security,
``you can't make good wine
from bad grapes'' \cite{BCK96}.

In the spirit of quantitative analysis, we will measure
the security of the Unix hash algorithm as a function of
the (quantitative) security level of DES.
We show that the construction is strongly security-preserving:
the Unix hash is almost as strong as DES.
Conversely, any serious weakness in the Unix hash would imply the
existence of a weakness in DES of comparable severity.
Our analysis requires only very weak assumptions of security for DES,
and as a result, our results will still be relevant even if DES is found
to have some small weakness.

One alternative might be to base our proof of security on the assumption
that DES behaves like an ideal cipher, but such an approach
would say nothing about whether a small imperfection in DES
might be magnified by the Unix
construction into a fatal flaw for a hashing function.
In this paper, we prove that this magnification effect cannot occur;
the Unix construction is robust.


\topic{An example}
Let us try to estimate the resources needed to reverse the Unix
hash function.
We start by estimating the concrete security level afforded by DES.
The best attack reported in the open literature for breaking DES
with 25 chosen plaintexts is exhaustive keysearch; differential and
linear cryptanalysis do not help with such a small number of chosen texts.
If we try $t$ keys, the probability of success for exhaustive
keysearch\footnote{We assume the adversary exploits the DES complementation
property, and thus $e = t/2^{55}$, not $t/2^{56}$ as one might naively
expect.}
is $e = t/2^{55}$.
Therefore, if the cryptanalytic results reported in the
open literature are representative,
we may conclude that DES forms a $(t,25,t/2^{55})$-secure block cipher.
Theorem~\ref{th:main} then says that the Unix scheme is
$(t,p)$-secure
%for $t \approx t'$
%and $e = 256/255 (e' + 3 \cdot 25^2/2^{65})$,
%or approximately when $e > (1 + 1/255) \cdot (t+1.831)/2^{55}$.
%Thus, we have an approximate bound $e \le 1.004 e'$ relating the
%success probabilities for attacking the Unix hash and for attacking DES.
for $p \approx (1 + 1/255) t/2^{55}$, which is only larger
than the corresponding success probability for attacking DES
by the small multiplicative factor of $1 + 1/255$.
This conclusion is worth repeating:
\begin{quote}
For an adversary with a given set of resources,
the chances of breaking the Unix password hash are at most only
slightly higher---less than 1\% higher---than the chances of breaking DES
with the same resources.
\end{quote}
This is a very strong result, for it shows that the Unix construction
has excellent security-preserving properties.

%For comparison, exhaustive keysearch will break the
%Unix hashing algorithm with probability $t/2^{56}$ after $t$
%trial hash computations.
%This is close to the proven lower bounds (we lose a factor of two
%due to the DES complementation property).
This lower bound is also relatively close to the best-known attack
(exhaustive search) on the Unix hashing algorithm.
In other words, according to our best current knowledge of DES,
an adversary attacking the Unix password hashing function simply
cannot do very much better than brute-force exhaustive search.

Note that our security proofs require only very mild assumptions
on the properties of DES.
To break the Unix algorithm, the adversary must
have some way to break DES with only 25 chosen plaintexts,
which is likely to be a very difficult task.
Furthermore, even the existence of such an attack on DES is no guarantee
of success at breaking the Unix hash function, since it seems to
be very difficult to control the internal values of the hash computation.
Therefore, we expect that the Unix hash function is likely to be
even stronger than our lower bounds would suggest.

\topic{Generalizations}
Theorem~\ref{th:main} actually assumes very little
about the properties of DES, and in fact it is proved by
first proving a corresponding result for a generic block cipher.
The only special property we need is that the output length is larger
than the key size.
A similar result allows us to build an efficient and secure
one-way function from any pseudorandom function (PRF)
or any stream cipher, so long as the output length is larger than
the key size\footnote{Of course, the effective block length can
always be cheaply lengthened if necessary, so this restriction is
not limiting in practice.  A typical block-lengthening construction
is $G(k) = \langle F_k(1), \ldots, F_k(n) \rangle$, and this can
be easily proven secure if $F$ is a secure PRF or block cipher.}.
%Also, see Section~\ref{???} for an efficient construction that
%works for any block cipher, PRF, or stream cipher, even if the
%output size is smaller than the key size.

\topic{A pitfall}
A proof of security for the Unix password hash function is
deceptively difficult.
Naively one might think that the proof should be trivial; however,
there is a trap for the unwary which makes the problem more
difficult than it might seem at first glance.

%An obvious line of approach might go like this (stated informally).
Consider a simple, informal attempt to prove that the one-way function
$h(k) = E_k(0)$ is secure if $E$ is a secure block cipher.
At first glance, it might seem as though
any algorithm to break the one-way function, i.e., any
algorithm that can
recover $k$ from $y = h(k) = E_k(0)$, can also be used to
break the cipher $E$ with a simple trick.
The idea is to first request the encryption of
the chosen plaintext 0, then recover $k$ from the resulting
ciphertext using the algorithm for breaking $h$,
and finally use $k$ to decrypt the rest of
the traffic enciphered using that key.

However, this reasoning is flawed:
the informal nature of the argument hides a subtle gap in the proof.
Breaking a one-way function $h$ does not require the ability
to recover $k$ from $y=h(k)$: a much weaker condition suffices.
If we can recover some
$k'$---possibly different from $k$---such that $h(k') = y$,
then such a $k'$ will allow access to the system just as well
as the original password $k$, since the system has no way to
distinguish between the two cases.
However, knowledge of $k'$ (different from $k$)
with $E_{k'}(0) = E_k(0)$ might not be any help in decrypting
additional traffic enciphered under $k$.

This example illustrates the need for formal, rigorous proofs
of security (and careful definitions).
%Therefore, it is not entirely obvious that an algorithm for
%breaking the one-way function can be converted into an algorithm
%that breaks the block cipher.
%The possibility of key-collisions renders the naive line
%of approach unworkable, and some more sophisticated observations
%are needed to fill the gap.
%
In this paper, we formally prove that in fact the simple construction of
a one-way function as $h(k) = E_k(0)$ is indeed secure, even though
the naive line of argument sketched above doesn't work.
Providing a correct and tight proof of security is one of the major
contributions of this paper.

%\topic{Related work}
%\ldots % XXX

\topic{Non-uniformity}
In practice, passwords are rarely chosen uniformly at random from
the entire 56-bit keyspace.
However, our proofs of security for the Unix hash function assume
that passwords are chosen according to the uniform distribution.
This is a serious limitation of our result, since real
users usually pick patterned passwords.

We do not know how to prove a robust lower bound for the security
of the Unix password hash scheme when used with
non-uniformly distributed passwords, even if we make additional
assumptions about the security of DES with non-uniformly distributed keys.
Still, we have some initial progress
on the problem, showing a trivial construction that allows us to
prove some good results; the disadvantage is that it requires relatively
strong assumptions about DES.
In Section~\ref{sec:nonuniform}, we provide
formal definitions of security for the problem and present our result,
showing upper and lower bounds for a trivial construction.

We leave it as an interesting open question to find better constructions;
this problem does not seem to have been formally addressed before in
the cryptographic literature.

\topic{Salting}
Another practical consideration is the use of salting.
The Unix password hashing algorithm uses salts to prevent
economies of scale from accruing to the adversary.
Without salting, the attacker can test a guess at a passphrase
against all accounts on the system at the cost of a single
hash-computation, and thus he would gain a speedup
linear in the number of users on the system.
Using a different salt for each user prevents this attack.

In this paper, we do not analyze the effectiveness of salts
at eliminating economies of scale.
Such an analysis would seem to require a deep ad-hoc investigation
into the internal structure of (salted) DES, which is outside
the scope of a theory paper.

Still, we can show that if salting does not hurt DES,
salting does not hurt the one-wayness of the Unix construction.
One merely needs to assume that the salted cipher $x \mapsto \des_{k,s}(x)$
is as secure as unsalted DES,
and then the security of the salted Unix hash follows immediately
with no change in the argument.

\topic{Iteration}
A second technique used in the Unix password hash is the use
of iteration.
Iteration was primarily intended to increase the cost of dictionary
attacks by decreasing the rate at which adversaries can test potential
passwords for correctness: each guess requires 25 DES operations
to test.

We do not know whether this feature
of the Unix hashing algorithm achieves its goal.
Our security bounds for the iterated hash are no better than
those for an unitererated variant.
In other words, we can only prove that breaking the Unix hash is
as hard as breaking DES,
not that it is $25 \times$ harder than breaking DES.
As a result, in practice our lower bounds are 25 times
worse than one might hope for if iteration indeed does its job properly
(since a brute-force search over all possible passwords
takes $25 \times 2^{55}$ DES operations).
While this is still a respectable result, it would be nice to
close the gap somehow; we leave it as another open question
to justify the effectiveness of iteration in the Unix hashing algorithm.

Though we cannot prove that `iteration' is better than `no iteration',
we do show that iteration can't hurt.
This is a real contribution.
In comparison, previous work \cite{LR89} has avoided the complexity
associated with iteration by analyzing only uniterated
variants of the construction.





%Thanks to more than two decades of intensive analysis,
%DES is probably better-understood
%than any other modern encryption algorithm\footnote{At least in the
%open community, anyway.}.
%Since the Unix password hashing function
%is built out of DES in a relatively simple way,
%one might optimistically hope that it might be possible to
%apply all the research on the security of DES to it.
%This paper shows that this hope is in fact achievable,
%and moreover that very strong lower bounds on the security
%of the Unix algorithm are available.
%
%For the bulk of this paper, we shall ignore the salting mechanism.
%\ldots
%
%We rely heavily on the formal techniques of concrete security analysis
%developed in \cite{?} \ldots


\section{An outline of the analysis}
\label{sec:ideas}

Our analysis of the Unix hash uses essentially only two new ideas:
an observation about close ties between the Unix hash and
the CBC-MAC construction,
and some new results on the construction of a one-way function
as $h(k) = E_k(0)$.
In the remainder of this section, we give a high-level sketch of
these two fundamental observations.

\topic{Relevance of the CBC-MAC}
First, we show that the Unix password hashing algorithm
is just a special case of the more general and better-studied DES-CBC-MAC
construction \cite{BKR94}.
Consequently, we can take advantage of well-known results on the security
of DES-CBC-MAC.

Let $\mbox{$f$-CBC-MAC}(x)$ denote the CBC-MAC
of the message $x$ under the function $f$.
Recall that the $\mbox{$f$-CBC-MAC}$ of a $n$-block message $x$
under function $f$ is defined as
\[
\mbox{$f$-CBC-MAC}(x) =
f(x_n \oplus  \cdots f(x_2 \oplus f(x_1))\cdots ).
\]
Then it is not hard to see that we get a close relation between
$n$-fold iterated encryption and the CBC-MAC on a $n$-block message:
\[ f^n(x) = \mbox{$f$-CBC-MAC}(\langle x,0,0,\ldots,0 \rangle). \]
This observation may be of independent interest, because it gives
a simple and powerful way to analyze iterated encryption.

Using this trick, we observe that the Unix password
hashing algorithm can be related to the DES-CBC-MAC by
\[ \mbox{Unix-hash}(k) = \mbox{DES-CBC-MAC}_k(\langle 0,\ldots,0 \rangle). \]
%where $\langle 0 \rangle$ is the all-zeros message with 25 blocks.
This is the basis for our treatment of iteration in the Unix
password hash.

\topic{New results on construction of one-way functions}
Next, we establish some new results on the construction
of a one-way function as $h(k) = E_k(0)$,
and use these results to relate the security of the Unix password
hashing algorithm to the security of DES-CBC-MAC.
This observation involves some technical analysis:
we show that every pseudorandom generator (``stream cipher'')
is a good one-way function,
using a counting argument to bound the number of keys
which are bad for hashing.
See Section~\ref{sec:analysis} for the details.

Along the way, we will find that
we have established a strong bound on the security
of the construction of a one-way function $h$ as $h(k) = F_k(0)$,
where $F$ is an arbitrary pseudorandom function or block cipher,
or as $h(k) = g(k)$ where $g$ is an arbitrary stream cipher.
We show that the construction preserves the security of $F$ (or $g$)
with very little degradation.

This security analysis of constructions for one-way functions
may be of independent interest, as it shows that one can
simultaneously achieve simplicity, excellent performance,
and minimal degradation of security.

\topic{Finishing up}
With these two ideas in hand, everything else is standard.
Bellare et. al show that DES-CBC-MAC is a secure PRF if DES is
secure \cite{BKR94}.
It is not hard to show that $g(k) = \mbox{DES-CBC-MAC}_k(0)$ is
a secure pseudorandom generator if DES-CBC-MAC is a secure PRF.
Then, our counting argument shows that $H(k) = g(k)$ is a secure
one-way function, under mild assumptions on the security of DES.

\section{Definitions}
\label{sec:defn}

Definitions of concrete security are parametrized
by a measure of the resources needed to break the cryptographic primitive.
In general, we say that an attack $R$-breaks a crypto primitive if
the algorithm succeeds in breaking the primitive with resources specified
by $R$, and we say that a crypto primitive is $R$-secure if there is no
algorithm\footnote{We may assume without loss of generality
that all adversarial algorithms behave deterministically, since any
probabilistic adversary can be de-randomized using standard techniques.}
to $R$-break it.
In the definitions to follow, we elaborate on the measure of
an adversary's resources.

First, we formally define the concept of a pseudorandom function (PRF).
Let $F : \K \times \X \to \Y$ be a keyed function.
We say that the oracle algorithm $A$ is an adversary which
$(t,q,e)$-breaks the alleged-PRF $F$ if $A$ runs in time $t$,
makes at most $q$ queries to its oracle,
and has advantage $\Adv A = e$.
The adversary's advantage $\Adv A$ is defined to be
\[ \Adv A = \left| \Pr[A^{F_k} = 1] - \Pr[A^R = 1] \right|, \]
where the probability is taken over the choice of $k$ and $R$,
and where the random variable $k$ is drawn from the uniform distribution
over $\K$ and $R : \X \to \Y$ is a random function.
We say that $F$ is a $(t,q,e)$-secure PRF if there is no adversary
which $(t,q,e)$-breaks $F$.

A $(t,q,e)$-secure pseudorandom permutation (PRP)
$E : \K \times \Y \to \Y$ is a pseudorandom function
where each $E_k$ forms a permutation.
We ask that $E_k$ be indistinguishable from a random
permutation $\pi : \Y \to \Y$ chosen uniformly at random from the set of
all permutations on $\Y$, when $k$ is drawn uniformly at random from $\K$.
The advantage of an adversary $A$ is defined as
$\Adv A = \left| \Pr[A^{E_k,E_k^{-1}} = 1] - \Pr[A^{\pi,\pi^{-1}} = 1] \right|$.

A pseudorandom generator (PRG) is a function $g : \K \to \Y$
which stretches a short seed (from $\K$) into a long, random-looking output.
The advantage of an adversary for $g$ is defined to be
$\Adv A = \left| \Pr[A(g(k)) = 1] - \Pr[A(u_Y) = 1] \right|$,
where the random variables $k$ and $u_Y$ are chosenly randomly according
to the uniform distributions on $\K$ and $\Y$ (resp.).
In the case of pseudorandom generators, normally one insists
that the output be longer than the seed,
i.e., that $|\Y| > |\K|$.

Also, it is useful to have the concept of a one-way function (OWF).
Let $h : \K \to \Y$ be an unkeyed function.
An adversary $B$ attacking $h$ is a 
algorithm with input $y \in \Y$
which outputs a symbol in $\K \cup \{\bot\}$,
and which is {\em correct};
$B$ is correct when $y \in \Y, B(y) \ne \bot$ implies $h(B(y)) = y$.
We say that an adversary $B$ $(t,p)$-breaks the alleged-OWF $h$
if $B$ runs in time $t$ and succeeds with probability
$p = \Pr[B(h(k)) \ne \bot]$,
where the probability is taken over the choice of $k \in \K$,
and the random variable $k$ is drawn from the uniform distribution.
Finally, we say that $g$ is a $(t,p)$-secure OWF
if there is no adversary which $(t,p)$-breaks it.

Note that the notion of a one-way function exactly captures the
security properties we need from a password hashing function.
In particular, if $g$ is a $(t,p)$-secure OWF, then the success
probability of any adversary running in time $t$ is at most $p$.


\section{Analysis}\label{sec:analysis}

The main result is a proof that any pseudorandom generator
is a good one-way function.

\begin{theorem}\label{th:prg2owf}
Let $g : \K \to \Y$ be a $(t,e)$-secure pseudorandom generator,
with $|\Y| > |\K|$.
Then $g$ is a $(t',p)$-secure one-way function, where
$p = e / (1 - |\K|/|\Y|)$ and $t' \approx t$.
\end{theorem}
\begin{remark} To be more precise, we show that $g$ is
$(t',p)$-secure, where $t'=t-c$ and
$c$ is a universal constant which depends only on the machine model.
However, in practice $c$ is extremely small compared to $t$,
so for simplicity of exposition in this paper we omit
these tiny constants and summarize the situation
by writing $t' \approx t$.  \end{remark}
%\begin{remark} When $\kappa \ge \eta$, the theorem says nothing useful.
%Nonetheless, very effective techniques are still available to construct
%a useable one-way function with not too much loss in security.
%For example, if $F$ is $(t'',m,e'')$-secure,
%we may use the construction of Theorem~\ref{th:prf2prf} to build
%a new $(t'',1,e'')$-secure PRF
%$\bar{F} : \Z_2^{\nu-m} \times \Z_2^{\kappa} \to \Z_2^{m\eta}$ with
%outputs $m$ times as wide as $F$,
%and then apply Theorem~\ref{th:prf2owf} to $\bar{F}$ to obtain a
%$(t''-c,e''/(1-2^{\kappa-m\eta})$-secure one-way function $g$ as
%$g(x) = \bar{F}_x(0)$.
%For typical PRF algorithms that arise in practice,
%it is often possible to get quite close to the best possible result
%with an appropriate choice of $m$.  \end{remark}
\begin{proof}%[of Theorem~\ref{th:prg2owf}]
We prove the contrapositive.
Let $h=g$ be our alleged one-way function.
Suppose that there is an adversary $B$ which $(t,p)$-breaks $h$
(viewed as a one-way function).
We construct an adversary $A$ against $g$ (viewed as a PRG), defined by
$$A(y) = \left\{ \begin{array}{ll}
	1\qquad	&\mbox{if }B(y) \ne \bot \\
	0	&\mbox{otherwise.}
	\end{array} \right.$$
Our claim is that $A$ $(t,e)$-breaks $g$ (the pseudorandom generator),
i.e., that $\Adv A \ge (1 - |\K|/|\Y|) \cdot p$.
A bit of notation: we let $k$ stand for a random variable
uniformly distributed over $\K$, and $u_Y$ for a r.v. that
is uniform over $\Y$.
All probabilities are calculated with respect to $k$.

Let $V = \{y \in \Y : B(y) \ne \bot\}$ be the set of outputs of $h$ where
$B$ succeeds.
Also, let $W = \{k \in \K : h(k) \in V\}$ be the set of inputs to $h$
which are not secure against $B$.
We see that $p = \Pr[h(k) \in V] = \Pr[k \in W]$.

Next, we observe that $|V| \le |W|$.
The argument goes like this.
We may view $B$ as a deterministic function
(by standard de-randomization results).
We examine $B'$, the restriction of $B$ to the domain $V$.
This restriction is well-defined, since when $v \in V$,
$B(v)$ is a well-defined element of $K$.
Moreover, using the correctness of $B$, we have
$g(B(v)) = v \in V$ for all $v \in V$,
so that $B(v) \in W$ for all $v \in V$.
Thus we may consider $B'$ as
a function with signature $V \to W$.
Also, if $v,v' \in V$ and $B(v) = B(v')$, we find that
$v = g(B(v)) = g(B(v')) = v'$;
therefore, $B'$ is one-to-one.
In summary, we have exhibited a one-to-one function from $V$ to $W$,
which demonstrates that $|V| \leq |W|$.

Finally, we are ready to calculate the advantage of the adversary $A$.
First,
\[ \Pr[A(g(k)) = 1] = \Pr[B(h(k)) \ne \bot] = \Pr[h(k) \in V] = p. \]
%%since $F'_j(0)$ is uniformly distributed when $j$ is, we see that
Also $|W| = |\K| \cdot \Pr[k \in W] = |\K| \cdot p$ and $|V| \le |W|$, so
\[ \Pr[A(u_Y) = 1] = \Pr[u_Y \in V] = |V|/|\Y|
   \le |W|/|\Y|  = |\K|/|\Y| \cdot p. \]
Plugging into the definition of $\Adv A$ gives
\[ \Adv A \ge \left| p - |\K|/|\Y| \cdot p \right|
  = (1 - |\K|/|\Y|) \cdot p = e. \]
To recap, under the assumption that there is an adversary $B$
which $(t,p)$-breaks $h$,
we obtain an adversary $A$ which shows that $g$ is not
$(t,e)$-secure, and this is the desired result.
\hfill\qed
\end{proof}

\begin{lemma}\label{th:prp2prf}
A $(t,q,e)$-secure PRP  $E : \K \times \Y \to \Y$
is a $(t,q,e+q^2/2|\Y|)$-secure PRF.
\end{lemma}
\begin{proof}
This lemma is a well-known consequence of the birthday paradox.
For a full proof, see, e.g., \cite{BKR94}.
\hfill\qed
\end{proof}

\begin{lemma}\label{th:cbc}
If $F: \K \times \Y \to \Y$ is a $(t,q,e)$-secure PRF, then $F^n$ is a
$(t',q/n,e')$-secure PRF, where
$t'=t-q \log_2 |\Y|$ and $e' = e + 1.5 q^2/|\Y|$.
\end{lemma}
\begin{proof}
Recall that $F_k^n(x)=F_k(\cdots(F_k(x))\cdots)$
is a $F_k$-CBC-MAC on the message $\langle x,0,0,\ldots,0 \rangle$,
as noted in Section~\ref{sec:ideas}.
Now invoke \cite[Lemma 4.1]{BKR94} to show that the $F_k$-CBC-MAC
is a secure PRF.
%of Bellare, Kilian, and Rogaway's analysis of
%the CBC-MAC \cite{BKR94}.
\hfill\qed
\end{proof}

\begin{lemma}\label{th:prf2prg}
If $F$ is a $(t,1,e)$-secure PRF, then $g(k)=F_k(0)$ is a $(t,e)$-secure PRG.
\end{lemma}
\begin{proof}
Immediate from the definitions.
\hfill\qed
\end{proof}

\begin{theorem}
If $\des$ is a $(t,25,e)$-secure pseudorandom permutation,
then the Unix construction
is a $(t',p)$-secure password hashing function, where
$p = (1+1/255) e + (1+1/255) \cdot 25^2/2^{63} \approx (1+1/255) e$
and $t' \approx t$.
\end{theorem}
\begin{proof}
Applying Lemmas~\ref{th:prp2prf} and \ref{th:cbc},
we see that $x \mapsto \des_k^{25}(x)$ is a
$(\tau,1,\epsilon)$-secure PRF, where
$\tau = t - 25 \times 64$ and $\epsilon = e + 2q^2/|\Y|$.
Lemma~\ref{th:prf2prg} then shows that the Unix algorithm
is a $(\tau,\epsilon)$-secure PRG.
Finally, Theorem~\ref{th:prg2owf} assures us that the Unix
construction is a $(t',p)$-secure one-way function,
where $t' = \tau - c = t - 25 \times 64 - c \approx t$
and $p = \epsilon/(1 - 2^{-8}) = (1+1/255) \epsilon$.
As discussed above, this is exactly the notion needed to show
that the Unix password hashing algorithm is secure when
used with uniformly-distributed passwords.
\hfill\qed
\end{proof}

\section{Non-uniformly distributed secrets}
\label{sec:nonuniform}

So far our proofs of security have assumed that all passwords
are uniformly distributed.
In practice, though, such an assumption is often far from the mark.
This section tackles the issue of security for non-uniform distributions.

  In this section, we introduce a new security model,
  {\em passphrase-based cryptography}, where keying material and
  other cryptographic secrets are derived from human-entered passphrases
  and thus are likely to have a highly non-uniform distribution.
  This is a significant departure from the standard model, where
  the very definitions of security assume a uniform distribution on the keys.
  A second important difference is that passphrases are typically relatively
  short, so the secret entropy in them is a scarce resource
  which we must not waste.
  We show that the standard approaches to smoothing non-uniform
  distributions are unsuitable for practical use
  because they waste too much entropy.
  Therefore, new techniques are needed.

Let us start by developing formal definitions of security for
passphrase-based cryptography.  We need a small amount of background.

%\begin{definition}
Let $D$ be a distribution on $\K$ which assigns the
probability $D(k)$ to each $k \in \K$, and let $D(S) = \sum_{k \in S} D(k)$
for all $S \subset \K$.
In this paper, we define
\[ \chi_D(t) = \max \{D(S) : S \subset \K, |S| \le t\}. \]
%\end{definition}
This definition is motivated by the following upper bound on the
security of hashing inputs with distribution $D$:
\begin{theorem}\label{th:dictionary}
For all one-way hash functions $f$,
all distributions $D$, and all time bounds $t$,
there is a generic attack, called the {\em dictionary attack},
which $(t,\chi_D(t))$-breaks $f$.
\end{theorem}
\begin{proof}
The dictionary attack proceeds by trying the $t$ elements of $D$
with the $t$ largest probabilities.
(Each guess can be easily checked with a single computation of $f$.)
If we write the $D$-probabilities in decreasing order,
$d_1 \ge d_2 \ge d_3 \ge \cdots$, we can see that the
success probability of the dictionary attack is
$d_1 + d_2 + \cdots + d_t$;
furthermore, this quantity is precisely $\chi_D(t)$.
\hfill\qed
\end{proof}
Therefore, $\chi_D$ describes the effectiveness of the optimal
dictionary-search attack against $D$:
no matter what we do,
{\em every} one-way hash function with
inputs chosen according to $D$ can be broken with probability
$\chi_D(t)$ and time $t$.

There is no way to avoid the dictionary attack.
This motivates our definition of security for a one-way hash function
that operates on inputs with a non-uniform distribution:
\begin{definition}
We say that the one-way function $f$ is {\em ideally-secure} 
for distribution $D$ if
$f$ is $(t,\chi_D(t))$-secure (for all $t$)
when its inputs are distributed according to $D$.
\end{definition}
Intuitively speaking, a one-way function is ideally-secure
if the dictionary attack is the best attack.

We are able to show that any one-way function that is sufficiently 
strong for uniformly distributed inputs will also be relatively good
for other distributions.
\begin{theorem}\label{th:nonunif}
Let $f$ be a one-way function that is $(t,p)$-secure for uniformly-distributed
inputs.
Then, for every distribution $D$ on $\K$,
$f$ is a $(t,\chi_D(p|\K|))$-secure one-way hash function for $D$.
\end{theorem}
\begin{proof}
Let $A$ be an adversary which $(t,p')$-breaks $f$ (for $D$),
where $p' \ge \chi_D(p|\K|)$.
We will show that $A$ also $(t,p)$-breaks $f$ (for uniformly
distributed inputs), and then taking the contrapositive
will yield the desired result.

Let $S = \{k \in \K : A(f(k)) \ne \bot\}$
be the set of $f$-inputs which are not safe against $A$.
Note that $p' = D(S)$,
and moreover that
$\chi_D(|S|) \ge D(S)$ (by the definition of $\chi_D$),
so we have
\[ \chi_D(|S|) \ge D(S) = p' \ge \chi_D(p|\K|). \]
Since $\chi_D(t)$ is a monotonically increasing function of $t$,
we may conclude that $|S| \ge p|\K|$.

Now we may prove that $A$ indeed works well, not just for the distribution
$D$, but also for the uniform distribution.
Note that
\[ \Pr[A(f(k)) \ne \bot] = \Pr[k \in S] = |S|/|\K| \ge p \]
when $k$ is drawn from the uniform distribution on $\K$.
Therefore, $A$ is an adversary that $(t,p)$-breaks $f$ (for the uniform
distribution), as claimed, and the theorem follows.
\hfill\qed
\end{proof}

\begin{corollary}
If the one-way function $f$ is ideally-secure for the uniform distribution,
then it is also ideally-secure for all other distributions as well.
\end{corollary}
\begin{proof}
For the uniform distribution $U$ on $\K$,
we have $\chi_U(t) = t/|\K|$, so by assumption
$f$ is $(t,t/|\K|)$-secure for all $t$.
Now Theorem~\ref{th:nonunif} assures us that $f$ is
$(t,\chi_D(t))$-secure for all distributions $D$,
since $\chi_D((t/|\K|) \cdot |\K|) = \chi_D(t)$.
\hfill\qed
\end{proof}


%if $f$ is $(t,\alpha(t))$-secure for all $t$,
%then $g$ is $(\alpha^{-1}(\chi^{-1}(p')/|\K|),p')$-secure for all $p',D$.
% conjecture: for DES, \alpha(t)=t/2^55

\topic{Applications to Unix password hashing}
%The above results may be used to prove lower bounds on the
%security of the Unix password hashing algorithm when used with
%patterned passwords, if we are willing to assume that DES is
%sufficiently strong when used with uniformly-distributed keys.
%If we assume that DES is sufficiently strong (when used with
%uniformly-distributed keys), then we may be assured that the
%Unix hash is strong (even for non-uniformly distributed passwords).
%
We can show that the Unix hash is good at
hashing even non-uniformly distributed passwords, under
assumptions on DES that appear to be reasonable (albeit stronger
than one might like).

In Section~\ref{sec:results}, we argued that DES appears
to be $(t,25,t/2^{55})$-secure, if the cryptanalysis results
reported in the open literature do indeed represent the best
attacks on DES (as many researchers believe).
This assumption implies that the Unix hash $H$ is a
$(t',t/2^{56})$-secure one-way function
when its inputs are uniformly distributed,
where $t' = (1 - 2^{-8}) (t/2 - 25^2/2^8) \approx (1 + 2^{-8})t/2$.
Thus, Theorem~\ref{th:nonunif} allows us to conclude that the
Unix hash is $(t',\chi_D(t))$-secure---i.e., nearly
$(t/2,\chi_D(t))$-secure---for every distribution $D$.

This lower bound only differs from Theorem~\ref{th:dictionary}'s upper bound
by a factor of about two\footnote{If we consider that the Unix hash internally
iterates DES 25 times and thus costs 25 times as much to compute as does
a single DES trial encryption, the gap between the upper and lower bounds
becomes a factor of about 50, which is still quite small.}.
Roughly speaking, this means that the Unix hash appears to be
nearly ideally-secure for all distributions $D$:
no shortcut attack can do much better than the dictionary attack.

Whether this result is useful in practice will depend on several
factors.
One disadvantage is that the approach requires relatively strong assumptions
about DES---that there are no shortcut attacks on DES that reduce
the workfactor of exhaustive keysearch by more than a small factor when
the key is uniformly distributed---and
as a result, the result is not as robust as we would like.
For example, if small weaknesses are present in DES,
our proof techniques cannot rule out the possibility that these
weaknesses might be greatly magnified when one uses DES with
patterned passwords, even though such a worst-case scenario is
considered unlikely by practitioners.

However, it is interesting to point out that we obtain a proof of
security for the Unix hash of patterned passwords starting only with
the assumption that DES is secure for uniformly-distributed keys.
In particular, we make no assumptions whatsoever about the behavior
of DES when keyed from a non-uniform distribution.
%, and yet we still
%end up with results for non-uniformly distributed passwords.
%%However, it is interesting to point out that there is no need to assume
%%that DES is secure when used with non-uniformly distributed keys to obtain
%%our results on the security of the Unix hash for patterned passwords.
Consequently, we can take advantage of the decades of analysis on DES
(which has all been premised on the assumption of uniformly-distributed keys)
to gain confidence in the security of the Unix algorithm.

\topic{Applications to other crypto primitives}
It is also worth noting that Theorem~\ref{th:nonunif} can also be
generalized to many other keyed cryptographic primitives, such as block
ciphers, stream ciphers, and PRF's, using the same style of proof.
This suggests that our results may have broader applications
to the entire field of passphrase-based cryptography.

\topic{Tightness}
One can show that our lower bound (given in Theorem~\ref{th:nonunif})
on the security of $f$ for non-uniform distributions is essentially tight.
In other words, it is unlikely that one can do much better without either
making additional assumptions on $f$
or finding a better construction.

The following simple example is due to David Zuckerman \cite{Zuc99}.
Let $g : \K_1 \to \Y_1$ be an ideally-secure one-way function with keyspace
$\K_1$ and output space $\Y_1$.
We construct $f : \K \to \Y$ as
$f( \langle x,y \rangle ) = \langle g(x),y \rangle$,
where $\K = \K_1 \times \K_2$ and $\Y = \Y_1 \times \K_2$.
Note that $f$ is $(t,t/|\K_1|)$-secure (for all $t$) for
the uniform distribution on $\K$.

Next consider the uniform distribution $D$ on $S \times \K_2$
for some $S \subset \K_1$, i.e.,
$D(\langle x,y \rangle) = 1/(|S| \cdot |\K_2|)$ for all
$\langle x,y \rangle  \in S \times \K_2$
and $D(\langle x,y \rangle)=0$ for $x \notin S$.
Theorem~\ref{th:nonunif} implies $f$ is
$(t,p)$-secure for $D$, where
\[ p = \chi_D({t \over |\K_1|} |\K|) = \chi_D(t |\K_2|)
  = {t |\K_2| \over |S| \cdot |\K_2|} = t/|S|. \]
At the same time, one may clearly $(t,t/|S|)$-break $f$
using a dictionary attack when its inputs are
distributed according to $D$ (see Theorem~\ref{th:dictionary}).
This shows that Theorem~\ref{th:nonunif} is tight.

% XXX: one possibility for improvement is to try to show that,
% if f is (t,p)-secure for the uniform distribution,
% then f is e.g. (t,\chi_D(np|K|)/n)-secure for some n>1.
% this is what I'd like to believe simple key-whitening
% has a hope of achieving, but it's not at all clear to prove it.

\topic{The power of stronger assumptions}
One alternative approach is to start from the assumption that
DES is secure (up to the possibility of dictionary attacks)
no matter what distribution the key is drawn from.
Then we may attempt to prove that the Unix hash is secure for
passwords with distribution $D$ if DES is secure for keys with
distribution $D$.

The following theorem, which forms a nice example of this
approach, is due to M. Bellare (and was stated as a homework
problem in \cite{GB99}):
\begin{theorem}\label{th:bellare}
If $g : \K \to \Y$ is a $(t,e)$-secure pseudorandom generator
for seeds distributed according to $D$, then $g$ is a $(t,p)$-secure
one-way function for $D$, where $p = e + |\K|/|\Y|$.
\end{theorem}
\begin{remark}
Of course, we may take $D$ to be the uniform distribution in the above;
however, this gives strictly weaker bounds than Theorem~\ref{th:nonunif}'s
dedicated proof.
\end{remark}
\begin{proof}
Use the same notation as in the proof of Theorem~\ref{th:prg2owf},
and define the adversary $A$ in the same way.
Note that $\Pr[A(u_Y)=1] \le |\{g(k):k \in \K\}|/|\Y| \le |\K|/|\Y|$,
and $\Pr[A(g(k))=1] = p$ as before, so we get
\[\Adv A
= \left|\Pr[A(g(k))=1] - \Pr[A(u_Y)=1]\right|
\ge \left|p - |\K|/|\Y|\right| = e.\]
In other words, if there is an adversary $B$ to
$(t,p)$-break $g$ as a one-way function, then there is another
adversary $A$ to $(t,e)$-break $g$ as a pseudorandom generator,
and the theorem follows.
\hfill\qed
\end{proof}
While this result may be useful in some contexts, it doesn't
give terribly useful lower bounds for the security of the Unix hash.
For the Unix algorithm, we have $|\K|/|\Y|=2^{-8}$, so we won't
be able to rule out the possibility that there exists an
algorithm that succeeds in breaking $1/256$ of all passwords
in constant time.
Such a result is not terribly reassuring.

One could attempt to repair the flaw by defining a new hash
construction, e.g., $\mbox{New-hash}(k) = \langle\des_k(0),\des_k(1)\rangle$.
Such an approach would work---if one is willing to deploy an
updated implementation of the password hashing algorithm on
millions of machines around the world!---but
it would still require strong assumptions
about the security of DES when used with non-uniformly distributed keys.
Since DES has not received as much scrutiny in this setting
(where the key is non-uniformly distributed), it becomes
harder to gain much confidence that the necessary
assumptions are indeed satisfied.

Therefore, we conclude that this approach does not seem to yield
security bounds that are as meaningful as those that can be achieved
with Theorem~\ref{th:nonunif}.

\topic{Comparison to entropy smoothing}
Another alternative approach to dealing with patterned passwords
is to smooth out the non-uniformity in the distribution.
A well-known result called the {\em leftover hash lemma} \cite{HILL99,IZ89}
shows that universal hash functions are good at entropy smoothing:
if $h$ is selected uniformly at random from a family of universal
hash functions with $m$-bit outputs,
and if $k$ is drawn from a distribution with at least $3m$ bits
of Renyi entropy, the random variable $\langle h,h(k) \rangle$
will be approximately uniformly distributed.

The disadvantage with the leftover hash lemma is that it wastes at least
two-thirds of the entropy of the password $k$: if we want to feed the
smoothed bits into the Unix hash function
(e.g., $\mbox{New-hash}(k) = \langle h,\mbox{Unix-hash}(h(k)) \rangle$),
we need a passphrase with at least $3 \times 56 = 168$ bits of
entropy.
This would require that
passphrases consist of hundreds of characters, which is
too difficult for most mere mortals to memorize.
When we consider that, in the real world, one is lucky to find a password
with more than 25--35 bits of entropy, it becomes clear that the leftover
hash lemma is thoroughly insuitable for practical use.

%Another (lesser)
%problem is that the leftover hash lemma requires Renyi entropy,
%which may not match our intuition of password
%entropy (`unguessability') very well.

The problem is that universal hash functions (and their generalizations,
e.g., extractors) are designed for use in de-randomization,
where the scarce resource is uniformly-distributed randomness,
and non-uniformly distributed bits are very cheap.
In contrast, for passphrase-based cryptography,
{\em secret randomness} (e.g., passwords, passphrases, etc.)
should be considered a very precious resource that must be conserved
at all costs, whereas {\em public randomness}
(even uniformly-distributed public randomness) is nearly free.
This suggests that new approaches may be required, and we leave
this as an interesting challenge for further study.


\section{Conclusions}
\label{sec:conc}

We have shown explicit lower bounds on the security of the Unix
password hashing algorithm and demonstrated that, under reasonable
cryptographic assumptions, the construction appears to be well-designed
and very strong.
This gives the first realistic proof of security for the Unix hash function.

Our work provides yet another piece of evidence that concrete security
analysis is a powerful technique for understanding cryptographic primitives
and that concrete security analysis
can be an effective tool for analyzing pre-existing constructions found in
real-world, widely-deployed systems.

\section{Acknowledgements}
We would like to gratefully acknowledge the contributions of
Mihir Bellare and Phil Rogaway (for their helpful observations
and careful commentary), Dan Boneh (who pointed out the
relevance of the leftover hash lemma), David Zuckerman (who contributed
the simplified example used in showing the tightness of
Theorem~\ref{th:nonunif}), and Umesh Vazirani (for helpful discussions
on extractors and entropy smoothing).
% XXX: also thank Vazirani.
%We are indebted to Mihir Bellare, Ran Canetti, and Hugo Krawczyk
%for the wonderful analogy to winemaking \cite{BCK96}.

\begin{thebibliography}{9}
\bibitem{BKR94} M. Bellare, J. Kilian, P. Rogaway,
``The Security of the Cipher Block Chaining Message Authentication Code,''
{\em CRYPTO '94}, Springer-Verlag, 1994.

\bibitem{BCK96} M. Bellare, R. Canetti, H. Krawczyk,
``Keying hash functions for message authentication,'',
{\em CRYPTO '96}, Springer-Verlag, 1996.

\bibitem{GB99} S. Goldwasser, M. Bellare,
``Lecture Notes on Cryptography,'' available online from
\verb+http://www-cse.ucsd.edu/users/mihir/papers/gb.html+.

\bibitem{HILL99} J. Hastad, R. Impagliazzo, L.A. Levin, M. Luby,
``A pseudorandom generator from any one-way function,''
{\em SIAM Journal on Computing}, vol.28 no.4, 1999.

\bibitem{IZ89} R. Impagliazzo and D. Zuckerman, 
``How to Recycle Random Bits,'' {\em FOCS '89}, IEEE Press, 1989.

\bibitem{LR87} M. Luby, C. Rackoff, ``A study of password security,''
{\em CRYPTO '87}, Springer-Verlag, 1988.

\bibitem{LR89} M. Luby, C. Rackoff, ``A study of password security,''
{\em J. Cryptology}, vol. 1 no. 3, 1989.

\bibitem{Zuc99} D. Zuckerman, personal communication, July 1999.
\end{thebibliography}

\end{document}
@


1.27
log
@*** empty log message ***
@
text
@d980 1
a980 1
\begin{theorem}
d985 5
@


1.26
log
@*** empty log message ***
@
text
@d1081 7
a1087 4
Thanks to Mihir Bellare and Phil Rogaway for their helpful observations
and careful commentary.
I am also grateful for discussions with Dan Boneh, who pointed out the
relevance of the leftover hash lemma.
@


1.25
log
@*** empty log message ***
@
text
@d49 1
a49 1
Luby and Rackoff presented strong evidence that the basic
d51 1
a51 1
However, their approach has three serious limitations:
d1002 3
a1004 2
be able to rule out the possibility that one can gain a $1/256$
chance of breaking a password in constant time.
d1015 2
a1016 2
(where the key is non-uniformly distributed), it becomes much
harder to gain confidence that the necessary
d1024 1
a1024 1
One alternative approach to dealing with patterned passwords
d1035 1
a1035 1
2/3 of the entropy of the password $k$: if we want to feed the
d1044 1
a1044 1
with more than 30--40 bits of entropy, it is clear that the leftover
d1062 1
a1062 1
this as an interesting challenge for study.
d1068 9
a1076 5
This work provides yet another piece of evidence that concrete security
analysis is a powerful technique for understanding cryptographic primitives.
Furthermore, in contrast to most prior work
(which has focused on concrete security analysis as a methodology
for the design of new primitives), we show that concrete security analysis
@


1.24
log
@*** empty log message ***
@
text
@d636 1
a636 1
uniformly distributed over $K$, and $u_Y$ for a r.v. that
d927 5
a931 1

d969 11
a979 18
\topic{Comparison to other constructions}
We know of only two other techniques for building one-way functions
that can handle non-uniformly distributed inputs:
(1) make additional assumptions
on the security of DES (or the underlying primitive, be it a PRF, PRP,
or PRG) when used with non-uniformly distributed keys, or
(2) use the leftover hash lemma.
We will examine each of these directions in turn and compare them
to our results.

The first approach relies on reductions which are security-preserving
for any distribution $D$ on the key input.
Then, if we assume that DES is secure for distribution $D$, we will
be able to show something about the security of the one-way function
for $D$.
The key theorem is a concretization of Luby and Rackoff's asymptotic
argument which is due to M. Bellare (stated in a homework problem for
an class in cryptography):
d986 12
d999 41
a1039 29

The leftover hash lemma \cite{HILL99,IZ89} describes a way to ``smooth out''
the entropy in the password using universal hash functions, so that
the result is approximately uniformly distributed and can be handled
by any one-way function that is secure for uniformly distributed inputs.
In its original form, the lemma states that $(h,h(k))$ is
approximately uniformly distributed if (1) $h$ is drawn uniformly
at random from a family of universal hash functions mapping $n$-bit
inputs to $m$-bit outputs, (2) $k$ is distributed uniformly on some
set $S \subset \Z_2$ , and (3) $|S| \ge 2^{3m}$.
(The lemma can be easily generalized to the case where (2',3')
$H_2(k) \ge 3m$, where $H_2(k) = -\log_2 \sum_{k \in \K} \Pr[k]^2$
is the Renyi entropy of order two.  This is an improvement, but
the core disadvantages of the lemma still remain.)

The disadvantage of using the leftover hash lemma
is that it wastes 2/3 of the entropy of the password
(due to requirement (3)).
For example, if we envision that the user will choose a
password with 30 bits of entropy (probably a rather generous assumption
in practice), we will have to crunch it down to a 10-bit field
using universal hash functions before we can apply the one-way
function.
In such a scheme, an adversary could invert the one-way function
(and break into the system!) with only $2^{10}$ work, and this

If we wanted to use a one-way hash function with a 56-bit input
(like the Unix algorithm), users would need to choose passphrases
with at least 168 bits of entropy; this would require that
d1042 14
a1055 7
These examples illustrate that the leftover hash lemma is thoroughly
unsuitable for hashing passwords (or keying other cryptosystems
with passphrases) in the real world.

\topic{A new model}
Our analysis of the leftover hash lemma suggests a new model
for extracting entropy from non-uniformly distributed secrets:
d1059 3
a1061 36
(any random quantity which are disclosed) is nearly free.
\marginpar{Is this really new?}

Thus, an algorithm which operates on non-uniformly distributed keying
material must strive to exploit every last bit of secret randomness
available.
The research challenge is to build these type of algorithms
out of cryptographic primitives which are only assumed to be
secure when used with uniformly distributed keys.

To motivate our suggestion that public randomness should be
considered free, we note that in cryptographic applications
large quantities of high-quality pseudorandomness can be
efficiently generated by seeding a secure PRG with a short
string of true randomness; typically, the seed will be publicly
disclosed so the recipient (of the encrypted message, hashed
passphrase, whatever) can replicate those random bits.
One must still prove, on a case-by-case basis, that it is
safe to replace truly random bits with pseudorandom bits,
but we expect that pseudorandomness will nearly
always suffice.

It is interesting to contrast this model to the approach typically
followed when attempting   to de-randomize probabilistic algorithms.
For de-randomization, randomness (in any form) is a scarce resource,
and researchers seek to find de-randomization techniques that do not
rely on any cryptographic assumptions (such as the existence
of pseudorandom generators).
In comparison, for cryptography, secrets are the scarce resource,
because establishing a shared secret is an expensive operation
(it typically requires personal
interaction or some form of trust in third parties).

We feel that this model provides a number of challenges
which are not only nice problems for theoreticians but also
potentially useful to practitioners.
a1063 5

%This can be recognized as a limitation of the classical definitions of
%security for cryptographic primitives: they always assume a uniform
%distribution on the secrets or keying material.

d1092 4
@


1.23
log
@*** empty log message ***
@
text
@d252 1
a252 5
with the same theoretical complexity\footnote{Note that in practice
we lose a factor of two (due to the complementation property of DES),
and a factor of 25 (due to iteration, which makes the cost of
each individual step for the Unix hash 25 times as expensive as
for DES).  See below for discussion.}.
d408 7
a414 5
As a result, in practice our lower bounds are 50 times worse than brute-force
search over all possible passwords (which takes $25 \times 2^{56}$
DES operations):
we lose a factor of 25 in the proof due to the iteration, and another factor
of 2 due to the DES complementation property.
d826 1
a826 1
be the set of $f$-inputs which are not safe against $B$.
d832 1
a832 1
Observing that $\chi_D$ is monotonic,
d883 3
a885 3
$(t,(1+1/255)(t/2^{55} + 25^2/2^{63}))$-secure one-way function
when its inputs are uniformly distributed.
\marginpar{XXX: fix}
d887 3
a889 2
Unix hash is $(t/2-25^2/2^8,\chi_D(t))$-secure for every
distribution $D$.
d891 1
a891 1
by a factor of two\footnote{If we consider that the Unix hash internally
d894 1
a894 1
becomes a factor of 50, which is still quite small.}.
d897 1
a897 1
the dictionary attack is just about the best possible attack.
d905 23
a927 7
as a result, the result is not as robust as we would like
(if small weaknesses are present in DES, they might be magnified
by the use of patterned passwords).
However, it is interesting to point out that there is no need to assume
that DES is secure when used with non-uniformly distributed keys,  and
thus we need not discard the decades of analysis on DES that have been
premised on the assumption of uniformly-distributed keys.
d936 1
a936 1
The following example is due to David Zuckerman \cite{Zuc99}.
a963 2

\topic{Applications to other crypto primitives}
@


1.22
log
@*** empty log message ***
@
text
@d175 2
a176 2
$(t,p)$-secure password hashing function,
where $p \approx (1+1/255) e'$.
d181 1
a181 1
$(t,p)$-security for hash functions will be provided later in
d290 1
a290 1
one-way function from any pseudo-random function (PRF)
d312 1
a312 1
any algorithm to break the one-way function, i.e. any
d395 2
a396 1
One merely needs to assume that the salted DES is secure,
d421 1
a421 1
Though we cannot prove that iterating is better than not iterating,
d424 1
a424 1
In comparison, previous work has avoided the complexity
d426 1
a426 1
variants of the construction \cite{LR89}.
d469 4
a472 4
Let $\mbox{DES-CBC-MAC}_k(x)$ denote the DES-CBC-MAC
of the message $x$ under the DES key $k$.
Recall that the DES-CBC-MAC of a 25-block message $x$
under key $k$ is defined as
d474 2
a475 2
\mbox{DES-CBC-MAC}_k(x) =
\des_k(x_{24} \oplus  \cdots \des_k(x_1 \oplus \des_k(x_0))\cdots ).
d478 2
a479 2
$n$-iterated encryption and the CBC-MAC on a $n$-block message:
\[ f^n(x) = \mbox{$f$-CBC-MAC}(x,0,0,\ldots,0). \]
d485 2
a486 1
\[ \mbox{Unix-hash}(k) = \mbox{DES-CBC-MAC}_k(0). \]
d496 1
a496 1
we show that every pseudo-random generator (``stream cipher'')
a501 8
With these two ideas in hand, everything else is standard.
Bellare et. al show that DES-CBC-MAC is a secure PRF if DES is
secure \cite{BKR94}.
It is not hard to show that $g(k) = \mbox{DES-CBC-MAC}_k(0)$ is
a sere pseudo-random generator if DES-CBC-MAC is a secure PRF.
Then, our counting argument shows that $H(k) = g(k)$ is a secure
one-way function, under mild assumptions on the security of DES.

d505 1
a505 1
where $F$ is an arbitrary pseudo-random function or block cipher,
d515 9
d539 1
a539 1
First, we formally define the concept of a pseudo-random function (PRF).
d553 2
a554 2
A $(t,q,e)$-secure pseudo-random permutation (PRP)
$E : \K \times \Y \to \Y$ is a pseudo-random function
d562 1
a562 1
A pseudo-random generator (PRG) is a function $g : \K \to \Y$
d568 1
a568 1
In the case of pseudo-random generators, normally one insists
d570 1
a570 1
i.e. that $|\Y| > |\K|$.
d595 1
a595 1
The main result is a proof that any pseudo-random generator
d599 1
a599 1
Let $g : \K \to \Y$ be a $(t,e)$-secure pseudo-random generator,
d601 2
a602 2
Then $g$ is a $(t,p)$-secure one-way function, where
$p = e / (1 - |\K|/|\Y|)$.
d605 2
a606 2
$(t-c,p)$-secure, where $c$ is a universal constant which depends
only on the machine model.
d609 2
a610 1
these machine-dependent constants.  \end{remark}
d635 2
a636 2
Our claim is that $A$ $(t,e)$-breaks $g$ (the pseudo-random generator),
i.e. that $\Adv A \ge (1 - |\K|/|\Y|) \cdot p$.
d693 1
a693 1
\begin{lemma}
d700 6
a705 3
is a $F_k$-CBC-MAC on $(x,0,0,\ldots,0)$, as noted in Section~\ref{sec:ideas}.
Now invoke Lemma 4.1 of Bellare, Kilian, and Rogaway's analysis of
the CBC-MAC \cite{BKR94}.
d709 1
a709 1
\begin{lemma}
d717 7
a723 16
% XXX: fix the following

\begin{corollary}
If $\des$ is a $(t,25,e)$-PRP, then $H(k)=\des_k^{25}(0)$ is
a $(t,e+25^2/2^{63})$-PRG.  In other words, the Unix hashing algorithm $H$
is a secure pseudo-random generator if DES is a secure block cipher.
\end{corollary}


\begin{corollary}
If DES is a $(t',25,e')$-secure block cipher, then the Unix password
hashing function $H$ is a
$(t,e)$-secure password hashing function,
where $t = t'-25c'/2^{64}-c$ and
$e = (1+1/255)e' + 3 \cdot (1+1/255) \cdot 25^2/2^{65}$.
\end{corollary}
d725 13
a737 8
First, by Theorem~\ref{th:desprf}, we get that DES-CBC-MAC is
a $(t'',1,e'')$-secure PRF, with
$t''=t'-25c'/2^{64}$ and $e''=e' + 3 \cdot 25^2/2^{65}$.
Letting $F$ = DES-CBC-MAC, we see that $H(k) = F_k(0)$, and
Theorem~\ref{th:prf2owf} shows that
$H$ is a $(t,e)$-secure one-way function with
$t=t''-c = t'-25c'/2^{64}-c$ and
$e=e'' \cdot 256/255=(1+1/255)e' + 3 \cdot 256/255 \cdot 25^2/2^{65}$.
a740 2
% XXX: Need a tightness analysis here.

d746 1
a746 1
In practice, though, this assumption is often far from the mark.
d784 1
a784 1
(Each guess can be easily checked with a single hash computation.)
d794 2
a795 1
{\em any} one-way hash function with
d885 3
a887 2
$(t,t/2^{55} + 25^2/2^{63})$-secure one-way function for the
uniform distribution on passwords.
d971 1
a971 1
If $g : \K \to \Y$ is a $(t,e)$-secure pseudo-random generator
d978 1
a978 1
The leftover hash lemma \cite{ILL89,IZ89} describes a way to ``smooth out''
d1015 1
a1015 1
{\em secret randomness} (e.g. passwords, passphrases, etc.)
d1030 1
a1030 1
large quantities of high-quality pseudo-randomness can be
d1036 2
a1037 2
safe to replace truly random bits with pseudo-random bits,
but we expect that pseudo-randomness will nearly
d1045 1
a1045 1
of pseudo-random generators).
d1090 3
a1092 3
\bibitem{ILL89} R. Impagliazzo, L.A. Levin, M. Luby,
``Pseudo-random generation from one-way functions,''
{\em STOC '89}, ACM, 1989.
@


1.21
log
@*** empty log message ***
@
text
@d13 2
a14 1
\title{Proofs of security for the Unix password hashing algorithm}
d22 6
a27 1
\ldots
d51 1
a51 1
However, their approach has some serious limitations:
d80 2
a81 2
The main practical shortcoming of our proof techniques is that,
to prove anything useful about the Unix hashing algorithm,
d83 3
a85 1
are uniformly distributed.
d92 1
a92 2
extending our results to the non-uniform case,
and we present a formal model that we hope may serve as a foundation
d94 16
@


1.20
log
@*** empty log message ***
@
text
@d431 12
a442 5
\begin{enumerate}
\item First, we show that the Unix password hashing algorithm
is just a special case of the more general DES-CBC-MAC
construction \cite{BKR94},
and so we can take advantage of well-known results on the security
a443 6
\item Next, we establish some new results on the construction
of a one-way function as $h(k) = E_k(0)$,
and use these results to relate the security of the Unix password
hashing algorithm to the security of DES-CBC-MAC.
\end{enumerate}
In the remainder of this section, we elaborate on these two ideas.
a444 1
The first idea is a very simple observation.
d465 6
a470 1
The second idea involves some technical analysis:
@


1.19
log
@*** empty log message ***
@
text
@d95 2
a96 2
Section~\ref{sec:theory} dives into the details of the proofs.
Also, Section~\ref{sec:nonunif} gives an formal model for security
d228 6
a233 1
slightly higher---less than 1\% higher---than the chances of breaking DES.
d327 2
a328 2
\topic{Related work}
\ldots % XXX
d346 1
a346 1
In Section~\ref{sec:nonunif}, we provide
d388 1
a388 1
As a result, our lower bounds are 50 times worse than brute-force
d442 1
d657 1
a657 1
For a full proof, see e.g. \cite{HWKS}.
d947 1
a947 1
The leftover hash lemma \cite{?,?} describes a way to ``smooth out''
d1058 7
@


1.18
log
@*** empty log message ***
@
text
@d14 3
a16 1
\author{David Wagner \and Ian Goldberg \\ {\em U.C. Berkeley}}
d44 1
a44 1
approach found in the Unix algorithm is likely to be sound.
d64 1
a64 1
(finite) Unix algorithm, rather than an abstract asymptotic model.
a77 18
%Providing a proof of security for the Unix algorithm without the
%``uniformity'' assumption seems to require some different ideas,
%and we leave it as an open problem for the community.
%
%In this paper, we take an important step towards security for
%non-uniformly distributed passwords: we show how to make a simple,
%efficient modification to the Unix hash algorithm that lets us
%prove security for arbitrary distributions.
%Our approach is based on {\em key whitening}, and it lets us
%prove near-optimal security bounds without making any additional
%assumptions
%(for instance, we do not assume anything about the behavior of
%DES or the Unix hash when used with non-uniformly distributed keys).
%
%Key whitening can also be used to operate other
%cryptographic primitives (block ciphers, stream ciphers, \ldots)
%securely in environments where the key is non-uniformly distributed,
%so this result may be of considerable independent interest.
d82 2
a83 1
In Section~\ref{?}, we make some initial progress on this problem,
d159 1
a159 1
Section~\ref{?}, but for now we just sketch the intuition.
d174 4
a177 4
to prove anything about the Unix scheme:
``you cannot make good wine
from bad grapes'' \cite{?}\footnote{We are indebted to ??? \cite{?} for this
wonderful analogy.}.
d182 1
a182 1
We show that the construction is highly security-preserving:
d196 1
a196 1
the Unix construction is relatively robust.
d211 4
a214 2
Therefore, DES appears to be $(t,25,t/2^{55})$-secure.
Theorem~\ref{th:main} thus says that the Unix scheme is
d259 1
a259 1
The only special property we need is that the block length is larger
d263 9
a271 5
or any stream cipher, so long as the key size is larger than
the block length.
Also, see Section~\ref{?} for an efficient construction that
works for any block cipher, PRF, or stream cipher, even if the
output size is smaller than the key size.
a348 27
\begin{comment}
analyze the situation
in more depth, and we show how to handle non-uniformity if we
are allowed to slightly modify the hash algorithm.

In particular, we describe how to build a one-way function that
is good for {\em all} distributions out of one that is good for
the uniform distribution, using a simple technique called {\em key whitening}.
This approach imposes very little performance overhead, and the
modification can be easily implemented in just a few lines of code.

Best of all, we show that the whitened construction has excellent
security.
If the cryptanalytic results on DES in the open literature really are
the best possible, then the dictionary attack is just about the best
possible attack on the whitened Unix hash: the whitened hash extracts
almost all of the entropy in the password, with very little waste.

The same techniques can also be applied to other cryptographic
primitives as well.
This is a powerful positive result, which shows that algorithm
designers do not need to worry about non-uniformly distributed inputs.
Instead, they can simply concentrate on the core concern,
security for the uniform distribution,
and our construction can be used to take care of the rest.
\end{comment}

d395 3
a397 3
In comparison, previous work has avoided the difficulties
associated with iteration by analyzing only an uniterated
variant of the construction.
d428 2
a429 1
is just a special case of the more general DES-CBC-MAC construction \cite{?},
d488 1
d707 1
d740 1
a740 1
\begin{theorem}
a774 3
%We are able to exhibit a construction which comes remarkably
%close to this ideal.  The idea is to {\em pre-whiten} the input
%with a uniformly-random value before hashing.
d778 1
a778 1
\begin{theorem}\label{th:whiten}
d819 1
a819 1
Now Theorem~\ref{th:whiten} assures us that $f$ is
d851 1
a851 1
Thus, Theorem~\ref{th:whiten} allows us to conclude that the
d854 1
a854 1
This lower bound only differs from Theorem~\ref{th:dicts}'s upper bound
d878 1
a878 1
We can show that our lower bound (given in Theorem~\ref{th:whiten})
d881 2
a882 2
(1) making additional assumptions on $f$,
or (2) finding a better construction.
d884 1
a884 1
Our counterexample is built as follows.
d889 4
a892 2
where $\K = K_1 \times \K_2$ and $\Y = \Y_1 \times \K_2$.
Note that $f$ is $(t,t/|\K_1|)$-secure for all $t$.
d896 4
a899 4
$x \in S, y \in \K_2$ and $D(\langle x,y \rangle)=0$ for $x \notin S$.

Theorem~\ref{?} implies $f$ is
$(t,p)$-secure for
d904 8
a911 2
distributed according to $D$ (see Theorem~\ref{?}).
This shows that Theorem~\ref{?} is tight.
d1040 3
d1044 2
a1045 2
\begin{thebibliography}{XXX99}
\bibitem[BKR94]{BKR94} M. Bellare, J. Kilian, P. Rogaway,
d1048 12
@


1.17
log
@*** empty log message ***
@
text
@d95 7
a101 40
  In general, security issues with non-uniformly distributed keying
  material seem to be rarely considered in the literature.
  In Section~\ref{?}, we make some initial progress on this front,
  presenting a formal model that we hope may serve as a foundation
  for future exploration of this area.

\begin{comment}
  In Section~\ref{?}, we introduce a new security model,
  {\em passphrased-based cryptography}, where keying material and
  other cryptographic secrets are derived from human-entered passphrases
  and thus are likely to have a highly non-uniform distribution.
  This is a significant departure from the standard model, where
  the very definitions of security assume a uniform distribution on the keys.
  A second important difference is that passphrases are typically relatively
  short, so the secret entropy in them is a scarce resource
  which we must not waste.
  We show that the standard approaches to smoothing non-uniform
  distributions are unsuitable for practical use
  because they waste too much entropy.
  Therefore, new techniques are needed.

  In this paper, we introduce a new tool which we call {\em key whitening}:
  it lets us build a primitive secure for arbitrary distributions
  on the passphrase
  out of one which is secure for the uniform distribution.
  %The disadvantage is that it requires a relatively high level of
  %security from the base primitive.
  %This is an important first step for provable security in the
  %passphrase model.
  When applied to password hashing, the key whitening technique
  shows how to make a very simple, efficient modification to the Unix
  hash algorithm that lets us prove excellent security bounds for
  arbitrary distributions without assuming anything about the behavior
  of DES on non-uniformly distributed keys.
  Key whitening also applies to a broad variety of other
  cryptographic primitives (block ciphers, stream ciphers, \ldots),
  so this tool may be of considerable independent interest.
\end{comment}


d111 3
a113 4
Also, Section~\ref{sec:nonunif} gives an in-depth analysis for
non-uniformly distributed passwords, with a description and security
analysis of key whitening; this section may be viewed as a
self-contained mini-paper of its own accord.
d168 1
a168 1
where $p = (1+1/255) (e' + 1875/2^{65})$.
d316 9
a324 7
Therefore, it is not entirely obvious that an algorithm for
breaking the one-way function can be converted into an algorithm
that breaks the block cipher.
The possibility of key-collisions renders the naive line
of approach unworkable, and some more sophisticated observations
are needed to fill the gap.

d342 3
a344 2
We do not know how to prove that the Unix password hash is secure
for non-uniformly distributed passwords, even if we make additional
d346 10
a355 1
The problem does not seem to have been formally addressed before in
a357 5
In Section~\ref{sec:nonunif}, we describe some initial progress on
the problem, providing formal definitions of security for the problem,
and showing upper and lower bounds for a trivial construction.
We leave it as an interesting open question to find better constructions.

d828 1
a828 2
be the set of $f$-inputs which are not safe against $B$,
when the input is pre-whitened by $w$.
d875 1
a875 1
We can show that the Unix hash is extremely good at
d877 2
a878 1
relatively reasonable assumptions on DES.
d885 4
a888 4
$(t,t/2^{55} + 25^2/2^{63})$-secure one-way function (for the
uniform distribution on passwords).
Finally, Theorem~\ref{th:whiten} allows us to conclude that the
whitened Unix hash is $(t/2-25^2/2^8,\chi_D(t))$-secure for every
@


1.16
log
@*** empty log message ***
@
text
@d4 1
d12 1
d95 8
a102 1
  To deal with this limitation, we introduce a new security model,
d132 1
d174 1
a174 1
Actually, this description of the Unix password scheme has omitted one
d206 3
d215 1
a215 1
However, the result is even better than this, because it gives
d232 2
a233 2
the Unix hash is almost as strong as DES, or conversely,
any serious weakness in the Unix hash would imply the
d235 2
a236 1
As a result, our analysis will still be relevant even if DES is found
d239 4
a242 3
The alternative is to base our proof of security on the assumption
that DES behaves like an ideal cipher, but this would say nothing about
whether a small imperfection in DES might be magnified by the Unix
d248 1
a248 1
{\sc An example.}
d261 1
a261 1
Applying Theorem~\ref{th:main}, we find that the Unix scheme is
d299 2
a300 2
Therefore, the Unix hash function might be even stronger than our lower
bounds would suggest.
d302 1
a302 1
{\sc Generalizations.}
d308 4
a311 3

A similar result holds for any pseudo-random function (PRF)
or any stream cipher.
d316 1
a316 1
{\sc A pitfall.}
d319 1
a319 1
Naively one might think that the proof is simple; however,
d339 5
a343 5
To break a one-way function $h$, you don't need to
recover $k$ from $y=h(k)$.
Actually, it suffices to recover some
$k'$, possibly different from $k$, such that $h(k') = y$.
Such a $k'$ will allow access to the system just as well
d359 1
a359 1
the simple line of argument doesn't work.
d363 1
a363 1
{\sc Related work.}
d366 1
a366 1
{\sc Non-uniformity.}
d370 1
a370 1
that passwords are chosen from a uniform distribution.
d377 10
a386 1
However, in Section~\ref{sec:nonunif} we analyze the situation
d410 1
d412 1
a412 1
{\sc Salting.}
d434 1
a434 1
{\sc Iteration.}
d488 1
a488 1
This paper contains essentially only two new ideas.
d491 3
a493 2
is just a special case of the more general DES-CBC-MAC construction.
DES-CBC-MAC has been previously analyzed by ?? and ?? \cite{?}.
a498 1
The rest of the analysis is entirely standard.
d560 1
a560 1
In the definitions to follow, we merely flesh out the measure of
d578 1
a578 1
$E : \K \times \Y \to \Y$ is a $(t,q,e)$-PRF
d580 1
a580 1
We ask that $E$ be indistinguishable from a random
d582 1
a582 1
all permutations on $\Y$.
d593 2
a594 2
that the output be at least one bit longer than the seed,
i.e. that $|\Y| \ge 2 |\K|$.
d706 1
a706 1
\begin{theorem}\label{th:prp2prf}
d709 1
a709 1
\end{theorem}
d711 1
a711 1
This theorem is a well-known consequence of the birthday paradox.
d716 1
a716 1
\begin{theorem}
d720 1
a720 1
\end{theorem}
d729 1
a729 1
\begin{theorem}
d731 1
a731 1
\end{theorem}
d737 2
d769 1
a769 1
So far our proof of security have assumed that all passwords
d774 18
a791 1
\begin{definition}
d795 1
a795 1
We define
d797 1
a797 1
\end{definition}
d835 6
a840 3
We are able to exhibit a construction which comes remarkably
close to this ideal.  The idea is to {\em pre-whiten} the input
with a uniformly-random value before hashing.
d843 1
a843 3
inputs, and define $g(k) = (w, f(k+w))$ where $w \in \K$
is chosen uniformly at random (independent of everything else and
chosen anew for each computation of $g$).
d845 1
a845 1
$g$ is a $(t,\chi_D(p|\K|))$-secure one-way hash function for $D$.
d848 1
a848 1
Let $B$ be an adversary which $(t,p')$-breaks $g$ (for $D$),
d850 1
a850 1
We will exhibit an algorithm $A$ which $(t,p)$-breaks $f$ (for uniformly
d854 2
a855 2
Let $S_w = \{k \in \K : A(w,f(k+w)) \ne \bot\}$
be the set of $g$-inputs which are not safe against $B$,
d857 10
d868 4
a871 17
\[ p' = {1 \over |\K|} \sum_{w \in \K} D(S_w), \]
so there must be some $w \in \K$ with $D(S_w) \ge p' \ge \chi_D(p|\K|)$.
Since $\chi_D(|S_w|) \ge D(S_w)$ (by the definition of $\chi_D$),
and since $\chi_D$ is monotonic,
for this $w$ we must also have $|S_w| \ge p|\K|$.
For the remainder of the proof we fix such a $w$.

We now define the adversary $A$ by $A(y) = B(w,y)+w$.
Clearly $A$ runs in time $t$, and if $B$ succeeds $A$ will too,
so we only need to show that the probability of success is at least $p$.
The success probability is defined as
$\Pr[A(f(k)) \ne \bot]$, where $k \in_R \K$ is chosen
uniformly at random.
Note that $A$ succeeds on $y=f(k)$ whenever $k-w \in S_w$,
and $k$ is chosen independently of $w$, so
\[ \Pr[A(f(k)) \ne \bot] \ge \Pr[k-w \in S_w] = |S_w|/|\K| \ge p. \]
Therefore, $A$ is an adversary that $(t,p)$-breaks $f$, as claimed.
d877 1
a877 1
th  en $g$ (defined as above) is ideally-secure for all distributions.
d883 1
a883 1
Now Theorem~\ref{th:whiten} assures us that $g$ is
d894 13
a906 14
{\sc Applications to Unix password hashing.}
If we are allowed to make a slight modification to the Unix password
hashing algorithm, we may use the pre-whitening technique to achieve provable
security even for non-uniformly distributed passwords.

If $H$ denotes the standard Unix hash, we suggest storing
$(w,H(k \oplus w))$ in the public password file instead of $H(k)$.
Since this approach consists of {\sc xor}ing a random mask
to the password before using it as a DES key, we call this
a {\em key whitening} construction.

We can show that the whitened Unix hash is extremely good at
hashing even non-uniformly distributed passwords, under reasonable
assumptions on DES.
d909 3
a911 2
reported in the open literature are indeed the best attacks on DES.
This result implies that the Unix hash $H$ is a
d917 8
d926 13
a938 9
Roughly speaking, this means that the Unix hash appears to be
nearly ideally-secure for all distributions $D$, i.e. that the
dictionary attack is just about the best possible attack.
This is a very good result.
The lower bound is within a factor of two of Theorem~\ref{th:dict}'s
upper bound, if we ignore the iteration
(it is 50 times worse than brute-force with iteration, since a
dictionary attack requires $25t$ DES operations to succeed with
probability $\chi_D(t)$).
d940 1
a940 1
{\sc Tightness.}
d942 2
a943 2
on the security of $g$ is essentially tight.
In other words, it is unlikely that one can do better without either
d948 19
a966 40
Consider an ideally-secure block cipher $E$ with keyspace $\K'$ and
message space $\X$ such that $|\X| \ge 7 |\K'|$,
i.e. let $E : \K' \times \X \to \X$
be a $(t,q,t/|\K'|)$-secure PRP for all $t$ and all $q$.
Set $\K = \K' \times \X$, $\Y = \X^3$, and
define $f : \K \to \Y$ by a counter-mode construction:
\[ f(k',x) = (E_{k'}(x), E_{k'}(x+1), E_{k'}(x+2)). \]
By Theorems~\ref{th:prg2owf} and \ref{th:prp2prf},
$f$ will be a $(t,p)$-secure one-way function for
\[ p \le {t/|\K'|+9/2|\X| \over 1 - |\K|/|\Y|}
     \le {t+1 \over |\K'|}. \]

Next consider the uniform distribution $D$ on $S \times \X$ for
some $S \subset \K$,
i.e. $D(s,x) = 1/(|S| \cdot |\X|)$ for all $s \in S, x \in \X$
and $D(s,x)=0$ for $s \notin S$.
In the construction given in Theorem~\ref{th:whiten},
the $g$-output $(w,y)$ suggests $|S|$ possibilities for the
encryption key $k'$ (when the input is chosen according to $D$):
if we write $w=(w_{k'},w_x)$, then we have $k'=w_{k'}+s$ for some $s \in S$.
Furthermore, if we can guess $s$ correctly,
the $g$-output $(w,y)$ will also disclose the input to $g$
as $x = E_{k'}^{-1}(y_0)$ (where $y = (y_0,y_1,y_2)$).
These observations give an algorithm that can $(t,t/|S|)$-break $g$
when $g$'s inputs are distributed according to $D$.

If we combine these two will results, we will be able to show
that Theorem~\ref{th:whiten} is nearly tight.
The theorem assures us that $g$ will be $(t,p')$-secure, where
\[ p' = \chi_D(p |\K|) = {p|\K| \over |S| \cdot |\X|}
= p {|\K'| \over |S|}
\le {t+1 \over |\K'|} \times {|\K'| \over |S|}
= {t+1 \over |S|}. \]
(With a little bit of additional work,
the upper bound $(t+1)/|S|$ on $p'$ can be reduced to
$(t+\epsilon)/|S|$ for any fixed $\epsilon > 0$.)
At the same time, we have shown that there exists an adversary
to $(t,t/|S|)$-break $g$.
Therefore, Theorem~\ref{th:whiten} gives essentially the best result
possible for this construction.
d968 1
a968 1
{\sc Applications to other crypto primitives.}
d970 1
a970 1
{\sc Comparison to other constructions.}
d978 1
a978 1
to the {\em key whitening} technique.
d1030 1
a1030 1
{\sc A new model.}
d1082 1
a1082 1
This provides yet another piece of evidence that concrete security
d1084 5
a1088 4
Furthermore, concrete analysis is not only a useful methodology
for the design of new primitives, but also (and perhaps more importantly)
an effective tool for analyzing pre-existing constructions in
real-world, deployed systems.
a1100 13

\appendix
\begin{theorem}\label{th:prf2prf}
Let $F : \Z_2^{\nu} \times \Z_2^{\kappa} \to \Z_2^{\eta}$
be a $(t',q',e')$-secure PRF, and let $m > 0$ be an arbitrary integer.
Define $\bar{F} : \Z_2^{\nu-m} \times \Z_2^{\kappa} \to \Z_2^{m\eta}$ by
\[ \bar{F}_k(x) = (F_k(x,0),F_k(x,1),\ldots,F_k(x,2^m-1)). \]
Let $t = t'$, $q = mq'$, and $e = e'$.
Then $\bar{F}$ is a $(t,q,e)$-secure PRF.
\end{theorem}
\begin{proof}
\hfill\qed
\end{proof}
@


1.15
log
@*** empty log message ***
@
text
@d74 49
a122 3
Providing a proof of security for the Unix algorithm without the
``uniformity'' assumption seems to require some different ideas,
and we leave it as an open problem for the community.
a123 9
In this paper, we take an important step towards security for
non-uniformly distributed passwords: we show how to make a simple,
efficient modification to the Unix hash algorithm that lets us
prove security for arbitrary distributions.
Our approach is based on {\em key whitening}, and it lets us
prove near-optimal security bounds without making any additional
assumptions
(for instance, we do not assume anything about the behavior of
DES or the Unix hash when used with non-uniformly distributed keys).
a124 4
Key whitening can also be used to operate other
cryptographic primitives (block ciphers, stream ciphers, \ldots)
securely in environments where the key is non-uniformly distributed,
so this result may be of considerable independent interest.
@


1.14
log
@*** empty log message ***
@
text
@d901 2
d904 101
a1005 1
{\sc Applications to other crypto primitives.}
@


1.13
log
@*** empty log message ***
@
text
@d26 2
a27 2
deployment in millions of systems worldwide it still has
not been proven safe.
d29 1
a29 1
(under some cryptographic assumptions) for the Unix algorithm.
d32 1
a32 1
a standard block cipher.
d36 1
a36 1
However, so far no such proof has appeared in the open literature.
d40 1
a40 1
approach is likely to be sound.
d42 1
a42 1
the algorithm they analyze omits some important features of
d62 1
a62 1
As a result, we are able to show surprisingly tight lower
d70 6
a75 4
The main practical shortcoming of our proof techniques is that
we---like Luby and Rackoff---must assume a uniform (or near-uniform)
distribution on the passwords.
Removing this assumption seems to require some different ideas,
d78 15
d101 4
d193 1
a193 1
that DES behaves like an ideal cipher, but this says nothing about
d275 2
d278 2
a279 1
any algorithm to break the one-way function, i.e. that can
d281 1
a281 1
break the cipher $E$, with a simple trick.
d297 1
a297 1
Furthermore, knowledge of $k'$ (different from $k$)
d301 3
d307 6
a312 2
Providing a correct proof is one of the major contributions
of this paper.
d430 1
a430 1
\begin{itemize}
d438 1
a438 1
\end{itemize}
d448 1
a448 1
\des_k(x_{24} \oplus \des_k(x_{23} \oplus \ldots \des_k(x_1 \oplus \des_k(x_0))\ldots )).
@


1.12
log
@*** empty log message ***
@
text
@d79 1
a79 1
Section~\ref{sec:summary}.
d131 1
a131 1
\label{sec:summary}
d135 1
a135 1
If DES is a $(t',25,e')$-secure block cipher, then the Unix password
d137 2
a138 3
$(t,e)$-secure password hashing function,
where $t \approx t'$ and
$e = (1+1/255) (e' + 1875/2^{65})$.
d186 1
a186 1
If we try $t'$ keys, the probability of success for exhaustive
d188 1
a188 1
property, and thus $e' = t'/2^{55}$, not $t'/2^{56}$ as one might naively
d190 2
a191 2
is $e' = t'/2^{55}$.
Therefore, DES appears to be $(t',25,t'/2^{55})$-secure.
d193 1
a193 1
$(t,e)$-secure
d199 1
a199 1
for $e \approx (1 + 1/255) t/2^{55}$, which is only larger
d240 2
a241 1
A similar result holds for any PRF or any stream cipher.
d246 10
a255 6
{\sc Non-triviality.}
One might wonder whether our result is in fact trivial.
We argue that it is not.

An obvious line of approach might go like this (stated informally).
Any algorithm to break the one-way function, i.e.  that can
d258 1
a258 1
The trick is to first request the encryption of
d267 2
a268 1
recover $k$ from $y=h(k)$; it suffices to recover some
d289 32
a320 11
However, our definitions (and proofs) of security assume
that passwords, and keys, are chosenrom a uniform distribution.

This is a serious limitation of our result: we do not know how to
prove that the Unix password hash function is secure when users pick
patterned passwords.
We would like to believe, optimistically, that the best attack on
non-uniform passphrases is the dictionary attack, where one tries
the passwords in order of decreasing probability.
However, we have absolutely no evidence for this,
and we leave this question as an open problem for the research community.
d339 1
a339 2
salting does not hurt the one-wayne  ss of the Unix construction
when viewed one user at a time.
d365 2
a366 2
Though we cannot prove that iteration is stronger than no iteration,
we do prove that iteration doesn't hurt.
d369 2
a370 1
associated with iteration by analyzing only the uniterated construction.
d403 2
a404 3
\item Next, we establish
some new results on the concrete security of one-way functions
constructed from pseudo-random functions,
d408 1
a408 1
The rest of the paper is entirely standard.
d427 1
a427 7
        \begin{center} \frame{\parbox{2.7in}{
        \begin{center} \parbox{2.5in}{ \begin{center}
        \[ \mbox{Unix-hash}(k) = \mbox{DES-CBC-MAC}_k(0). \]
        \end{center}
        } \end{center}
        }}
        \end{center}
d442 1
a442 1
a secure PRG if DES-CBC-MAC is a secure PRF.
d461 11
d473 1
a473 2
First, we formally define the concept of a pseudo-random function,
or PRF for short.
d496 2
a497 1
A pseudo-random generator (PRG) is a function $g : \K \to \Y$.
d508 1
a508 4
An adversary $B$ attacking $h$
is a deterministic\footnote{We may assume the algorithm
to be deterministic without loss of generality, since any
probabilistic adversary can be de-randomized using standard techniques.}
d533 2
a534 1
Let $g : \K \to \Y$ be a $(t,e)$-secure PRG, with $|\Y| > |\K|$.
d573 1
a573 1
All probabilities are calculated with respect to the distribution of $k$.
d613 1
d616 1
a616 1
\begin{theorem}
d623 1
d636 1
d644 1
d670 1
d673 2
d687 1
a687 1
\[ \rho_D(t) = \max \{D(S) : S \subset \K, |S| \le t\}. \]
d695 1
a695 1
which $(t,\rho_D(t))$-breaks $f$.
d705 2
a706 1
furthermore, this quantity is precisely $\rho_D(t)$.
d708 1
a708 1
Therefore, $\rho_D$ describes the effectiveness of the optimal
d712 1
a712 1
$\rho_D(t)$ and time $t$.
d720 1
a720 1
$f$ is $(t,\rho_D(t))$-secure (for all $t$)
d727 2
a728 1
close to this ideal.
d735 1
a735 2
$g$ is a $(t,\rho_D(p|\K|))$-secure
one-way hash function for inputs distributed according to $D$.
d738 4
a741 4
Let $A$ be an adversary which $(t,p')$-breaks $g$ (for $D$),
where $p' \ge \rho_D(p|\K|)$.
We will exhibit an algorithm $B$ which $(t,p)$-breaks $f$ (for uniformly
distributed inputs); then taking the contrapositive
d745 1
a745 1
be the set of $g$-inputs which are not safe against $A$,
d749 3
a751 2
so there must be some $w \in \K$ with $D(S_w) \ge \rho_D(p|\K|)$.
Since $D(S_w) \le \rho_D(|S_w|)$ (by the definition of $\rho_D$),
d753 1
a753 1
Fix such a $w$.
d755 3
a757 4
We now define the adversary $B$ that breaks $f$
by $B(y) = A(w,y)+w$.
Clearly $B$ runs in time $t$, so we only need to show
that its success probability is at least $p$.
d759 1
a759 1
  $\Pr[B(f(k)) \ne \bot]$, where $k \in_R \K$ is chosen
d761 5
a765 5
Note that $B$ succeeds on $y=f(k)$ whenever $k-w \in S_w$,
and $k$ is independent of $w$, so
\[ \Pr[B(f(k)) \ne \bot] \ge \Pr[k-w \in S_w] = |S_w|/|\K| \ge p. \]
Therefore, we have exhibited an adversary $B$ which shows
that $f$ is not $(t,p)$-secure, which proves the theorem.
d774 1
a774 1
we have $\rho_U(t) = t/|\K|$, so by assumption
d777 3
a779 2
$(t,\rho_D(t))$-secure for all distributions $D$,
since $\rho_D((t/|\K|) \cdot |\K|) = \rho_D(t)$.
d784 1
a784 1
%then $g$ is $(\alpha^{-1}(\rho^{-1}(p')/|\K|),p')$-secure for all $p',D$.
d787 86
d882 7
d893 1
a893 2
relevance of the leftover hash lemma to non-uniformly
distributed secrets.
d911 1
@


1.11
log
@*** empty log message ***
@
text
@d651 1
a651 1
Then we define
d654 12
d667 5
a671 2
$d_1 \ge d_2 \ge d_3 \ge \cdots$, we can see that
$\rho_D(t) = d_1 + d_2 + \cdots + d_t$.
d676 1
a676 4
$\rho_D(t)$ and time $t$,
just by trying the $t$ highest probability elements of $D$.
There is no way to prevent the dictionary attack, except using
a password with sufficient entropy.
d678 3
a680 4
Optimistically, we would like there to be no better attack than
the dictionary attack.
Thus, we are seeking an {\em ideally-secure} password hash
function, defined as follows:
d682 4
a685 3
We say that the one-way function $f$ is {\em ideally-secure} if,
for all distributions $D$,
$f$ is $(t,\rho_D(t))$-secure when inputs are chosen according to $.
d687 3
d692 1
a692 2

\begin{theorem}
d702 5
a706 3
Let $A$ be an adversary for $g$ which runs in time at most $t$.
We will show that $A$'s success probability is at most
$\rho_D(p|\K|)$.
d711 6
a716 10
If $|S_w| \ge p|\K|$ were to hold for any $w \in \K$, then there would
exist an adversary $B$ that $(t,p)$-breaks $f$, contradicting the
assumption about $f$ in the statement of the theorem.
(For example, the algorithm
defined by $B(y) = A(w,y)+w$ is one such adversary;
if we pick $k \in_R \K$ randomly and set $y=f(k)$, then
$B$ will succeed whenever $k-w \in S_w$,
and $\Pr[k-w \in S_w] = |S_w|/|\K| \ge p$ when $k$ is uniformly distributed.)
Therefore, for the remainder of the argument we may safely
assume that $|S_w| < p|\K|$ for all $w \in \K$.
d718 25
a742 5
Now observe that
\[ p' = {1 \over |\K|} \sum_{w \in \K} D(S_w). \]
Furthermore, $D(S_w) \le \rho_D(|S_w|)$ (by the definition of $\rho_D$)
and $\rho_D(|S_w|) \le \rho_D(p|\K|)$,
so $p' \le \rho_D(p|\K|)$, which is what we wanted to prove.
@


1.10
log
@*** empty log message ***
@
text
@a4 1
\newcommand{\H}{{\cal H}}
d8 1
d402 2
a403 2
        \begin{center} \frame{\parbox{5.7in}{
        \begin{center} \parbox{5.5in}{ \begin{center}
a404 1
        \vskip 0.2in
d664 1
a664 2
a password with sufficient entropy so that $\rho_D(t)$ is very small
for reasonably values of $t$.
d680 3
a682 3
inputs, and define $g(x) = (h, f(h(x)))$ where $h:\K \to \K$
is chosen uniformly at random from a family $\H$ of invertible
universal hash functions.
d688 3
a690 3
Suppose, for some distribution $D$, there is an adversary $A$
that $(t,p')$-breaks $g$.
We will show t  hat $p' \le \rho_D(p|\K|)$.
d692 1
a692 1
Let $S_h = \{k \in \K : A(h,f(h(k))) \ne \bot\}$
d694 2
a695 2
  when the hash function used is $h$.
If $|S_h| \ge p|\K|$ were to hold for any $h \in \H$, then there would
d699 1
a699 1
defined by $B(y) = h(A(h,y))$ is one such adversary;
d701 2
a702 2
$B$ will succeed whenever $k \in h(S_h)$, and $|h(S_h)| \ge |S_h| \ge p|\K|$
so $\Pr[k \in h(S_h)] \ge p$.)
d704 1
a704 1
assume that $|S_h| < p|\K|$ for all $h \in \H$.
d706 4
a709 4
Note that
\[ p' = {1 \over |\H|} \sum_{h \in \H} D(S_h). \]
Furthermore, $D(S_h) \le \rho_D(|S_h|)$ (by the definition of $\rho_D$)
and $\rho_D(|S_h|) \le \rho_D(p|\K|)$,
a718 1
\subsection{Exploiting stronger block ciphers}
d720 3
a722 8
\subsection{Smoothing password entropy}

\subsection{Discussion}

This can be recognized as a limitation of the classical definitions of
security for cryptographic primitives: they always assume a uniform
distribution on the secrets or keying material.
To `
@


1.9
log
@*** empty log message ***
@
text
@d5 1
d394 3
a396 6
Then it is not hard to see that in fact the Unix password
hashing algorithm $H$ can be related to the DES-CBC-MAC
by the very simple relation
\[ H(k) = \mbox{DES-CBC-MAC}_k(00\ldots 0). \]
(Here $00\ldots 0$ stands for the
all-zeros message of the appropriate length.)
d400 13
d588 23
a610 5
\begin{theorem}\label{th:desprf}
Suppose DES is a $(t',25,e')$-secure block cipher.
Let $t=t'-25c'/2^{64}$ and $e=e' + 3 \cdot 25^2/2^{65}$.
(Here $c'$ is a constant which depends only on the machine model.)
Then DES-CBC-MAC is a $(t,1,e)$-secure PRF.
a611 3
\begin{remark} In practice, the constant $c$ is small enough
that $25c'/2^{64}$ is negligible compared with $t$, and thus we
should think of $t'$ as approximately $t$. \end{remark}
d613 1
a613 8
First, if DES is a $(t',25,e')$-secure block cipher,
then a well-known argument based on the birthday paradox shows
that it is a $(t',  25,e'+25^2/2^{65})$-secure PRF.
\marginpar{Citation for birthday argument?}
Next, we use a result of Bellare, Kilian, and Rogaway
that CBC-MAC makes a secure PRF \cite{BKR94};
specifically, Lemma 4.1 assures us that
it is $(t,1,e)$-secure.
d617 7
d641 90
d738 3
@


1.8
log
@*** empty log message ***
@
text
@d537 1
a537 1
Let $V = \{y : B(y) \ne \bot\}$ be the set of outputs of $h$ where
d539 1
a539 1
Also, let $W = \{k \in K : h(k) \in V\}$ be the set of inputs to $h$
@


1.7
log
@*** empty log message ***
@
text
@d4 3
d137 2
a138 2
where $t = t'-25c'/2^{64}-c$ and
$e = (1+1/255)e' + 3 \cdot (1+1/255) \cdot 25^2/2^{65}$.
d155 3
a157 1
cryptographic assumptions on the security of DES---``you cannot make good wine
d159 2
a160 1
wonderful analogy.}---to prove anything about the Unix scheme.
a167 1

d170 1
d222 11
d251 1
a251 1
recover $k$ from $y = g(k) = E_k(0)$, can also be used to
d255 1
a255 1
ciphertext using the algorithm for breaking $g$,
d261 3
a263 3
To break a one-way function $g$, you don't need to
recover $k$ from $y=g(k)$; it suffices to recover some
$k'$, possibly different from $k$, such that $g(k') = y$.
d277 3
d330 5
a334 5
As a result, our lower bounds are 50 times worse than brute-froce
search over all possible passwords, which takes $25 \times 2^{56}$
DES operations
(we lose a factor of 25 in the proof due to the iteration, and another factor
of 2 due to the DES complementation property).
d339 5
a398 1

d402 4
a405 4
The second idea involves some technical analysis of the
construction of a one-way function $g$ from a pseudo-random function $F$
as $g(k) = F_k(0)$.
This is basically a counting argument to bound the number of keys
d409 7
a415 8
With these two ideas, one can express the security of the Unix
password hashing function in terms of
the security of DES-CBC-MAC.
Then we apply some well-known results from Bellare et. al. \cite{BKR94}
to express the security of DES-CBC-MAC in terms of the security of DES.
Finally, we are able to obtain powerful bounds on the security
of the Unix password hashing algorithm,
if we make some mild assumptions on the security of DES.
d419 4
a422 3
of the construction of a one-way function $g$ as $g(k) = F_k(0)$,
where $F$ is an arbitrary pseudo-random function.
This bound shows that the construction preserves the security of $F$
d424 5
a428 10
Since this is about the best we could hope for in an
information-theoretic analysis, this means that the bound is
(roughly speaking) nearly ``tight''.

This security analysis of the construction $g(x) = F_x(0)$
may be of independent interest, as it shows
that a very simple construction with excellent performance can be
used to build a one-way function from a trusted pseudo-random function
with essentially no degradation of security.
This is the best result in this direction that we know of.
d432 1
d435 1
a435 6
Let $F : \Z_2^{\eta} \times K \to \Z_2^{\nu}$ be
a keyed function with $\kappa$-bit key, $\eta$-bit input,
and $\nu$-bit output.
Also, let $\{R_k : k \in K\}$ be a family of $|K|$
functions chosen independently and uniformly at random from the set of
all functions with signature $\Z_2^{\eta} \to \Z_2^{\nu}$.
d440 5
a444 4
The advantage $\Adv A$ is defined to be
\[ \Adv A = \left| \Pr[A^{F_k} = 1] - \Pr[A^{F'_k} = 1] \right|, \]
where the probability is taken over $k$, and the random variable $k$ is
drawn from the uniform distribution over $K$.
d448 22
a469 5
Also, it is useful to have the concept of a one-way function,
or OWF for short.
Let $g : {\cal D} \to \Z_2^{\nu}$ be an unkeyed function.
An adversary $B$ attacking $g$
is a deterministic\footnote{We may assume the adversary
d471 3
a473 3
probabilistic algorithm can be de-randomized with standard results.}
algorithm with input $h \in \Z_2^{\nu}$
which outputs a symbol in ${\cal D} \cup \{\perp\}$,
d475 2
a476 2
$B$ is correct when $B(h) \ne \perp$ implies that $g(B(h)) = h$, for all $h$.
We say that an adversary $B$ $(t,e)$-breaks the alleged-OWF $g$
d478 5
a482 6
\[ \Pr[B(g(x)) \ne \perp] = e, \]
where the probability is taken over the choice of $x$,
and the random variable $x$ is drawn from the uniform distribution
over ${\cal D}$.
Finally, we say that $g$ is a $(t,e)$-secure OWF
if there is no adversary which $(t,e)$-breaks it.
d486 2
a487 3
In particular, if $g$ is a $(t,e)$-secure OWF, then the success
probability of any adversary running in time $t$ is at most $e$.
\marginpar{proof?}
d492 7
a498 8
\begin{theorem}\label{th:prf2owf}
Let $F : \Z_2^{\nu} \times \Z_2^{\kappa} \to \Z_2^{\eta}$
be a $(t',1,e')$-secure PRF with $\kappa$-bit key and $\eta$-bit output,
where $\kappa < \eta$.
Define the funct  ion $g : \Z_2^{\kappa} \to \Z_2^{\eta}$ by $g(x) = F_x(0)$,
and let $t = t'-c$ and $e = e'/(1-2^{\kappa-\eta})$,
(Here $c$ is a constant which depends only on the machine model.)
Then $g$ is a $(t,e)$-secure one-way function.
d500 21
a520 17
\begin{remark} In practice, $c$ is typically negligible compared to $t$,
and thus we should think of $t$ as approximately equal to $t'$. \end{remark}
\begin{remark} When $\kappa \ge \eta$, the theorem says nothing useful.
Nonetheless, very effective techniques are still available to construct
a useable one-way function with not too much loss in security.
For example, if $F$ is $(t'',m,e'')$-secure,
we may use the construction of Theorem~\ref{th:prf2prf} to build
a new $(t'',1,e'')$-secure PRF
$\bar{F} : \Z_2^{\nu-m} \times \Z_2^{\kappa} \to \Z_2^{m\eta}$ with
outputs $m$ times as wide as $F$,
and then apply Theorem~\ref{th:prf2owf} to $\bar{F}$ to obtain a
$(t''-c,e''/(1-2^{\kappa-m\eta})$-secure one-way function $g$ as
$g(x) = \bar{F}_x(0)$.
For typical PRF algorithms that arise in practice,
it is often possible to get quite close to the best possible result
with an appropriate chioce of $m$.  \end{remark}
\begin{proof}[of Theorem~\ref{th:prf2owf}]
d522 14
a535 13
Suppose that there is an adversary $B$ which $(t,e)$-breaks $g$.
We construct an adversary $A$ against $F$ as
$$A^f = \left\{ \begin{array}{ll}
	1\qquad	&\mbox{if }B(f(0)) \ne \perp \\
	0	&\mbox{otherwise}
	\end{array} \right..$$
Our claim is that $A$ $(t',1,e')$-breaks $F$.
Clearly $A$ makes exactly one query to $F$, and runs in time $t'=t+c$ for
a very small constant $c$,
so it only remains to show that $\Adv A \ge (1 - 2^{\kappa-\eta}) \cdot e$.
A bit of notation: we let $k$ stand for a the random variable
uniformly distributed over $K$; all probabilities are calculated
with respect to the distribution of $k$.
d537 1
a537 1
Let $Y = \{h : B(h) \ne \perp\}$ be the set of outputs of $F$ where
d539 1
a539 1
Also, let $W = \{k \in K : g(k) \in Y\}$ be the set of inputs to $g$
d541 1
a541 1
We see that $e = \Pr[g(k) \in Y] = \Pr[k \in W]$.
d543 1
a543 1
Next, we observe that $|Y| \le |W|$.
d547 3
a549 3
We examine $B'$, the restriction of $B$ to the domain $Y$.
This restriction is well-defined, since when $h \in Y$,
$B(h)$ is a well-defined element of $K$.
d551 2
a552 2
$g(B(h)) = h \in Y$ for all $h \in Y$,
so that $B(h) \in W$ for all $h \in Y$.
d554 6
a559 5
a function with signature $Y \to W$.
Moreover $B'$ is one-to-one, since $B(h) = B(h')$ for $h,h' \in Y$
implies $h = g(B(h)) = g(B(h')) = h'$.
In summary, we have exhibited a one-to-one function from $Y$ to $W$;
this shows that $|Y| \leq |W|$.
d563 8
a570 11
$$\Pr[A^{F_k} = 1] = \Pr[B(F_k(0)) \ne \perp] = \Pr[F_k(0) \in Y]
= \Pr[g(k) \in Y] = e.$$
Furthermore, since $F'_j(0)$ is uniformly distributed when $j$ is, we see that
$$\Pr[A^{F'_j} = 1] = \Pr[F'_j(0) \in Y] = |Y| \cdot 2^{-\eta}.$$
Also $|W| = 2^{\kappa} \Pr[k \in W] = 2^{\kappa} e$ and $|Y| \le |W|$, so
$$|Y| \cdot 2^{-\eta} \le |W| \cdot 2^{-\eta} = e \cdot 2^{\kappa-\eta}.$$
In other words, $\Pr[A^{F'_j} = 1] \le 2^{\kappa-\eta} e$.
Plugging this into the definition of $\Adv A$ gives
$$\Adv A \ge | e - 2^{\kappa - \eta} e | = (1 - 2^{\kappa-\eta}) \cdot e = e'.$$

This proves our claim.
d572 3
a574 4
which $(t,e)$-breaks $g$,
we obtain an adversary $A$ which shows that $F$ is not
$(t',1,e')$-secure.
The desired result follows.
@


1.6
log
@*** empty log message ***
@
text
@d123 1
a123 1
at the end, we show how to add the effects of the salt back in
d138 1
a138 1
Some inrpration of this analytical result is clearly in order.
d154 1
a154 1
wonderful quote.}---to prove anything about the Unix scheme.
d158 4
d172 1
d180 5
a184 3
If we try $t'$ keys, our probability of success will be
$e' = t'/2^{55}$ with exhaustive keysearch\footnote{The $2^{55}$ figure
appears because we take into account the DES complementation property.}.
d187 9
a195 3
$(t,e)$-secure for $t \approx t'$
and $e = 256/255 (e' + 3 \cdot 25^2/2^{65})$,
or approximately when $e > (1 + 1/255) \cdot (t+1.831)/2^{55}$.
d199 2
a200 2
the chances  breaking the Unix password hash are (at most) only
slightly higher (less than 1\%) than the chances of breaking DES.
d205 7
a211 4
For comparison, exhaustive keysearch will $(t,t/2^{56})$-break the
Unix hashing algorithm.
This is close to the proven lower bounds (we loose a factor of two
due to the DES complementation property).
d214 1
a214 3
cannot do much better than simply exhaustively try all possible passwords.

{\sc A trivial result?}
d216 43
d263 11
a273 1
\ldots
d277 20
a296 1
\ldots
d299 22
d343 1
a343 1
\section{Analyzing the hash: A high-level outline}
d346 3
a348 2
This paper essentially contains only two new ideas.
First, we show that the Unix password hashing algorithm
d350 2
a351 1
Next, we establish
d356 1
d375 3
d380 4
a383 2
as $g(x) = F_x(0)$;
see Section~\ref{sec:analysis} for the details.
d396 1
a396 1
of the construction of a one-way function $g$ as $g(x) = F_x(0)$,
@


1.5
log
@*** empty log message ***
@
text
@d12 3
a14 1
\begin{abstract} \ldots \end{abstract}
d168 14
a181 8

%In particular, we have obtained concrete bounds on its security.
Let us suppose that DES is $(t',25,e')$-secure when $e' > t'/2^{55}$;
we are not aware of any attacks reported in the open literature which
suggest otherwise\footnote{We use the $2^{55}$ figure to take into
account the DES complementation property.}.
In this case, we have proven that the Unix scheme is $(t,e)$-secure
when $t \approx t'$ and $e = 256/255 (e' + 3 \cdot 25^2/2^{65})$,
d183 8
d193 9
a201 4
hashing algorithm.
In other words, assuming that there are no better attacks on DES,
an adversary attacking the Unix password hashing functi cannot do
much better than simply exhaustively try all possible passwords.
d203 1
d208 1
d212 3
a340 2

ection{Results}
@


1.4
log
@*** empty log message ***
@
text
@d6 1
d16 17
a32 6
The Unix password hashing function is over 20 years old
and deployed in millions of systems worldwide.
The construction is a fairly simple application of DES,
which has seen many man-years of analysis, so we might
hope for a proof that the Unix password hash is secure if DES is.
However, no such proof has appeared in the open literature yet.
d34 16
a49 11
approach is likely to be sound, by showing that asymptotically
it is secure if one abstracts away some important features of the
hash construction and assumes a uniform distribution on
passwords \cite{?}, but the security of the real
Unix password hash remains an open question.

In this paper, we take a further step towards proving that
the password hash is secure if DES is.
First, we show how to analyze the full construction,
removing the needo abstract away features of the hash;
this removes the gap between what has been analyzed and
d51 5
a55 2
Second, we provide explicit security measures instead of
asymptotic estimates.
d58 1
d60 9
a68 9
of one-way functions from block ciphers can be both very
efficient and strongly security-preserving; this result
may be of independent interest.

The main practical shortcoming of our results is that
we too must assume a uniform (or near-uniform) distribution
on the passwords for our proof of security to work.
Removing this assumption seems to require some different ideas;
we leave it as an open problem for the community.
d86 2
a87 2
function {\tt crypt}.
The function {\tt crypt} is built out of a 25-fold
d89 12
a100 10
If we let $E_k(x)$ denote the DES encryption of plaintext $x$
under key $k$, and $E_k^n(x)$ denotes the $n$-fold iteration
of $E_k$ (i.e. $E_k^{n+1}(x) = E_k(E_k^n(x))$ and $E_k^0(x)=x$),
then the hash ${\tt crypt}(k)$ of the 8-character
password $k$ may be defined as
\[ {\tt crypt}(k) = E_k^{25}(0). \]
Finally, the hashed password ${\tt crypt}(k)$ is stored with
the user's id in the system password file {\tt /etc/passwd}.
When a user attempts to log on with password $k'$, 
the system computes ${\tt crypt}(k')$ and compares the result
d102 1
a102 1
to log on only if ${\tt crypt}(k') = {\tt crypt}(k)$.
d104 2
a105 2
Actually, this description of {\tt crypt} has omitted one
important feature of {\tt crypt}: the salt.
d108 3
a110 3
the salted hash ${\tt crypt}_s(k)$ from $k$ and $s$.
The salted hash is defined as ${\tt crypt}_s(k) = E_{k,s}^{25}(0)$,
where $E_{k,s}(x)$ refers to the DES encryption of plaintext $x$
d114 1
d118 5
d127 54
d182 3
a184 12
Thanks to more than two decades of intensive analysis,
DES is probably better-understood
than any other modern encryption algorithm\footnote{At least in the
open community, anyway.}.
Since the Unix password hashing function {\tt crypt}
is built out of DES in a relatively simple way,
one might optimistically hope that it might be possible to
apply all the research on the security of DES to understanding
the security of {\tt crypt}.
This paper shows that this hope is in fact achievable,
and moreover that very strong lower bounds on the security
of {\tt crypt} are available.
d186 1
a186 1
For the bulk of this paper, we shall ignore the salting mechanism.
d189 18
a206 2
We rely heavily on the formal techniques of concrete security analysis
developed in \cite{?} \ldots
d229 1
a229 1
E_k(x_{24} \oplus E_k(x_{23} \oplus \ldots E_k(x_1 \oplus E_k(x_0))\ldots )),
a230 1
where $E_k(x)$ represents the DES encryption of $x$ under key $k$.
d232 1
a232 1
hashing algorithm {\tt crypt} can be related to the DES-CBC-MAC
d234 1
a234 1
\[ {\tt crypt}(k) = \mbox{DES-CBC-MAC}_k(00\ldots 0). \]
d427 1
a427 1
hashing function {\tt crypt} is a
d436 3
a438 4
Letting $F$ = DES-CBC-MAC and $g(x) = F_k(0)$, we see that
$g$ = {\tt crypt3}.
Also, Theorem~\ref{th:prf2owf} shows that
$g$ is a $(t,e)$-secure one-way function with
a442 25

This analysis shows that if DES is secure against all attacks
using at most 25 chosen plaintexts, and if the password is chosen
uniformly at random, then {\tt crypt} is secure
against password guessing attacks.
In particular, we have obtained concrete bounds on the security
of {\tt crypt}.
Let us suppose that DES is $(t',25,e')$-secure when $e' > t'/2^{55}$;
we are not aware of any attacks reported in the open literature which
suggest otherwise\footnote{We use the $2^{55}$ figure to take into
account the DES complementation property.}.
In this case, we have proven that {\tt crypt} is $(t,e)$-secure,
where $t \approx t'$ and $e = 256/255 (e' + 3 \cdot 25^2/2^{65})$,
or approximately when $e > (1 + 1/255) \cdot (t+1.831)/2^{55}$.
For comparison, exhaustive keysearch will $(t,t/2^{56})$-break {\tt crypt}.
In other words, assuming that there are no better attacks on DES,
an adversary attacking the Unix password hashing function cannot do
much better than simply exhaustively try all possible passwords.

In practice, passwords are rarely chosen uniformly at random from
the entire 56-bit keyspace.
\ldots

Another practical consideration is the use of salting.
\ldots
@


1.3
log
@*** empty log message ***
@
text
@d290 1
a290 1
a function with signature $Y->W$.
@


1.2
log
@*** empty log message ***
@
text
@d15 48
a62 3
In this paper, we analyze the security of the Unix password
hashing function, also called {\tt crypt} or {\tt crypt(3)}.
\ldots
d95 4
d118 4
d380 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
\documentclass{llncs}
@


1.1.1.1
log
@
@
text
@@
